<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils_$_attr-linked.js.html":{"id":"utils_$_attr-linked.js.html","title":"Source: utils/$_attr-linked.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/$_attr-linked.js const regAttr = /=&quot;*'*\\{*([_a-z\\-0-9$]+)}*'*&quot;*/; const regStart = /^\\[/; const $ = window.rb.$; /** * Finds attribute linked elements on the first element in collection. * @function external:&quot;jQuery.fn&quot;.attrLinked * @param {String} attributeSelector Attribute selector pattern to search for. (&quot;[aria-controls=&quot;${id}&quot;]&quot;) * @returns {jQueryfiedObject} * * @example * * //&lt;div id=&quot;yo&quot;&gt;&lt;/div&gt; * //&lt;a data-target=&quot;yo&quot;&gt;&lt;/a&gt; * * $('#yo').attrLinked('data-target={id}'); // returns '[data-target=&quot;yo&quot;]' elements. * $('#yo').attrLinked('data-target={id}').attrLinked('id={data-target}'); // returns '[id=&quot;yo&quot;]' elements. */ $.fn.attrLinked = function (attributeSelector) { let newCollection; let elem = this.get(0); if (elem) { const valueAttr = attributeSelector.match(regAttr); if(valueAttr){ let value = elem[valueAttr[1]]; if(!value || typeof value != 'string'){ value = elem.getAttribute(valueAttr[1]) || ''; } if(!regStart.test(attributeSelector)){ attributeSelector = `[${attributeSelector}]`; } newCollection = $(attributeSelector.replace(regAttr, `=&quot;${value}&quot;`)); } } return newCollection || $([]); }; × Search results Close "},"utils_$_closest-find.js.html":{"id":"utils_$_closest-find.js.html","title":"Source: utils/$_closest-find.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/$_closest-find.js const regSplit = /\\s*?,\\s*?|\\s+?/g; const $ = window.rb.$; /** * Invokes on the first element in collection the closest method and on the result the querySelector method. * @function external:&quot;jQuery.fn&quot;.closestFind * @param {String} selectors Two selectors separated by a white space and/or comma. First is used for closest and second for querySelector. Example: `&quot;.rb-item, .item-input&quot;`. * @returns {jQueryfiedObject} */ $.fn.closestFind = function (selectors) { let sels; let closestSel, findSel; let elem = this.get(0); if (elem) { sels = selectors.split(regSplit); closestSel = sels.shift(); findSel = sels.join(' '); elem = elem.closest(closestSel); if (elem) { elem = elem.querySelector(findSel); } } return $(elem || []); }; × Search results Close "},"utils_$_slide-up-down.js.html":{"id":"utils_$_slide-up-down.js.html","title":"Source: utils/$_slide-up-down.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/$_slide-up-down.js const $ = window.rb.$ || window.jQuery || {fn: {}}; function calcDuration(smallValue, bigValue, options){ return Math.min( (options.durationBase || 350) + ((bigValue - smallValue) * (options.durationMultiplier || 0.3)), options.durationMax || 900 ); } /** * A jQuery/rb.$ plugin to slideUp content. Difference to $.fn.slideUp: The plugin handles content hiding via height 0; visibility: hidden; * Also does not animate padding, margin, borders (use child elements) * @function external:&quot;jQuery.fn&quot;.rbSlideUp * @param [options] {object} All jQuery animate options * @param options.beforeCalculation {Function} * @param options.durationMax=900 {Number} * @param options.durationBase=350 {Number} * @param options.durationMultiplier=0.3 {Number} * @returns {jQueryfiedDOMList} */ $.fn.rbSlideUp = function (options) { if (!options) { options = {}; } if (this.length) { const opts = Object.assign({}, options, { always: function () { this.style.display = options.display ? 'none' : ''; this.style.visibility = 'hidden'; if (options.always) { return options.always.apply(this, arguments); } }, }); if (opts.easing) { rb.addEasing(opts.easing); } this .stop() .each(()=&gt;{ const $panel = $(this); if(options.duration == 'auto'){ opts.duration = calcDuration(0, $panel.innerHeight(), options); } $panel.animate({height: 0}, opts); }) .css({overflow: 'hidden', display: 'block', visibility: 'inherit'}) ; } return this; }; /** * A jQuery/rb.$ plugin to slideDown content. Difference to $.fn.slideDown: The plugin handles content showing also using visibility: 'inherit' * Also does not animate padding, margin, borders (use child elements) * @function external:&quot;jQuery.fn&quot;.rbSlideDown * @param options {object} All jQuery animate options and options below * @param options.beforeCalculation {Function} * @param options.durationMax=900 {Number} * @param options.durationBase=350 {Number} * @param options.durationMultiplier=0.3 {Number} * @param options.getHeight {Boolean} * @returns {jQueryfiedDOMList|Number} */ $.fn.rbSlideDown = function (options) { var opts; var ret = this; if (!options) { options = {}; } if (this.length) { opts = Object.assign({}, options, { always: function () { this.style.overflow = ''; this.style.height = 'auto'; if (options.always) { return options.always.apply(this, arguments); } }, }); if (opts.easing &amp;&amp; !rb.$.easing[opts.easing]) { rb.addEasing(opts.easing); } } this.each(function () { var endValue; var $panel = $(this); var startHeight = $panel.innerHeight(); $panel.css({overflow: 'hidden', display: 'block', height: 'auto', visibility: 'inherit'}); if(options.beforeCalculation){ options.beforeCalculation($panel); } endValue = $panel.innerHeight(); if(options.getHeight){ ret = endValue; } if(typeof process != 'undefined' &amp;&amp; process.env &amp;&amp; process.env.NODE_ENV != 'production'){ if(options.autoDuration){ rb.logError('use duration=&quot;auto&quot; instead of options.autoDuration'); } } if(options.duration == 'auto'){ opts.duration = calcDuration(startHeight, endValue, opts); } $panel .css({height: startHeight}) .animate({height: endValue}, opts) ; }); return ret; }; × Search results Close "},"utils_scrollintoview.js.html":{"id":"utils_scrollintoview.js.html","title":"Source: utils/scrollintoview.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/scrollintoview.js const regHash = /^#/; const $ = window.rb.$ || window.jQuery; /** * A jQuery/rb.$ plugin to scroll an element into the viewport * @function external:&quot;jQuery.fn&quot;.scrollIntoView * @param options {object} All jQuery animate options and additional options * @param options.focus {Element} Element that should be focused after animation is done. * @param options.hash {String} Hash to set on the location object * @param options.scrollingElement {Element} * @param options.durationBase=350 {Number} * @param options.durationMax=700 {Number} * @param options.durationMultiplier=0.2 {Number} * * @returns {jQueryfiedDOMList} */ $.fn.scrollIntoView = function (options) { let bbox, distance, scrollingElement, opts, focus, pos; const elem = this.get(0); if (elem) { options = options || {}; bbox = elem.getBoundingClientRect(); distance = Math.max(Math.abs(bbox.top), Math.abs(bbox.left)); scrollingElement = options.scrollingElement || rb.getPageScrollingElement(); pos = { scrollTop: bbox.top + (options.offsetTop || 0), scrollLeft: bbox.left + (options.offsetLeft || 0), }; if(!options.scrollingElement || options.scrollingElement.contains(elem)){ pos.scrollTop += scrollingElement.scrollTop; pos.scrollLeft += scrollingElement.scrollLeft; } if (options.easing) { rb.addEasing(options.easing); } if (!options.duration) { options.duration = Math.min(options.durationMax || 700, (options.durationBase || 350) + (distance * (options.durationMultiplier || 0.2))); } opts = Object.assign({}, options, { always: function () { let top, left, hash; if (options.forcePosition) { top = scrollingElement.scrollTop; left = scrollingElement.scrollLeft; } if ( (focus = options.focus) ) { let focusType = typeof focus; if(focusType == 'boolean'){ focus = elem; } else if(focusType == 'string'){ focus = regHash.test(focus) ? document.querySelector(focus) : document.getElementById(focus); } if(focus){ rb.setFocus(focus); } } if (options.hash) { hash = typeof options.hash == 'string' ? options.hash : elem.id || elem.name ; if(hash){ location.hash = hash; } } if (options.forcePosition) { scrollingElement.scrollTop = top; scrollingElement.scrollLeft = left; } if (options.always) { options.always.call(elem); } }, }); $(scrollingElement).animate( pos, opts ); } return this; }; $.fn.rbScrollIntoView = $.fn.scrollIntoView; export default $.fn.scrollIntoView; × Search results Close "},"components_itemscroller-pagination.js.html":{"id":"components_itemscroller-pagination.js.html","title":"Source: components/itemscroller-pagination.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/itemscroller-pagination.js import rb, { Component } from '../core'; import './itemscroller'; const $ = Component.$; class ItemScrollerPagination extends rb.components.itemscroller { /** * @static * @mixes rb.components.itemscroller.defaults * * @property {String} paginationFor='' Reference to another scroller that should be paginated with this scroller instance. The value is processed by rb.elementFromStr. */ static get defaults(){ return { paginationFor: '', }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.updateScrollerAsPagination = rb.rAF(this.updateScrollerAsPagination, {that: this}); if (this.options.paginationFor) { this.setOption('paginationFor', this.options.paginationFor); } } static get events(){ return { 'click:closest(.{name}{e}cell)'(e) { if (!this.groupedMainComponent) { return; } this.groupedMainComponent.selectedIndex = this.$cells.index(e.delegatedTarget || e.currentTarget); }, }; } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); if (name == 'paginationFor') { if (value) { this._setupScrollerAsPagination(); } else { this._teardownScrollerAsPagination(); } } } updateScrollerAsPagination() { var cell; var selectedIndex = this.groupedMainComponent.selectedIndex; if (!this.$cells || !this.$cells.length) { return; } this.$cells.rbToggleState('selected{-}pagination', false); cell = this.$cells.eq(selectedIndex).rbToggleState('selected{-}pagination', true).get(0); if (this.isCellVisible(cell) !== true) { this.selectCell(selectedIndex); } } _setupScrollerAsPagination() { this._teardownScrollerAsPagination(); var paginationFor = this.options.paginationFor; if (!paginationFor) { return; } this.groupedMainElement = rb.elementFromStr(paginationFor, this.element)[0] || null; if (!this.groupedMainElement) { return; } this.groupedMainComponent = this.component(this.groupedMainElement); if (!this.groupedMainComponent) { return; } $(this.groupedMainElement).on(this.groupedMainComponent._evtName, this.updateScrollerAsPagination); this.updateScrollerAsPagination(); } _teardownScrollerAsPagination() { if (this.groupedMainComponent &amp;&amp; this.groupedMainElement) { $(this.groupedMainElement).off(this.groupedMainComponent._evtName, this.updateScrollerAsPagination); this.groupedMainComponent = null; this.groupedMainElement = null; } } } Component.register('itemscroller', ItemScrollerPagination, true); export default ItemScrollerPagination; × Search results Close "},"components_itemscroller-player.js.html":{"id":"components_itemscroller-player.js.html","title":"Source: components/itemscroller-player.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/itemscroller-player.js import rb, { Component } from '../core'; import './itemscroller'; import '../utils/keyboardfocus'; class ItemScrollerPlayer extends rb.components.itemscroller { /** * @static * @mixes rb.components.itemscroller.defaults * * @property {Number} autoplayDelay=2000 Delay between autoplay next and current slide. * @property {Boolean} autoplay=false Activates autoplay/slide show. * @property {Boolean} pauseOnHover=true Pauses slide show on mouseenter. * @property {Boolean} jumpToStart=true In case of a non-carousel jumps to the first slide instead of sliding to the first slide. */ static get defaults(){ return { autoplay: false, autoplayDelay: 2000, pauseOnHover: true, jumpToStart: true, }; } constructor(element, initialDefaults) { super(element, initialDefaults); this._setAutoplayUI = rb.rAF(function () { this.$element[this.options.autoplay ? 'addClass' : 'removeClass'](rb.statePrefix + 'autoplay'); }, {that: this}); } static get events(){ return { 'click:closest(.{name}{e}autoplay{-}btn)'() { this.setOption('autoplay', !this.options.autoplay); }, }; } setOption (name, value, isSticky) { super.setOption(name, value, isSticky); switch (name) { case 'autoplay': this[value ? 'startAutoplay' : 'stopAutoplay'](); break; case 'autoplayDelay': if (this.options.autoplay) { this.startAutoplay(); } break; } } stopAutoplay () { clearInterval(this._autoplayTimer); if (this._onenterAutoplay) { this.$element.off('mouseenter', this._onenterAutoplay); } if (this._onleaveAutoplay) { this.$element.off('mouseleave', this._onleaveAutoplay); } if (!this.options.autoplay) { this._setAutoplayUI(); } } startAutoplay() { var that = this; var options = this.options; var keyboardFocusSel = '.' + rb.utilPrefix + rb.nameSeparator + 'keyboardfocus'; if (!options.autoplay) { return; } this.stopAutoplay(); if (!this._onenterAutoplay) { this._onenterAutoplay = function () { if (options.pauseOnHover) { clearInterval(that._autoplayTimer); } }; } if (!this._onleaveAutoplay) { this._onleaveAutoplay = function () { if (options.pauseOnHover &amp;&amp; options.autoplay) { clearInterval(that._autoplayTimer); that._autoplayTimer = setInterval(that._autoplayHandler, options.autoplayDelay); } }; } if (!this._autoplayHandler) { this._autoplayHandler = function () { if(that.element.querySelector(keyboardFocusSel)){return;} if (that.isCarousel || that.selectedIndex + 1 &lt; that.baseLength) { that.selectNext(); } else { that.selectIndex(0, options.jumpToStart); } }; } this.$element.on('mouseenter', this._onenterAutoplay); this.$element.on('mouseleave', this._onleaveAutoplay); clearInterval(that._autoplayTimer); that._autoplayTimer = setInterval(this._autoplayHandler, options.autoplayDelay); this._setAutoplayUI(); } attached () { if (this.options.autoplay) { this.startAutoplay(); } } detached () { this.stopAutoplay(); } } Component.register('itemscroller', ItemScrollerPlayer, true); export default ItemScrollerPlayer; × Search results Close "},"components_itemscroller-queries.js.html":{"id":"components_itemscroller-queries.js.html","title":"Source: components/itemscroller-queries.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/itemscroller-queries.js import rb, { Component } from '../core'; import './itemscroller'; const regSizes = /(\\(\\s*(min|max)(-width)?\\s*:\\s*(\\d+\\.*\\d*)(px)?\\)\\s*)?(\\d+\\.*\\d*)(px|%)?/g; const createConditions = rb.memoize(function (value) { var match, size; var sizes = []; while((match = regSizes.exec(value))){ size = { condition: parseFloat(match[4]), type: match[2], str: match[0], value: parseFloat(match[6]), unit: match[7] || 'px', }; size.css = size.value + size.unit; sizes.push(size); } return sizes; }, true); class ItemScrollerQueries extends rb.components.itemscroller { /** * @static * @mixes rb.components.itemscroller.defaults * @prop {String} queries=&quot;&quot; Container queries configuration represented by a `sizes` like comma separated string. `&quot;(max-width: 480px) cellWidthSize1(%|px), (max-width: 1024px) cellWidthSize2(%|px), defaultCellWidthSize(%|px)&quot;` (i.e.: `&quot;(max-width: 480px) 100%, (max-width: 1024px) 50%, 600px&quot;`). * @prop {String} modifyUsePx=true Wether the `usePx` option should automatically changed. */ static get defaults() { return { queries: '', modifyUsePx: true, }; } beforeConstruct(){ super.beforeConstruct(); this.rAFs({batch: true}, '_setCurrentQuery'); } _parseQueries() { const queries = this.options.queries; if (!queries) { this._parsedQueries = null; return; } if (this._parsedQueries &amp;&amp; this._parsedQueries.queryString == queries) { return; } this._parsedQueries = createConditions(queries); this._parsedQueries.queryString = queries; } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); if (name == 'queries') { this.calculateLayout(); } } _getCellWidth(element) { return this._parsedQueries &amp;&amp; this._parsedQueries.currentQuery ? this._parsedQueries.currentQuery.computedValue : super._getCellWidth(element) ; } _getCurrentQuery() { if (!this._parsedQueries) { return; } let currentQuery, i; for (i = 0; i &lt; this._parsedQueries.length; i++) { currentQuery = this._parsedQueries[i]; if(!currentQuery.condition || !currentQuery.type || (currentQuery.type == 'max' &amp;&amp; this.viewportWidth &lt;= currentQuery.condition) || (currentQuery.type == 'min' &amp;&amp; this.viewportWidth &gt;= currentQuery.condition)){ break; } } currentQuery.computedValue = currentQuery.unit == '%' ? this.viewportWidth * currentQuery.value / 100 : currentQuery.value ; if(this.options.modifyUsePx){ this.options.usePx = currentQuery.unit == 'px'; } if (currentQuery != this._parsedQueries.currentQuery) { this._parsedQueries.currentQuery = currentQuery; this._setCurrentQuery(); } } _setCurrentQuery() { if (this._parsedQueries &amp;&amp; this._parsedQueries.currentQuery) { this.$cells.css({width: this._parsedQueries.currentQuery.css}); } } _switchOff() { const ret = super._switchOff(); if (this._parsedQueries &amp;&amp; this._parsedQueries.currentQuery) { this._parsedQueries.currentQuery = null; this.$cells.css({width: ''}); } return ret; } _calculateCellLayout() { this._parseQueries(); this._getCurrentQuery(); return super._calculateCellLayout(); } } Component.register('itemscroller', ItemScrollerQueries, true); export default ItemScrollerQueries; × Search results Close "},"components_listbox.js.html":{"id":"components_listbox.js.html","title":"Source: components/listbox.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/listbox.js import rb, { Component } from '../core'; /** * Class component to create a ListBox. * * @name rb.components.listbox * * @extends rb.Component * * @param element {Element} * @param [initialDefaults] {OptionsObject} * * @fires componentName#changed * @fires componentName#selectedchanged * * @example * &lt;div class=&quot;js-rb-live&quot; data-module=&quot;listbox&quot;&gt; * &lt;span class=&quot;listbox-item&quot;&gt;Item 1&lt;/span&gt; * &lt;span class=&quot;listbox-item&quot;&gt;Item 2&lt;/span&gt; * &lt;/div&gt; */ class Listbox extends Component { /** * @static * @mixes rb.Component.defaults * @property {Object} defaults */ static get defaults(){ return { focusElement: '', defaultSelected: 0, checkWithSpace: true, disconnected: false, }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.selectedIndex = -1; this.selectedItem = null; this.checkedIndex = -1; this.checkedItem = null; this.isList = Listbox.regList.test(element.nodeName); this.rAFs({throttle: true}, '_changeSelected', '_changeChecked', 'postRender', 'renderList', '_setFocusElement', '_setInitialMarkup'); this._onkeyboardInput = this._onkeyboardInput.bind(this); this.setFocusElement(); this._getElements(); } static get events(){ return { 'mousedown:closest(.{name}{e}item)' (e) { this.select(e.delegatedTarget); }, 'click .{name}{e}item:not([aria-disabled=&quot;true&quot;])' (e) { this.select(e.delegatedTarget); this.check(e.delegatedTarget); }, }; } setOption (name, value, isSticky) { super.setOption(name, value, isSticky); switch (name) { case 'focusElement': this.setFocusElement(); break; case 'disconnected': this[value ? '_disconnect' : '_connect'](); break; } } _setInitialMarkup(){ this.$items .attr({role: 'option'}) .parent() .attr({role: 'listbox'}) ; this.$items .filter( '.' + rb.statePrefix + 'disabled') .attr({'aria-disabled': 'true'}) ; if(this.checkedItem){ this.checkedItem.setAttribute('aria-checked', 'true'); } if(this._isStatic){ this.element.style.position = 'relative'; } } _getElements() { this.$items = this.$queryAll('.{name}{e}item'); this.checkedItem = this.$items.filter('.' + rb.statePrefix + 'checked').get(0) || null; this.checkedIndex = (this.checkedItem) ? this.$items.index(this.checkedItem) : -1; this._isStatic = this.$element.css('position') == 'static'; this._setInitialMarkup(); if(!this.options.disconnected){ this._connect(); } } _onkeyboardInput(e) { var prevent; if(this.options.disconnected){return;} if (e.keyCode == 40) { prevent = true; this.selectNext(); this.scrollIntoView(this.selectedItem); } else if (e.keyCode == 38) { prevent = true; this.selectPrev(); this.scrollIntoView(this.selectedItem); } else if (this.selectedItem &amp;&amp; (e.keyCode == 13 || (e.keyCode == 32 &amp;&amp; this.options.checkWithSpace))) { prevent = true; this.checkSelected(); } if (prevent) { e.preventDefault(); } } _disconnect () { this.select(-1); } _connect(){ var activeItem = this.focusElement.getAttribute('aria-activedescendant'); if(activeItem){ activeItem = this.query('#'+ activeItem); } this.select(this.checkedItem || activeItem || this.options.defaultSelected); this.scrollIntoView(this.checkedItem || activeItem, true); } setFocusElement(){ var value = this.options.focusElement; var old = this.focusElement; this.focusElement = typeof value == 'object' ? value : (value &amp;&amp; this.getElementsFromString(value)[0] || this.element) ; if(old &amp;&amp; old != this.focusElement){ old.removeEventListener('keydown', this._onkeyboardInput); } else { old = null; } this.focusElement.addEventListener('keydown', this._onkeyboardInput); this._setFocusElement(old); } _setFocusElement(old) { if (old) { old.removeAttribute('aria-activedescendant'); old.removeAttribute('tabindex'); } if(this.focusElement.tabIndex == -1 &amp;&amp; !this.focusElement.getAttribute('tabindex')){ this.focusElement.setAttribute('tabindex', '0'); } } _selectCheck (index, type) { var item; var typeData = Listbox.type[type]; if (index == -1 || index == null) { index = -1; item = null; } else if (typeof index == 'number') { item = this.$items.get(index); } else { item = index; index = this.$items.index(item); } if (index != this[typeData.index]) { this[typeData.index] = index; this[typeData.item] = item; this[typeData.change](); } } scrollIntoView(item, noAnimate){ if(!item || this.element.scrollHeight - 1 &lt;= this.element.offsetHeight){ return; } var moveScroll; var listboxTop = this.element.scrollTop; var listboxBottom = this.element.offsetHeight + listboxTop; var itemTop = item.offsetTop; var itemBottom = itemTop + item.offsetHeight; var isStartReached = itemTop &lt; listboxTop; var isEndReached = itemBottom &gt; listboxBottom; if(isStartReached || isEndReached){ moveScroll = itemTop; this.$element[noAnimate ? 'prop' : 'animate']( { scrollTop: moveScroll, }, { duration: 200, } ); } } select (index) { this._selectCheck(index, 'select'); } _changeSelected () { this.$items.removeClass(rb.statePrefix + 'selected'); if (this.selectedItem) { this.selectedItem.classList.add(rb.statePrefix + 'selected'); this.focusElement.setAttribute('aria-activedescendant', this.getId(this.selectedItem)); } this.trigger('selectedchanged'); } getSelectableIndex(dir){ var item; var ret = -1; var disabledClass = rb.statePrefix + 'disabled'; var index = this.selectedIndex + dir; while(index &gt; -1 &amp;&amp; this.$items.length &gt; index){ item = this.$items.get(index); if(!item.classList.contains(disabledClass) &amp;&amp; item.getAttribute('aria-disabled') != 'true'){ ret = index; break; } index += dir; } return ret; } selectNext () { var index = this.getSelectableIndex(1); if (index &gt; -1) { this.select(index); } } selectPrev () { var index = this.getSelectableIndex(-1); if (index &gt; -1) { this.select(index); } } _changeChecked() { this.$items .filter('.' + rb.statePrefix + 'checked') .rbToggleState('checked', false) .removeAttr('aria-checked') ; if (this.checkedItem) { this.checkedItem.classList.add(rb.statePrefix + 'checked'); this.checkedItem.setAttribute('aria-checked', 'true'); } this.trigger(); } check (index) { this._selectCheck(index, 'check'); } checkSelected() { if (this.selectedItem) { this.check(this.selectedItem); } } postRender() {} renderList() { } } Object.assign(Listbox, { regList: /^(?:ol|ul)$/i, type: { select: { index: 'selectedIndex', item: 'selectedItem', change: '_changeSelected', }, check: { index: 'checkedIndex', item: 'checkedItem', change: '_changeChecked', }, }, }); Component.register('listbox', Listbox); export default Listbox; × Search results Close "},"utils_router.js.html":{"id":"utils_router.js.html","title":"Source: utils/router.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/router.js /** * original by * http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url */ import rb from './global-rb'; import deserialize from './deserialize'; import getID from './get-id'; import addLog from './add-log'; const regPlus = /\\+/g; const regSlashBegin = /^\\//; const regSlashEnd = /\\/$/; const regFullHash = /#(.*)$/; const regWildCard = /\\*$/; const thenable = Promise.resolve(); const winHistory = window.history; let historyKeyCounter = 0; const returnTrue = () =&gt; true; function decodeParam(param){ return decodeURIComponent(param.replace(regPlus, ' ')); } rb.Router = addLog({ routes: {}, mode: 'history', current: '', options: { regHash: /#!(.*)$/, regIndex: /\\/index\\.htm[l]*$/, //you need to install a URL polyfill for IE supportRelativeRoutes: false, //reload reloads the page on Router.navigate, replace uses replaceState on Router.navigate and recalls the handler and recall simply re-calls the router handler samePathStrategy: 'replace', //reload, replace, recall, stop }, noNavigate: false, history: null, activeHistoryIndex: -1, storageKey: 'rb_router', init({ options, listen, routes } = {}) { this.config(options); this.initHistory(); if(routes){ this.map(routes); } if(listen){ this.listen(); } }, config: function (options) { Object.assign(this.options, options); return this; }, getFragment: function (locationObject = location) { let match; let fragment = ''; const {regHash, mode} = this.options; if (mode != 'hash') { fragment = decodeURI(locationObject.pathname + locationObject.search); } else { match = locationObject.href.match(regHash); fragment = match ? match[1] : ''; } return fragment; }, clearSlashes(path) { return path.toString().replace(regSlashBegin, '').replace(regSlashEnd, ''); }, createRouteMatcher(routeObj, parentRoute = ''){ let {path} = routeObj; const hasWildCard = regWildCard.test(path); path = this.clearSlashes(path); if(hasWildCard){ path = path.replace(regWildCard, ''); } if(parentRoute &amp;&amp; !parentRoute.endsWith('/') &amp;&amp; path){ parentRoute += '/'; } path = parentRoute + path; routeObj.path = path; routeObj.matcher = path ? path.split('/').map((name)=&gt;{ const isPlaceHolder = name[0] == ':'; return { type: isPlaceHolder ? 'placeholder' : 'strict', name: isPlaceHolder ? name.slice(1) : name, }; }) : [] ; if(hasWildCard){ routeObj.matcher.push({ type: 'wildcard', }); } else if(!routeObj.matcher.length){ routeObj.matcher.push({ type: 'strict', name: '', }); } }, extendRoutes(routes, parentPath){ let path; for(path in routes){ let routeObj = routes[path]; if(typeof routeObj == 'function'){ routeObj = { handler: routeObj, }; routes[path] = routeObj; } if(routeObj.subRoutes){ if(!routeObj.handler){ routeObj.handler = returnTrue; } if(!path.endsWith('*')){ path += '*'; } } routeObj.path = path; this.createRouteMatcher(routeObj, parentPath); if(routeObj.subRoutes){ this.extendRoutes(routeObj.subRoutes, routeObj.path); } } }, /** * * @param routes * * @example * Router.map({ * '/'(){ * * }, * '/:lang': { * handler({lang}){ * return (lang in availableLangs); * }, * subRoutes: { * '/'(){ * * }, * '/user' * } * }, * '*'(){ * * } * }); */ map(routes){ this.extendRoutes(routes); this.routes = routes; }, flush() { this.routes = {}; this.mode = null; return this; }, matches(route, path){ const length = path.length + 1; if(route.length &gt; length || ((length - 2) &gt; route.length &amp;&amp; route[route.length - 1].type != 'wildcard')){ return null; } let params = {}; for(let i = 0; i &lt; length; i++){ let routePart = route[i]; let pathPart = path[i]; if(!routePart){ if(pathPart){ params = null; } } else if(routePart.type == 'wildcard'){ if(pathPart){ params['*'] = decodeParam(path.slice(i).join('/')); } break; } else if(routePart.type == 'placeholder'){ if(pathPart){ params[routePart.name] = decodeParam(pathPart); } else { params = null; } } else if(routePart.name != pathPart) { params = null; } if(!params){ break; } } return params; }, findMatchingRoutes(routes, fragment, data, options){ for(let route in routes){ route = routes[route]; let handleResult; let params = this.matches(route.matcher, fragment); if (params) { handleResult = route.handler(params, options, data); if (handleResult == null) { return null; } else if(handleResult === true){ if(route.subRoutes){ handleResult = this.findMatchingRoutes(route.subRoutes, fragment, data, options); if(handleResult !== false){ return null; } } } } } return false; }, _saveState(fragment, event = {type: 'unknown/initial'}){ const data = {fragment: fragment == null ? this.getFragment() : fragment}; const fragmentParts = data.fragment.split('?'); fragment = this.clearSlashes((fragmentParts[0] || '').replace(this.options.regIndex, '')); this.before = this.current; this.beforeRoute = this.currentRoute; this.beforeOptions = this.currentOptions || ''; this.current = data.fragment; this.currentRoute = fragment; this.currentOptions = fragmentParts[1] || ''; data.fragment = fragment; data.changedRoute = this.beforeRoute != this.currentRoute; data.changedOptions = this.beforeOptions != this.currentOptions; data.history = this.history; data.activeHistoryIndex = this.activeHistoryIndex; data.event = event; return data; }, applyRoutes(fragment, event) { const data = this._saveState(fragment, event); const options = deserialize(this.currentOptions); fragment = data.fragment.split('/'); if(this.noNavigate){ this.logError('Router.applyRoutes called while routes are already applied.'); } this.noNavigate = true; this.findMatchingRoutes(this.routes, fragment, data, options); this.noNavigate = false; return this; }, unlisten() { if (this._listener) { window.removeEventListener('hashchange', this._listener); window.removeEventListener('popstate', this._listener); } if (this._listener || this.interval) { clearInterval(this.interval); } return this; }, applyRoutesIfNeeded(event){ if(this.getFragment() !== this.current){ this.onRouteChanged(event); } }, onRouteChanged(event){ const cur = this.getFragment(); const stop = cur === this.current &amp;&amp; this.options.samePathStrategy.includes('stop'); if(!stop){ this.updateActiveHistoryIndex(); this.applyRoutes(cur, event); } else if(event &amp;&amp; event.original &amp;&amp; event.original.type === 'popstate') { this.logWarn('route did not change, but pop event occurred'); this.updateActiveHistoryIndex(); } return this; }, initHistory: function(){ const state = winHistory.state; let currentHistoryKey = state &amp;&amp; state.historyKey; let restoredRouterState; this.history = null; try { restoredRouterState = JSON.parse(window.sessionStorage.getItem(this.storageKey)); } catch(e) {} // eslint-disable-line no-empty if(restoredRouterState){ this.sessionHistories = restoredRouterState.sessionHistories; if(currentHistoryKey &amp;&amp; this.sessionHistories.length){ this.history = this.sessionHistories.find((history) =&gt; { const historyIndex = history.indexOf(currentHistoryKey); if(historyIndex &gt; -1){ this.activeHistoryIndex = historyIndex; return true; } }); } } if(!currentHistoryKey){ currentHistoryKey = this.getHistoryKey(); winHistory.replaceState({ state, historyKey: currentHistoryKey, }, ''); } this.sessionHistories = this.sessionHistories || []; if(!this.history){ this.history = [currentHistoryKey]; this.activeHistoryIndex = 0; this.sessionHistories.push(this.history); } }, updateActiveHistoryIndex(){ const currentHistoryKey = winHistory.state &amp;&amp; winHistory.state.historyKey; if(!currentHistoryKey){ return this.logWarn('missing currentHistoryKey'); } this.activeHistoryIndex = this.history.indexOf(currentHistoryKey); if(this.activeHistoryIndex === -1){ this.logWarn('did not find key in history', currentHistoryKey, this.history, this.sessionHistories); this.history = [currentHistoryKey]; this.activeHistoryIndex = 0; this.sessionHistories.push(this.history); } this.saveRouterState(); }, getHistoryKey(){ historyKeyCounter += 1; return historyKeyCounter + '-' + getID(); }, addToHistory(historyKey, replace){ if(replace){ this.history[this.activeHistoryIndex] = historyKey; } else { // remove former history future stack const historyEndIndex = this.history.length - 1; if(historyEndIndex &gt; this.activeHistoryIndex){ this.history.length = this.activeHistoryIndex + 1; } this.history.push(historyKey); this.activeHistoryIndex = this.history.length - 1; } this.saveRouterState(); }, saveRouterState(){ window.sessionStorage.setItem(this.storageKey, JSON.stringify({sessionHistories: this.sessionHistories})); }, listen() { this.last = this.current; this.current = this.getFragment(); this.unlisten(); if (!this._listener) { //'interval' often means either browser bug or external (disapproved) pushState/replaceState call this._listener = (e = {type: 'interval'}) =&gt; { const run = e.type != 'interval' || this.getFragment() !== this.current; if(run){ this.onRouteChanged({ type: 'popstate', original: { type: e.type, state: e.state, }, }); } }; } this.interval = setInterval(this._listener, 999); if (this.mode == 'hash') { window.addEventListener('hashchange', this._listener); } else { window.addEventListener('popstate', this._listener); } return this; }, normalizePath(path = ''){ path = path.replace(regSlashEnd, ''); if(!path.startsWith('.')){ path = '/' + path.replace(regSlashBegin, ''); } return path; }, changedPath(path, locationObj = location){ let changedPath; if(this.options.supportRelativeRoutes){ path = this.normalizePath(path); changedPath = this.current !== this.getFragment(new URL(path, locationObj.href)); } else { if(path.startsWith('.')){ this.logError(`we do not support relative path: ${path}`); } changedPath = this.clearSlashes(path) !== this.clearSlashes(this.current); } return changedPath; }, navigate(path, state = null, silent, replace) { if(this.noNavigate){ thenable.then(() =&gt; { this.navigate(...arguments); }); this.logWarn('Router.navigate called while routes are already applied.'); return this; } path = this.normalizePath(path || ''); if(typeof state == 'boolean'){ replace = silent; silent = state; state = null; } if(!replace &amp;&amp; !this.changedPath(path)){ const { samePathStrategy } = this.options; if(samePathStrategy.includes('reload')){ window.location.reload(); return; } else if(samePathStrategy.includes('replace') &amp;&amp; replace !== false){ replace = true; } } const event = { type: 'navigate', replace, }; if(!state || !state.historyKey || !state.state){ state = {state, historyKey: this.getHistoryKey()}; } this.addToHistory(state.historyKey, replace); if (this.mode === 'history') { winHistory[replace === true ? 'replaceState' : 'pushState'](state, '', path); } else { const value = window.location.href.replace(regFullHash, '') + '#' + path; if(replace === true){ location.replace(value); } else { window.location.href = value; } } if(silent){ this._saveState(event); } else { this.onRouteChanged(event); } setTimeout(() =&gt; { const customEvent = new CustomEvent('rb_pushstate', { bubbles: true, cancelable: false, detail: { event, state, }, }); window.dispatchEvent(customEvent); }, 0); return this; }, push(path, state, silent){ return this.navigate(path, state, silent, false); }, replace(path, state, silent) { return this.navigate(path, state, silent, true); }, }, 2); export default rb.Router; × Search results Close "},"utils_rafqueue.js.html":{"id":"utils_rafqueue.js.html","title":"Source: utils/rafqueue.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/rafqueue.js import rb from './global-rb'; import deferred from './deferred'; let isInProgress, inProgressStack; const fns1 = []; const fns2 = []; const immediatePromise = Promise.resolve(); let curFns = fns1; const setProgressFalse = () =&gt; { isInProgress = false; }; const run = function () { if(curFns.length){ inProgressStack = curFns; curFns = fns1.length ? fns2 : fns1; isInProgress = true; while (inProgressStack.length) { inProgressStack.shift()(); } immediatePromise.then(setProgressFalse); } }; /** * Invokes a function inside a rAF call * @memberof rb * @alias rb#rAFQueue * @param fn {Function} the function that should be invoked * @param [inProgress=true] {boolean} Whether the fn should be added to an ongoing rAF or should be appended to the next rAF. */ export default function rAFQueue(fn, inProgress = true) { if (inProgress &amp;&amp; isInProgress) { immediatePromise.then(fn); } else { curFns.push(fn); if (curFns.length == 1) { (!document.hidden ? requestAnimationFrame : setTimeout)(run); } } } let rafPromise; /** * If no function is given returns a promise that is resolved in the mutation phase * @param [fn] {Function} Function that will be executed in the mutation phase * @return {Promise} */ export const mutationPhase = (fn) =&gt; { if(fn){ rAFQueue(fn, true); } else if(!rafPromise || rafPromise.isResolved){ rafPromise = deferred(); rAFQueue(rafPromise.resolve, true); } return rafPromise; }; let measurePromise; /** * Returns a promise that is resolved in the measure/read phase. * @return {Promise&lt;void&gt; | Deferred} */ export const measurePhase = () =&gt; { let promise; if (isInProgress) { if (!measurePromise || measurePromise.isResolved()) { measurePromise = deferred(); setTimeout(measurePromise.resolve); } promise = measurePromise; } else { promise = immediatePromise; } return promise; }; rb.rAFQueue = rAFQueue; × Search results Close "},"utils_viewport.js.html":{"id":"utils_viewport.js.html","title":"Source: utils/viewport.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/viewport.js /** * * @param element * @param [margin=0] {Number} * @param [intersect=0] {Number} * @param [viewportWidth] {Number} * @param [viewportHeight] {Number} */ export default function checkInViewport(element, margin = 0, intersect = 0, viewportWidth, viewportHeight){ let tmpValue, boxArea, intersectArea; let value = false; let box = element.getBoundingClientRect(); if(box.top || box.left || box.right || box.bottom || element.getClientRects().length){ let top = 0; let left = 0; let right = viewportWidth || window.innerWidth; let bottom = viewportHeight || window.innerHeight; if(margin){ top -= margin; left -= margin; right += margin; bottom += margin; } tmpValue = (box.top &lt;= bottom &amp;&amp; box.bottom &gt;= top &amp;&amp; box.left &lt;= right &amp;&amp; box.right &gt;= left); if(tmpValue){ value = tmpValue; if(intersect == 1){ value = (box.top &gt;= top &amp;&amp; box.bottom &lt;= bottom &amp;&amp; box.left &gt;= left &amp;&amp; box.right &lt;= right); } else if(intersect) { boxArea = Math.min(box.width, right) * Math.min(box.height, bottom); intersectArea = (Math.min(box.bottom, bottom) - Math.max(box.top, top)) * (Math.min(box.right, right) - Math.max(box.left, left)); value = intersectArea / boxArea &gt;= intersect; } } } return value; } × Search results Close "},"utils_serialize.js.html":{"id":"utils_serialize.js.html","title":"Source: utils/serialize.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/serialize.js const rCRLF = /\\r?\\n/g; const rcheckableType = ( /^(?:checkbox|radio)$/i ); const rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i; const rsubmittable = /^(?:input|select|textarea|keygen)/i; /** * * @param elements {Element} * @return {Array} */ export default function serialize(elements){ const array = []; if(!Array.isArray(elements)){ elements = elements.nodeType ? [elements] : Array.from(elements); } elements.forEach(function(element){ const elements = element.elements &amp;&amp; Array.from(element.elements) || [element]; elements.forEach(function(element){ let type, options, i, len; if( element.name &amp;&amp; !element.matches(':disabled') &amp;&amp; rsubmittable.test( element.nodeName || '' ) &amp;&amp; (type = element.type) &amp;&amp; !rsubmitterTypes.test(type) &amp;&amp; (element.checked || !rcheckableType.test( type )) ) { if( (options = element.selectedOptions) ){ for(i = 0, len = options.length; i &lt; len; i++){ array.push({name: element.name, value: (options[i].value || '').replace( rCRLF, '\\r\\n' )}); } } else { array.push({name: element.name, value: (element.value || '').replace( rCRLF, '\\r\\n' )}); } } }); }); return array; } × Search results Close "},"utils_deferred.js.html":{"id":"utils_deferred.js.html","title":"Source: utils/deferred.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/deferred.js import rb from './global-rb'; /** * Creates a promise with a resolve and a reject method. * @returns {Deferred} */ export default function deferred(){ const tmp = { isResolved: false, isRejected: false, isDone: false, }; const promise = new Promise(function(resolve, reject){ tmp.resolve = function(data){ promise.isResolved = true; promise.isDone = true; promise.value = data; return resolve(data); }; tmp.reject = function(data){ promise.isRejected = true; promise.isDone = true; promise.value = data; promise.catch(value =&gt; value); return reject(data); }; }); Object.assign(promise, tmp); return promise; } rb.deferred = deferred; × Search results Close "},"utils_expando.js.html":{"id":"utils_expando.js.html","title":"Source: utils/expando.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/expando.js import rb from './global-rb'; /** * Sets/Gets expando property of an object * * @param obj {Object} * @param expando {String|Symbol} * @param [name] {String|Object} * @param [value] {*} * @return {*} * * @example * //sets expando properties by merging name object into expando object * expando(divElement, expando, {isValid: true, tested: true}); * * //sets expando property by setting name of expando object * expando(divElement, expando, 'isValid', true); * * //gets hole expando object * expando(divElement, expando); * * //gets isValid property of expando * expando(divElement, expando, isValid); */ export default function expando(obj, expando, name, value){ const nameType = typeof name; const isSring = nameType == 'string'; if(!obj[expando]){ obj[expando] = {}; } if(isSring &amp;&amp; arguments.length == 4){ if(value !== undefined){ obj[expando][name] = value; } else if( (name in obj[expando]) ){ delete obj[expando]; } } else if(nameType == 'object'){ Object.assign(obj[expando], name); } return isSring ? obj[expando][name] : obj[expando]; } rb.expando = expando; × Search results Close "},"utils_ajaxform.js.html":{"id":"utils_ajaxform.js.html","title":"Source: utils/ajaxform.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/ajaxform.js /** * @module ajaxform */ import serialize from './serialize'; import param from '../rb_$/$_param'; import fetch from './fetch'; /** * Returns option to fetch a form using rb.fetch. * @param element {HTMLFormElement} * @return {{url: (string), type: string, data: *}} */ export function getFormFetchOptions(element){ const fetchOpts = { url: element.action, type: element.method.toUpperCase(), }; if(fetchOpts.type == 'POST'){ Object.assign(fetchOpts, { data: new FormData(element), contentType: false, processData: false, }); } else { fetchOpts.url += '?' + param(serialize(element)); } return fetchOpts; } /** * Fetches a form using rb.fetch * * @param element {HTMLFormElement} * @return {Promise} */ export default function fetchForm(element){ return fetch(getFormFetchOptions(element)); } × Search results Close "},"utils_validity.js.html":{"id":"utils_validity.js.html","title":"Source: utils/validity.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/validity.js /** * @module validity */ const rb = window.rb; const $ = rb.$; const rules = {}; const checkedTypes = {radio: !0, checkbox: !0}; const expando = rb.Symbol('validity'); /** * This callback is displayed as a global member. * @callback customValidationRuleCallback * @param {customValidationElementInfo} validityInfo * * @returns {Boolean|Promise|deferred} */ /** * @typedef {Object} customValidationElementInfo * @property {Element} element Reference to the element. * @property {Object} $element jQuerified version of element. * @property {Object} data Data object of the element. Retrieved by $element.data(). * @property {Object|null} errorRule Current validation rule that the element lacks of. * @property {null|String[]|String} value The value that was used on last validation. * @property {undefined|String} valueStr The value as string that was used on last validation. * @property {null|String[]|String} prev The value that the was used on the validation before. * @property {false|Promise|Deferred} isPending The value that the was used on the validation before. */ /** * Adds a new custom validation rule to the set. * @param rule {Object} * @param rule.name {String} Name of the custom validation rule. * @param rule.rule {customValidationRuleCallback} The function that runs the validation. Returns false if the rule is not satisfied otherwise false. In case of async validation it has to return a promise/deferred. * @param [rule.message='This field is invalid.'] {String} Default validation message. * @param [rule.isAsync=false] {Boolean} In case the rule works async. * @param [rule.isDependent=false] {Boolean} In case the rule not only depends on the value of one field. * * @example * * //&lt;input data-val-foo=&quot;This field has to contain 'foo'&quot; /&gt; * //or * //&lt;input data-foo=&quot;&quot; /&gt; * addRule({ * name: 'foo', * rule(validityInfo){ * return validityInfo.value.includes('foo'); * } * }); */ export function addRule(rule){ rule = Object.assign({ isAsync: false, isDependent: false, message: 'This field is invalid.', }, rule); if(!rule.messageAttr){ rule.messageAttr = $.camelCase(`val-${rule.name}`); } rule.normalizedName = $.camelCase(rule.name); rules[rule.normalizedName] = rule; rules[rule.messageAttr] = rule; } /** * Returns the validityData of an element. * * @param element * @return {customValidationElementInfo} */ export function getCustomValidityInfo(element){ let validityInfo = element[expando]; if(!validityInfo){ const $element = $(element); validityInfo = { element, $element, prev: null, value: null, data: $element.data(), isPending: false, errorRule: null, }; element[expando] = validityInfo; } return validityInfo; } function applyErrorMessage(validityInfo) { const {errorRule} = validityInfo; let message = errorRule ? validityInfo.data[errorRule.messageAttr] || errorRule.message : '' ; validityInfo.element.setCustomValidity(message); } function applyValidity(isValid, errorRule, validityInfo) { if(!isValid){ validityInfo.errorRule = errorRule; applyErrorMessage(validityInfo); } else if(validityInfo.errorRule == errorRule){ validityInfo.errorRule = null; applyErrorMessage(validityInfo); } } function satifiesRule(errorRule, validityInfo){ if(!validityInfo.isChanged &amp;&amp; !errorRule.isDependent){ return validityInfo.errorRule == errorRule ? false : true; } const isValid = errorRule.rule(validityInfo); applyValidity(isValid, errorRule, validityInfo); return isValid; } function checkAsyncRule(asyncRule, validityInfo){ if(!validityInfo.isChanged &amp;&amp; !asyncRule.isDependent){ return; } validityInfo.isPending = asyncRule.rule(validityInfo); validityInfo.isPending .then((isValid)=&gt;{ validityInfo.isPending = null; applyValidity(isValid, asyncRule, validityInfo); }) .catch(()=&gt;{ validityInfo.isPending = null; applyValidity(true, asyncRule, validityInfo); }) ; } function getValue(element){ let value = ''; let valueStr = ''; if(checkedTypes[element.type]){ value = element.checked ? element.value : ''; valueStr = value; } else if((element.multiple || element.size &gt; 1) &amp;&amp; element.matches('select')){ value = $(':checked:not([disabled])', element).get().map((option)=&gt; option.value); valueStr = value.join(', '); } else { value = element.value; valueStr = value; } return [value, valueStr]; } /** * Runs custom validation rules on an element. Returns a promise if the validation is pending otherwise false. * * @param element {Element} * @return {false|Promise|Deferred} * * @example * * checkElement(element); * console.log(element.validity.valid); */ export function checkElement(element){ if(!element.willValidate){return;} const validityInfo = getCustomValidityInfo(element); const {errorRule} = validityInfo; const {validity} = element; if(validity.valid || (validity.customError &amp;&amp; errorRule)){ let asyncRule; const [value, valueStr] = getValue(element); validityInfo.value = value; validityInfo.valueStr = valueStr; validityInfo.isChanged = valueStr !== validityInfo.prev; if(!errorRule || errorRule.isAsync || satifiesRule(errorRule, validityInfo)){ for(let ruleName in rules){ const currentRule = rules[ruleName]; if(ruleName in validityInfo.data &amp;&amp; (currentRule.messageAttr != ruleName || !(currentRule.normalizedName in validityInfo.data))){ if(currentRule.isAsync){ asyncRule = currentRule; continue; } if(currentRule != errorRule &amp;&amp; !satifiesRule(currentRule, validityInfo)){ break; } } } if(asyncRule &amp;&amp; (!validityInfo.errorRule || validityInfo.errorRule == asyncRule)){ checkAsyncRule(asyncRule, validityInfo); } validityInfo.prev = valueStr; } } return validityInfo.isPending; } /** * Runs checkElement on multiple elements. * * @param element {Element|Element[]|HTMLFormElement|FieldsetFormElement} * @return {Promise|false} */ export function check(element){ let pendings = false; (Array.isArray(element) ? element : element.elements &amp;&amp; Array.from(element.elements) || [element]) .forEach((element)=&gt;{ const pending = checkElement(element); if(pending){ if(!pendings){ pendings = []; } pendings.push(pending); } }) ; return pendings ? Promise.all(pendings) : pendings; } export function willValidate(element){ return element.willValidate &amp;&amp; element.type != 'submit' &amp;&amp; !element.matches('[aria-hidden=&quot;true&quot;] *, [hidden] *'); } /** * Returns all elements that are considered to be validated inside of contextElement. * @param contextElement * * @return {Element[]} */ export function getVisibleElements(contextElement){ return $('input, select, textarea', contextElement).get().filter(willValidate); } /** * Returns all elements that are invalid inside of contextElement. * @param contextElement * * @return {Element[]} */ export function getInvalidVisibleElements(element){ return $('input:invalid, select:invalid, textarea:invalid', element).get().filter(willValidate); } const validity = {checkElement, check, addRule, getInvalidVisibleElements, getCustomValidityInfo, willValidate, getVisibleElements}; rb.validity = validity; export default validity; × Search results Close "},"components_panelbutton.js.html":{"id":"components_panelbutton.js.html","title":"Source: components/panelbutton.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/panelbutton.js import rb, { Component } from '../core'; import './button'; /** * Class component to create a panelbutton. A panelbutton controls the state of a panel the same way an ordinary button does. Additionally the panelbutton associates with the panel and reflects it's state via an aria-expanded attribute. * * @name rb.components.panelbutton * @extends rb.components.button * * @param element * @param initialDefaults * * @example * &lt;button data-target=&quot;next(.rb-panel)&quot; data-module=&quot;panelbutton&quot; type=&quot;button&quot; class=&quot;js-rb-click&quot;&gt;button&lt;/button&gt; * &lt;div class=&quot;rb-panel&quot; data-module=&quot;panel&quot;&gt; * {{panelContent}} * &lt;/div&gt; */ class PanelButton extends rb.components.button { /** * @static * @property {Object} defaults * @mixes rb.components.button.defaults * * @property {String} openTitle=&quot;&quot; * @property {String} closedTitle=&quot;&quot; */ static get defaults(){ return { openTitle: '', closedTitle: '', }; } constructor(element, initialOpts) { super(element, initialOpts); this.rAFs({that: this, throttle: true}, 'updatePanelButtonState'); } updatePanelButtonState() { var options = this.options; var isOpen = this.panelComponent.isOpen; var disable = !!(isOpen &amp;&amp; this.panelComponent.groupComponent &amp;&amp; this.panelComponent.groupComponent.options.toggle === false); this.element.setAttribute('aria-expanded', '' + isOpen); this.element.disabled = disable; if(options.closedTitle &amp;&amp; options.openTitle){ this.element.title = options[isOpen ? 'openTitle' : 'closedTitle']; } if (this._isFakeBtn) { this.element.setAttribute('aria-disabled', disable); this.element.setAttribute('tabindex', disable ? -1 : 0); } } _switchOff() { super._switchOff(); this.element.removeAttribute('aria-expanded'); if (this._isFakeBtn) { this.element.removeAttribute('role'); this.element.removeAttribute('tabindex'); this.element.removeAttribute('aria-disabled'); } } _switchOn() { super._switchOn(); if (!this.panelComponent) { this.associatePanel(); } else { this.updatePanelButtonState(); } } _setTarget(value) { var ret = super._setTarget(value); if(this.target){ this.associatePanel(); } return ret; } associatePanel() { var panelComponent; var panel = this.getTarget(); if (!panel || !(panelComponent = this.component(panel)) || !('isOpen' in panelComponent) || this.panelComponent == panelComponent) { return; } if (this.panelComponent) { if (this.panelComponent.buttonComponent == this) { this.panelComponent.buttonComponent = null; } this.panelComponent.$element.off(this.panelComponent._evtName, this.updatePanelButtonState); } this.panelComponent = panelComponent; panelComponent.buttonComponent = this; panelComponent.$element.on(this.panelComponent._evtName, this.updatePanelButtonState); this.updatePanelButtonState(); } } Component.register('panelbutton', PanelButton); export default PanelButton; × Search results Close "},"utils_global-rb.js.html":{"id":"utils_global-rb.js.html","title":"Source: utils/global-rb.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/global-rb.js import glob from './glob'; import version from './rb-version'; if(!glob.rb){ glob.rb = { version, }; } const rb = glob.rb; /** * rawblock main object holds classes and util properties and methods to work with rawblock * @namespace rb */ export default rb; × Search results Close "},"components__childfx.js.html":{"id":"components__childfx.js.html","title":"Source: components/_childfx.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/_childfx.js import rb, { Component } from '../core'; import getCss from '../utils/get-css'; const $ = Component.$; const pseudoExpando = rb.Symbol('childfxPseudo'); /** * Abstract class that can be extended to animate child elements according to a progress property. * * @extends rb.Component * @alias rb.components._childfx * * @param element * @param initialDefaults * * @example * &lt;style type=&quot;sass&quot;&gt; * .rb-main { * .child-fx { * top: 0; * transition: all 50ms; * * (at)include exportToJS(( * top: 50, * //complicated values like transform/backgroundColor... * transform: ( * start: &quot;rotate(0deg)&quot;, * value: &quot;rotate(10deg)&quot;, * ) * )); * } * } * &lt;/style&gt; * * &lt;div class=&quot;rb-main js-rb-live&quot; data-module=&quot;childfxExtension&quot;&gt; * &lt;img class=&quot;logo&quot; src=&quot;...&quot; /&gt; * &lt;/div&gt; * * &lt;script&gt; * rb.components._childfx.extend('childfxExtension', { * init: function(element, initialDefaults){ * this._super(element, initialDefaults); * this.pos(); * }, * pos: function(){ * this.progress = 0.4; //set number between 0 - 1. * this.updateChilds(); * } * }); * &lt;/script&gt; */ class _ChildFX extends Component { /** * @prop {Boolean} defaults.switchedOff=false Switches the component off. * @prop {String} defaults.childSel='find(.child{e}fx)' Child elements that should be animated. String is processed by rb.elementFromStr. */ static get defaults(){ return { switchedOff: false, childSel: 'find(.{name}{e}fx)', }; } static toNumber(i) { return parseFloat(i) || 0; } constructor(element, initialDefaults){ super(element, initialDefaults); this.progress = -2; this.updateChilds = rb.rAF(this.updateChilds); } getCssValue(elem, prop, options, styles) { const value = {}; const endValue = options.end[prop]; if (typeof endValue == 'object') { Object.assign(value, endValue); options.end[prop] = endValue.value || endValue.end || 0; if ('start' in endValue) { value.value = endValue.start; } } value.value = value.value != null ? value.value : getCss(elem, prop, 1, styles); if (typeof value.value == 'string' &amp;&amp; typeof options.end[prop] == 'string') { value.template = value.value; value.value = (value.value.match(_ChildFX.regNumber) || [0]).map(_ChildFX.toNumber); options.end[prop] = (options.end[prop].match(_ChildFX.regNumber) || [0]).map(_ChildFX.toNumber); } return value; } setupChilds() { this.childs = this.getElementsByString(this.options.childSel, this.element); this.childAnimations = this.childs.map((elem)=&gt; { let prop; const styles = rb.getStyles(elem); const options = { start: {}, end: Object.assign({}, rb.parsePseudo(elem, pseudoExpando), rb.parseDataAttrs(elem)), from: 0, to: 1, }; for (prop in options.end) { if (prop == 'easing') { options.easing = rb.addEasing(options.end[prop]); } else if (prop == 'from' || prop == 'to') { options[prop] = options.end[prop]; } else { options.start[prop] = this.getCssValue(elem, prop, options, styles); } } return options; }); } checkChildReflow() { let ret = false; if (this.childs &amp;&amp; this.childs.length &amp;&amp; !this.options.switchedOff) { this.childs.forEach(function (elem) { if (!ret &amp;&amp; rb.hasPseudoChanged(elem, pseudoExpando)) { ret = true; } }); } if (ret) { this.updateChilds._rbUnrafedFn.call(this, true); this.progress = -2; } return ret; } updateChilds(empty) { let eased, i, len, animOptions, elem, eStyle, prop, value, option, isString, i2, retFn, progress; empty = empty === true; if (!this.childs || !this.childAnimations) { if (empty) { return; } this.setupChilds(); } for (i = 0, len = this.childs.length; i &lt; len; i++) { elem = this.childs[i]; animOptions = this.childAnimations[i]; progress = this.progress; eStyle = elem.style; if (!empty) { if (animOptions.from &gt; progress) { progress = 0; } else if (animOptions.to &lt; progress) { progress = 1; } else if (animOptions.to &lt; 1 || animOptions.from &gt; 0) { progress -= animOptions.from; progress *= 1 / (1 - (1 - animOptions.to) - animOptions.from); } eased = animOptions.easing ? animOptions.easing(progress) : progress ; } for (prop in animOptions.start) { option = animOptions.start[prop]; value = option.value; if (!empty) { if ((isString = option.template)) { i2 = 0; if (!retFn) { /*jshint loopfunc: true */ retFn = function () { // eslint-disable-line no-loop-func let value = (animOptions.end[prop][i2] - option.value[i2]) * eased + option.value[i2]; i2++; if (prop == 'backgroundColor') { value = Math.round(value); } return value; }; } value = option.template.replace(_ChildFX.regNumber, retFn); } else { value = (animOptions.end[prop] - option.value) * eased + option.value; } } if (prop in eStyle) { if (!isString &amp;&amp; !$.cssNumber[prop]) { value += 'px'; } eStyle[prop] = empty ? '' : value; } else { elem[prop] = value; } } } if (empty) { this.childs = null; this.childAnimations = null; } } } _ChildFX.regNumber = /(-*\\d+[.\\d]*)/g; _ChildFX.regWhite = /\\s/g; Component.register('_childfx', _ChildFX); × Search results Close "},"components__composer-component.js.html":{"id":"components__composer-component.js.html","title":"Source: components/_composer-component.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/_composer-component.js const rb = window.rb; const childOptionExpando = rb.Symbol('childOptionExpando'); /** * Base Class component to create a _ComposerComponent. * * @alias rb.components._composer_component * * @extends rb.Component * * @param element {Element} * @param [initialDefaults] {OptionsObject} * */ class ComposerComponent extends rb.Component { _createChildOptions(componentName, opts, leaveOriginalName){ const initialDefaults = {}; if(!leaveOriginalName){ initialDefaults.jsName = this.interpolateName(`{name}{e}${componentName}`, true); initialDefaults.name = this.interpolateName(`{name}{e}${componentName}`); } if(!this[childOptionExpando]){ this[childOptionExpando] = {}; } opts.forEach(option =&gt; { let optionName, childName; const compute = option.computeValue; if(typeof option == 'string'){ optionName = option; childName = option; } else { optionName = option.name; childName = option.childName || optionName; } initialDefaults[childName] = compute ? compute(this.options[optionName], optionName, this) : this.options[optionName] ; if(!this[childOptionExpando][optionName]){ this[childOptionExpando][optionName] = {}; } if(!this[childOptionExpando][optionName][componentName]){ this[childOptionExpando][optionName][componentName] = { components: [], compute, childName, }; } }); return initialDefaults; } _createChildComponent(componentName, componentElement, initialDefaults, opts){ const component = rb.getComponent(componentElement, componentName, initialDefaults); opts.forEach(option =&gt; { const optionName = typeof option == 'string' ? option : option.name ; this[childOptionExpando][optionName][componentName].components.push(component); }); return component; } createChildComponent(componentName, componentElement, opts, leaveOriginalName){ const initialDefaults = this._createChildOptions(componentName, opts, leaveOriginalName); return this._createChildComponent(componentName, componentElement, initialDefaults, opts); } createChildComponents(componentName, componentElements, opts, leaveOriginalName){ const initialDefaults = this._createChildOptions(componentName, opts, leaveOriginalName); return componentElements .map((componentElement) =&gt; this._createChildComponent(componentName, componentElement, initialDefaults, opts)); } setOption(name, value, isSticky){ if(this[childOptionExpando] &amp;&amp; this[childOptionExpando][name]){ for(let optionName in this[childOptionExpando][name]){ let option = this[childOptionExpando][name][optionName]; let computedValue = option.compute ? option.compute(value, name, this) : value ; option.components.forEach((component)=&gt;{ component.setOption(option.childName, computedValue, isSticky); }); } } super.setOption(name, value, isSticky); } } rb.live.register('_composer_component', ComposerComponent); export default ComposerComponent; × Search results Close "},"components__focus-component.js.html":{"id":"components__focus-component.js.html","title":"Source: components/_focus-component.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/_focus-component.js let focusClass, focusSel; const rb = window.rb; const generateFocusClasses = function(){ focusClass = ['js', 'rb', 'autofocus'].join(rb.nameSeparator); focusSel = '.' + focusClass; }; /** * Base Class component to create a _FocusComponent. * * @alias rb.components._focus_component * * @extends rb.Component * * @param element {Element} * @param [initialDefaults] {OptionsObject} * */ class _FocusComponent extends rb.Component { /** * @static * @mixes rb.Component.defaults * * @prop {Number} defaults.focusDelay=0 Default focus delay for `setComponentFocus`. Can be used to avoid interference between focusing and an animation. * @prop {String} defaults.autofocusSel='' Overrides the js-rb-autofocus selector for the component. */ static get defaults() { return { focusDelay: 0, autofocusSel: '', }; } beforeConstruct(){ super.beforeConstruct(); if(!focusClass){ generateFocusClasses(); } } /** * * @param [element] {Element|Boolean|String} The element that should be focused. In case a string is passed the string is converted to an element using `rb.elementFromStr` * @returns {undefined|Element} */ getFocusElement(element){ let focusElement; if (element &amp;&amp; element !== true) { if (element.nodeType == 1) { focusElement = element; } else if (typeof element == 'string') { focusElement = rb.elementFromStr(element, this.element)[0]; } } else { focusElement = this.options.autofocusSel &amp;&amp; this.query(this.options.autofocusSel) || this.query(focusSel); } if (!focusElement &amp;&amp; (element === true || this.element.classList.contains(focusClass))) { focusElement = this.element; } return focusElement; } /** * Sets the focus and remembers the activeElement before. If setComponentFocus is invoked with no argument. The element with the class `js-rb-autofocus` inside of the component element is focused. * @param [element] {Element|Boolean|String} The element that should be focused. In case a string is passed the string is converted to an element using `rb.elementFromStr` * @param [delay] {Number} The delay that should be used to focus an element. */ setComponentFocus(element, delay) { let focusElement; if (typeof element == 'number') { delay = element; element = null; } focusElement = (!element || element.nodeType != 1) ? this.getFocusElement(element) : element ; this.storeActiveElement(); if (focusElement) { this.setFocus(focusElement, delay || this.options.focusDelay); } } /** * stores the activeElement for later restore. * * @returns {Element} * * @see rb.Component.prototype.restoreFocus */ storeActiveElement(){ const activeElement = document.activeElement; this._activeElement = (activeElement &amp;&amp; activeElement.nodeName) ? activeElement : null; return this._activeElement; } /** * Restores the focus to the element, that had focus before `setComponentFocus` was invoked. * @param [checkInside] {Boolean} If checkInside is true, the focus is only restored, if the current activeElement is inside the component itself. * @param [delay] {Number} */ restoreFocus(checkInside, delay) { const activeElem = this._activeElement; if (!activeElem) { return; } if (typeof checkInside == 'number') { delay = checkInside; checkInside = null; } this._activeElement = null; if (!checkInside || this.element == document.activeElement || this.element.contains(document.activeElement)) { this.setFocus(activeElem, delay || this.options.focusDelay); } } } rb.live.register('_focus_component', _FocusComponent); export default _FocusComponent; × Search results Close "},"components_panelgroup.js.html":{"id":"components_panelgroup.js.html","title":"Source: components/panelgroup.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/panelgroup.js import rb, { Component } from '../core'; import './panelbutton'; import './panel'; import './_composer-component'; import '../utils/contains'; const $ = Component.$; const live = rb.live; const componentExpando = live.componentExpando; const components = rb.components; const cleanupCSS = function () { const css = {display: ''}; if (!this.style.height.startsWith('0')) { css.height = ''; css.overflow = ''; } $(this).css(css); }; /** * Class component to create a tab-like or an accordion-like component. Associates panelbuttons and panels and manages the `isOpen` state of the panels. * * @alias rb.components.panelgroup * @extends rb.components._composer_component * * @param element {Element} * * @fires componentName#changed Fires after the `selectedIndexes`/`selectedItems` changes. Note the panel#change and panel#changed events are also fired on the panel elements. * * @prop {Number[]} selectedIndexes The index(es) of the open panel(s) * @prop {Element[]} selectedItems The dom element(s) of the open panel(s) * * @example * &lt;div class=&quot;rb-tabs js-rb-click&quot; data-module=&quot;panelgroup&quot; data-panelgroup-toggle=&quot;false&quot;&gt; * &lt;button type=&quot;button&quot; class=&quot;panelgroup-ctrl-btn&quot; data-type=&quot;prev&quot;&gt;&amp;lt;&lt;/button&gt; * &lt;button type=&quot;button&quot; class=&quot;panelgroup-ctrl-btn&quot; data-type=&quot;next&quot;&gt;&amp;gt;&lt;/button&gt; * * &lt;button type=&quot;button&quot; class=&quot;panelgroup-btn&quot;&gt;1&lt;/button&gt; * &lt;div class=&quot;panelgroup-panel&quot;&gt; * {{panelContent}} * &lt;/div&gt; * * &lt;button type=&quot;button&quot; class=&quot;panelgroup-btn&quot;&gt;2&lt;/button&gt; * &lt;div class=&quot;panelgroup-panel&quot;&gt; * {{panelContent}} * &lt;/div&gt; * &lt;/div&gt; * @example * rb.$('.rb-tabs').on('panelgroupchanged', function(){ * console.log(rb.$(this).rbComponent().selectedIndexes); * }); * * rb.$('.rb-tabs').rbComponent().next(); */ class PanelGroup extends rb.components._composer_component { /** * @static * @mixes rb.components._composer_component.defaults * @property {Object} defaults * @property {Boolean} toggle=true Whether a panel button toggles the state of a panel. * @property {Boolean} multiple=false Whether multiple panels are allowed to be open at the same time. If `multiple` is `true` `toggle` is also automatically set to `true`. * @property {Number} selectedIndex=-1 The initially opened index. If no panel with the class `is-open` was found. If no panel should be opened by default use -1. (For performance the `is-open` class should be favored instead of changing this value). * @property {Boolean} closeOnFocusout=false Closes all panels of a group on focusout. * @property {String} animation='' Possible animations: `adaptHeight` or `slide`. These should be combined with CSS transitions or animations. * @property {String} easing='' Easing function for the animation. * @property {Number} duration=400 Duration of the animation. * @property {Boolean|Number} adjustScroll=false Sets the adjustScroll option on the panel components. * @property {Boolean|Number} scrollIntoView=false Sets the scrollIntoView option on the panel components. * @property {Boolean|String} setDisplay=false Sets the setDisplay option on the panel components. * @property {Boolean} setFocus=true Whether component should try to focus a `js-rb-autofocus` element inside of an opening panel. * @property {Boolean} preventDefault=false Whether default click action on &quot;{name}-btn&quot; should be prevented. * @property {String} itemWrapper='' Set itemWrapper option of the panel instance. * @property {Boolean} switchedOff=false Turns off panelgroup. * @property {Boolean} resetSwitchedOff=true Resets panels to initial state on reset switch. * @property {Boolean} closeOnEsc=false Panel closes on ESC keydown. * @property {String} panelSel='find(.{name}{e}panel)' Reference to find all panels associated with this component group. For a nested accordion/tab use &quot;children(.{name}-panel)&quot;. * @property {String} btnSel='find(.{name}{e}btn)' Reference to find all panel buttons associated with this component group. For a nested accordion/tab use &quot;children(.{name}-btn)&quot;. * @property {String} groupBtnSel='find(.{name}{e}ctrl{-}btn)' Reference to find all panelgroup buttons associated with this component group. For a nested accordion/tab use &quot;children(.{name}-ctrl-btn)&quot;. * @property {String} panelWrapperSel='find(.{name}{e}panel{-}wrapper):0' Reference to find the panelwrapper(s) associated with this component group. If no panelwrapper is found the component element is used. For a nested accordion/tab use &quot;children(.{name}-panel-wrapper)&quot;. * @property {String} btnWrapperSel='find(.{name}{e}btn{-}wrapper):0' Reference to find the button wrapper(s) associated with this component group. If no button wrapper is found the component element is used. For a nested accordion/tab use &quot;children(.{name}-panel-btn-wrapper)&quot;. */ static get defaults(){ return { multiple: false, toggle: true, animation: '', // 'adaptHeight' || 'slide' easing: '', duration: 400, closeOnFocusout: false, selectedIndex: -1, adjustScroll: false, scrollIntoView: false, setFocus: true, switchedOff: false, resetSwitchedOff: true, panelSel: 'find(.{name}{e}panel)', btnSel: 'find(.{name}{e}btn)', groupBtnSel: 'find(.{name}{e}ctrl{-}btn)', panelWrapperSel: 'find(.{name}{e}panel{-}wrapper):0', btnWrapperSel: 'find(.{name}{e}btn{-}wrapper):0', itemWrapper: '', setDisplay: false, closeOnEsc: false, }; } constructor(element, initialDefaults) { super(element, initialDefaults); if (this.options.multiple &amp;&amp; !this.options.toggle) { this.options.toggle = true; } this.$element = $(element); this.selectedIndexes = []; this.selectedItems = []; this.closingItems = []; this.openingItems = []; rb.rAFs(this, 'setSelectedState', 'setSwitchedOffClass'); this._onOutSideInteraction = this._onOutSideInteraction.bind(this); this.setOption('easing', this.options.easing); if (!this.options.switchedOff) { this.setOption('switchedOff', false); } else { this.setSwitchedOffClass(); } } setSwitchedOffClass(){ this.element.classList[this.options.switchedOff ? 'add' : 'remove'](rb.statePrefix + 'switched' + rb.nameSeparator + 'off'); } _handleAnimation(animationData){ if(animationData.animation == 'adaptHeight'){ if(animationData.panel.isOpen){ this.animateWrapper(animationData.panel.element); } else if(!this._closedByOpen){ this.animateWrapper(); } } } animateWrapper(openedPanel) { let end; const that = this; const panels = this.$panels.get(); const panelWrapper = this.$panelWrapper.get(0); const nextIndex = openedPanel ? panels.indexOf(openedPanel) : 0; const closingPanels = []; let curIndex = -1; const start = panelWrapper.offsetHeight; this.$panelWrapper.stop(); panelWrapper.style.height = 'auto'; this.closingItems.forEach(function (panel) { panel.style.display = 'none'; curIndex = panels.indexOf(panel); closingPanels.push(panel); }); if(openedPanel){ openedPanel.style.display = 'block'; openedPanel.style.position = 'relative'; } end = panelWrapper.offsetHeight; this.closingItems.forEach(function (panel) { panel.style.display = ''; }); if(openedPanel){ openedPanel.style.display = ''; openedPanel.style.position = ''; } $(closingPanels).addClass(rb.statePrefix + 'closing'); this.$panelWrapper .attr({'data-direction': nextIndex &gt; curIndex ? 'up' : 'down'}) .css({ overflow: 'hidden', height: start + 'px', }) .animate({height: end}, { duration: this.options.duration, easing: this.options.easing, always: function () { that.$panels.removeClass(rb.statePrefix + 'closing'); that.$panelWrapper .removeClass(rb.statePrefix + 'fx') .attr({'data-direction': ''}) ; cleanupCSS.call(this); }, }) .addClass(rb.statePrefix + 'fx') ; } setSelectedState() { this.element.classList.toggle(rb.statePrefix + 'selected' + rb.nameSeparator + 'within', !!this.selectedIndexes.length); } _updatePanelInformation() { const that = this; this.selectedIndexes.length = 0; this.selectedItems.length = 0; this.$panels.each(function (i) { if (this[componentExpando].isOpen) { that.selectedIndexes.push(i); that.selectedItems.push(this); } }); if (this.options.closeOnFocusout) { this._addRemoveFocusOut(); } this.setSelectedState(); } _addRemoveFocusOut() { const shouldInstall = this.options.closeOnFocusout &amp;&amp; this.selectedItems.length; const touchEvts = {passive: true, capture: true}; document.removeEventListener('focus', this._onOutSideInteraction, true); document.removeEventListener('mousedown', this._onOutSideInteraction, touchEvts); document.removeEventListener('touchstart', this._onOutSideInteraction, touchEvts); if (shouldInstall) { document.addEventListener('focus', this._onOutSideInteraction, true); document.addEventListener('mousedown', this._onOutSideInteraction, touchEvts); document.addEventListener('touchstart', this._onOutSideInteraction, touchEvts); } } _onOutSideInteraction(e) { var target = e.type == 'touchstart' ? (e.changedTouches || e.touches || [e])[0].target : e.target ; if (target &amp;&amp; (e.type != 'focus' || target.tabIndex != -1) &amp;&amp; !rb.contains(this.element, target) &amp;&amp; document.body.contains(target)) { this.closeAll(); } } _getElements() { let panels; const that = this; const options = this.options; const buttonWrapper = this.getElementsFromString(options.btnWrapperSel)[0]; this.$panelWrapper = $(this.getElementsFromString(options.panelWrapperSel)); this.$panels = $(this.getElementsFromString(options.panelSel, this.$panelWrapper.get(0))); this.createChildComponents('panel', this.$panels.get(), [ { name: 'itemWrapper', computeValue: (value, name, component) =&gt; component.interpolateName(value || ''), }, 'resetSwitchedOff', 'setFocus', 'closeOnEsc', 'adjustScroll', 'scrollIntoView', 'setDisplay', 'autofocusSel', 'switchedOff', ]).forEach(panel =&gt; { panel.group = that.element; panel.groupComponent = that; }); panels = this.$panels; this.$buttons = $(this.getElementsFromString(options.btnSel, buttonWrapper)); this.createChildComponents('panelbutton', this.$buttons.get(), [ { name: 'toggle', childName: 'type', computeValue: (value) =&gt; value ? 'toggle' : 'open', }, 'preventDefault', 'switchedOff', ]).forEach((btn, index)=&gt;{ const panel = panels.get(index); if(panel){ btn._setTarget(panels.get(index)); } }); this.$groupButtons = $(this.getElementsFromString(options.groupBtnSel)); this.createChildComponents('panelgroupbutton', this.$groupButtons.get(), [ { name: 'target', computeValue: () =&gt; this.element, }, 'preventDefault', 'switchedOff', ]); } /** * Closes all panels of a group. If a panel is passed as the except argument, this panel won't be closed. * @param {Element|ComponentInstance|Number} [except] */ closeAll(except) { if(this.selectedItems.length){ this.$panels.get().forEach(function (panel, i) { const component = live.getComponent(panel); if (component &amp;&amp; component != except &amp;&amp; panel != except &amp;&amp; i !== except) { component.close(); } }); } } /** * Opens all panels of a group. If a panel is passed as the except argument, this panel won't be opened. * @param {Element|ComponentInstance|Number} [except] */ openAll(except){ this.$panels.get().forEach(function(panel, i){ const component = live.getComponent(panel); if (component &amp;&amp; component != except &amp;&amp; panel != except &amp;&amp; i !== except) { component.open(); } }); } /** * Toggles all panel isOpen state */ toggleAll(){ if(this.selectedItems.length){ this.closeAll(); } else { this.openAll(); } } _triggerOnce() { if (!this._isTriggering) { let that = this; this._isTriggering = true; setTimeout(function () { that._isTriggering = false; that.trigger(); }); } } panelChangeCB(panelComponent, action) { const options = this.options; if(action.startsWith('before')){ if (action == 'beforeopen' &amp;&amp; !options.multiple &amp;&amp; this.selectedItems.length) { this._closedByOpen = true; this.closeAll(panelComponent); this._closedByOpen = false; } this[action == 'beforeopen' ? 'openingItems' : 'closingItems'].push(panelComponent.element); this._updatePanelInformation(); } else if(action.startsWith('after')){ if(this.openingItems.length){ this.openingItems.length = 0; } if(this.closingItems.length){ this.closingItems.length = 0; } this._triggerOnce(); } } /** * Selects next panel. * @param options {Object} options Options are passed to the open method of the panel instance. */ next(options) { let selectedIndex = this.selectedIndexes[0]; selectedIndex = selectedIndex == null ? 0 : selectedIndex + 1; if (selectedIndex &gt;= this.$panels.get().length) { selectedIndex = 0; } this.selectIndex(selectedIndex, options); } /** * Selects previous panel. * @param options {Object} options Options are passed to the open method of the panel instance. */ prev(options) { let selectedIndex = this.selectedIndexes[0]; selectedIndex = selectedIndex == null ? 0 : selectedIndex - 1; if (selectedIndex &lt; 0) { selectedIndex = this.$panels.get().length - 1; } this.selectIndex(selectedIndex, options); } getComponentByIndexOrDOM(index) { if (index == null) { index = 0; } let panel = typeof index == 'number' ? this.$panels.get(index) : index ; if (!panel || !panel[componentExpando]) { return false; } return panel[componentExpando]; } /** * Selects/opens a panel. * @param index {Number|Element} * @param options {Object} Options are passed to the open method of the panel instance. * @returns {Boolean} */ selectIndex(index, options) { const component = this.getComponentByIndexOrDOM(index); return component &amp;&amp; component.open(options); } /** * Closes a panel. * @param index {Number|Element} * @param options {Object} Options are passed to the close method of the panel instance. * @returns {Boolean} */ deselectIndex(index, options) { const component = this.getComponentByIndexOrDOM(index); return component &amp;&amp; component.close(options); } _switchOff() { this.setSwitchedOffClass(); } _switchOn() { if (!this.$panelWrapper || !this.$panels.length) { this._getElements(); } this._updatePanelInformation(); this.setSwitchedOffClass(); if (!this.selectedIndexes.length) { this.selectIndex(this.options.selectedIndex, {animationPrevented: true, setFocus: false}); } } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); if (name == 'multiple' &amp;&amp; value &amp;&amp; !this.options.toggle) { this.setOption('toggle', true, isSticky); } else if (name == 'easing' &amp;&amp; value &amp;&amp; typeof value == 'string') { rb.addEasing(value); } else if (name == 'closeOnFocusout') { this._addRemoveFocusOut(); } else if (name == 'switchedOff') { if (value) { this._switchOff(); } else { this._switchOn(); } } if ((name == 'toggle' || name == 'multiple') &amp;&amp; this.options.multiple &amp;&amp; !this.options.toggle) { setTimeout(() =&gt; { if (this.options.multiple &amp;&amp; !this.options.toggle) { this.setOption('toggle', true, isSticky); } }); } } } Component.register('panelgroup', PanelGroup); export default PanelGroup; class PanelGroupButton extends components.button { } Component.register('panelgroupbutton', PanelGroupButton); /** * Class component to create a tab component. This component simply just changes some default options of the [panelgroup component]{@link rb.components.panelgroup}. * @alias rb.components.tabs * @extends rb.components.panelgroup * * @param element * @param initialDefaults * * @example * &lt;div class=&quot;rb-tabs js-rb-click&quot; data-module=&quot;tabs&quot;&gt; * &lt;button type=&quot;button&quot; class=&quot;tabs-btn&quot; aria-expanded=&quot;true&quot;&gt;1&lt;/button&gt; * &lt;button type=&quot;button&quot; class=&quot;tabs-btn&quot;&gt;2&lt;/button&gt; * * &lt;button type=&quot;button&quot; class=&quot;tabs-ctrl-btn&quot; data-type=&quot;prev&quot;&gt;&amp;lt;&lt;/button&gt; * &lt;button type=&quot;button&quot; class=&quot;tabs-ctrl-btn&quot; data-type=&quot;next&quot;&gt;&amp;gt;&lt;/button&gt; * * &lt;div class=&quot;tabs-panel is-open&quot;&gt; * {{panelContent}} * &lt;/div&gt; * &lt;div class=&quot;tabs-panel&quot;&gt; * {{panelContent}} * &lt;/div&gt; * &lt;/div&gt; * @example * rb.$('.rb-tabs').on('tabschanged', function(){ * console.log(rb.$(this).rbComponent().selectedIndexes); * }); * * rb.$('.rb-tabs').rbComponent().next(); */ class Tabs extends components.panelgroup { /** * Changed options compared to the panelgroup component. Go to {@link rb.components.panelgroup#defaults} for detailed option descriptions. * * @static * @mixes rb.components.panelgroup.defaults * @property {Boolean} toggle=false * @property {Number} selectedIndex=0 * @property {String} animation='adaptHeight' */ static get defaults(){ return { selectedIndex: 0, toggle: false, animation: 'adaptHeight', }; } } Component.register('tabs', Tabs); /** * Class component to create a accordion component. This component simply just changes some default options of the [panelgroup component]{@link rb.components.panelgroup}. * @alias rb.components.accordion * @extends rb.components.panelgroup * * * @example * &lt;div class=&quot;rb-accordion js-rb-click&quot; data-module=&quot;accordion&quot;&gt; * &lt;button type=&quot;button&quot; class=&quot;accordion-btn&quot; aria-expanded=&quot;true&quot;&gt;1&lt;/button&gt; * &lt;div class=&quot;accordion-panel is-open&quot;&gt; * {{panelContent}} * &lt;/div&gt; * * &lt;button type=&quot;button&quot; class=&quot;accordion-btn&quot;&gt;2&lt;/button&gt; * &lt;div class=&quot;accordion-panel&quot;&gt; * {{panelContent}} * &lt;/div&gt; * &lt;/div&gt; * @example * rb.$('.rb-tabs').on('accordionchanged', function(){ * console.log(rb.$(this).rbComponent().selectedIndexes); * }); */ class Accordion extends components.panelgroup { /** * Changed options compared to the panelgroup component. Go to {@link rb.components.panelgroup#defaults} for detailed option descriptions. * * @static * @mixes rb.components.panelgroup.defaults * @property {Boolean} toggle=false * @property {Number} selectedIndex=0 * @property {String} animation='slide' * @property {String} adjustScroll=10 */ static get defaults(){ return { selectedIndex: 0, toggle: false, animation: 'slide', adjustScroll: 10, itemWrapper: '.{name}{e}item', }; } } Component.register('accordion', Accordion); × Search results Close "},"components_button.js.html":{"id":"components_button.js.html","title":"Source: components/button.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/button.js import rb, { Component } from '../core'; /** * Class component to create a button. * @alias rb.components.button * * @extends rb.Component * * @param element * @param initialDefaults * * @example * ```html * &lt;button type=&quot;button&quot; * data-module=&quot;button&quot; * class=&quot;js-rb-click&quot; * aria-controls=&quot;panel-1&quot; * data-button-type=&quot;open&quot;&gt; * click me * &lt;/button&gt; * &lt;div id=&quot;panel-1&quot; data-module=&quot;panel&quot;&gt;&lt;/div&gt; * ``` */ class Button extends Component { /** * @static * * @mixes rb.Component.defaults * * @property {Object} defaults * @property {String} defaults.target=&quot;&quot; String that references the target element. Is processed by rb.elementFromStr. * @property {String} defaults.type=&quot;toggle&quot; Method name to invoke on target component. * @property {Boolean} defaults.preventDefault=false Whether the default click action should prevented. * @property {*} defaults.args=null Arguments to be used to invoke target method. */ static get defaults(){ return { target: '', type: 'toggle', args: null, switchedOff: false, }; } constructor(element, initialDefaults) { super(element, initialDefaults); this._isFakeBtn = !this.element.matches('input, button'); this._resetPreventClick = this._resetPreventClick.bind(this); rb.rAFs(this, {throttle: true}, '_switchOff', '_switchOn', '_setAriaControls'); this.setOption('args', this.options.args); if (!this.options.switchedOff) { this.setOption('switchedOff', false); } } static get events(){ return { click: '_onClick', keydown(e) { if (this.options.switchedOff) { return; } let target; const component = this.panelComponent || (target = this.getTarget()) &amp;&amp; this.component(target); if (component &amp;&amp; e.keyCode == 40 &amp;&amp; this.element.getAttribute('aria-haspopup') == 'true') { if (!('isOpen' in component) || !component.isOpen) { this._onClick(e); } else { component.setComponentFocus(); } e.preventDefault(); } else { this._delegateFakeClick(e); } }, keyup: '_delegateFakeClick', }; } _delegateFakeClick(e) { if (this.options.switchedOff) { return; } if (this._isFakeBtn &amp;&amp; (e.keyCode == 32 || e.keyCode == 13)) { e.preventDefault(); if ((e.type == 'keyup' &amp;&amp; e.keyCode == 32) || (e.type == 'keydown' &amp;&amp; e.keyCode == 13)) { this._onClick(e); this._preventClick = true; setTimeout(this._resetPreventClick, 33); } } } _resetPreventClick() { this._preventClick = false; } _simpleFocus(){ try { if (this.element != document.activeElement) { this.element.focus(); } } catch (e) {} // eslint-disable-line no-empty } _onClick(e) { let args; if (this.options.switchedOff || this._preventClick || this.element.disabled) { return; } const target = this.getTarget(); const component = target &amp;&amp; this.component(target); if (!component) { return; } if (e &amp;&amp; this.options.preventDefault &amp;&amp; e.preventDefault) { e.preventDefault(); } if (this.options.type in component) { args = this.args; this._simpleFocus(); component.activeButtonComponent = this; if (typeof component[this.options.type] == 'function') { component[this.options.type].apply(component, args); } else { component[this.options.type] = args; } } } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); switch (name) { case 'target': this._setTarget(value); break; case 'args': if (value == null) { value = []; } else if (!Array.isArray(value)) { value = [value]; } this.args = value; break; case 'switchedOff': if (value) { this._switchOff(); } else { this._switchOn(); } break; } } _switchOff() { if (this._isFakeBtn) { this.element.removeAttribute('role'); this.element.removeAttribute('tabindex'); } } _switchOn() { if (this._isFakeBtn) { this.element.setAttribute('role', 'button'); this.element.setAttribute('tabindex', '0'); } } _setAriaControls() { if(this.target){ this.$element.attr({'aria-controls': this.getId(this.target)}); } } /** * Changes/sets the target element. * @param {Element|String} [element] */ _setTarget(element) { if(!element){ element = this.options.target; } if(!element &amp;&amp; !this.options.target){ element = this.element.getAttribute('aria-controls'); } this.target = (typeof element == 'string') ? this.getElementsByString(element)[0] : element ; this.targetAttr = element; this._setAriaControls(); } /** * Returns the current target component of the button * @returns {Element} */ getTarget() { const target = this.options.target || this.element.getAttribute('aria-controls'); if (!this.target || (target != this.targetAttr &amp;&amp; target)) { this._setTarget(); } return this.target; } } Component.register('button', Button); export default Button; × Search results Close "},"components_dialog.js.html":{"id":"components_dialog.js.html","title":"Source: components/dialog.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/dialog.js import rb, { Component } from '../core'; import '../utils/scrollbarwidth'; import './_focus-component'; const $ = Component.$; const regInputs = /^(?:input|textarea)$/i; /** * Class component to create a modal dialog with a backdrop. * * @alias rb.components.dialog * * @extends rb.components._focus_component * * @param element {Element} * @param [initialDefaults] {OptionsObject} * * @fires dialog#change Fires before a dialog's `isOpen` state changes; The default behavior can be prevented. * @fires dialog#changed Fires after a dialog's `isOpen` state changed; * * @example * &lt;button aria-controls=&quot;dialog-1&quot; data-module=&quot;button&quot; type=&quot;button&quot; class=&quot;js-rb-click&quot;&gt;button&lt;/button&gt; * &lt;div id=&quot;dialog-1&quot; class=&quot;rb-dialog&quot; data-module=&quot;dialog&quot;&gt; * &lt;div class=&quot;dialog-content&quot;&gt; * {{dialogContent}} * &lt;/div&gt; * &lt;button type=&quot;button&quot; class=&quot;dialog-close&quot;&gt;close&lt;/button&gt; * &lt;/div&gt; * @example * rb.$('.rb-dialog').rbComponent().open(); * rb.$('.rb-dialog').on('dialogchanged', function(){ * console.log(rb.$(this).rbComponent().isOpen); * }); */ class Dialog extends rb.components._focus_component { /** * @static * @mixes rb.components._focus_component.defaults * * @property {Boolean} defaults.open=false Whether the dialog should be open by default * @property {Boolean} defaults.appendToBody=true * @property {String} defaults.contentUrl='' * @property {Boolean} defaults.closeOnEsc=true Whether the dialog should be closed as soon as the user presses the ESC key. * @property {Boolean} defaults.closeOnBackdropClick=true Whether the dialog should be closed as soon as the user clicks on the backdrop. * @property {String} defaults.contentId='' * @property {String} defaults.backdropClass='' * @property {Boolean} defaults.setDisplay=true * @property {String|Boolean} defaults.scrollPadding='paddingRight' Whether to set a paddingRight/paddingLeft value to the body. * @property {Boolean|String} defaults.setFocus='force' Whether the component should set the focus on open. true: sets only focus if js-rb-autofocus is found. 'force': sets focus to dialog, if no 'js-rb-autofocus' was found. */ static get defaults(){ return { open: false, closeOnEsc: true, closeOnBackdropClick: true, appendToBody: true, contentId: '', backdropClass: '', setDisplay: true, scrollPadding: 'paddingRight', trapKeyboard: true, setFocus: 'force', contentUrl: '', xhrOptions: null, }; } static get events(){ return { 'click:closest(.{name}{e}close)': function (e) { this.close(); e.preventDefault(); e.stopPropagation(); }, }; } constructor(element, initialDefaults){ super(element, initialDefaults); /** * @name rb.components.dialog.prototype.isOpen * @type {boolean} */ this.isOpen = false; this.$backdrop = $(document.createElement('div')).addClass(this.name + rb.elementSeparator + 'backdrop'); this.contentElement = this.query('.{name}{e}content'); this.rAFs({that: this, throttle: true}, '_setup', '_addContent', '_setDisplay'); this.rAFs({throttle: true}, '_open', '_close'); if (this.options.open) { this._setup(); } else { setTimeout(this._setup, 99 + (999 * Math.random())); } } _setup() { if (this.isReady || !this.element.parentNode) { return; } let backdrop, isWrapped; let backdropDocument = this.element.parentNode; const backdropDocumentName = this.name + rb.elementSeparator + 'backdrop' + rb.nameSeparator + 'document'; this.trapKeyboardElemBefore = $(document.createElement('span')).attr({ 'class': this.name + 'keyboardtrap', 'tabindex': this.options.trapKeyboard ? 0 : -1, }).get(0); this.trapKeyboardElemAfter = this.trapKeyboardElemBefore.cloneNode(); this.isReady = true; if(!backdropDocument || !backdropDocument.classList.contains(backdropDocumentName)){ backdropDocument = document.createElement('div'); backdropDocument.className = backdropDocumentName; this.$backdrop.append(backdropDocument); } else if(backdropDocument &amp;&amp; (backdrop = backdropDocument.parentNode) &amp;&amp; backdrop.classList.contains(this.name + rb.elementSeparator + 'backdrop')) { this.$backdrop = $(backdrop); isWrapped = true; } this.backdropDocument = backdropDocument; $(this.backdropDocument).before(this.trapKeyboardElemBefore).after(this.trapKeyboardElemAfter); if(this.options.backdropClass){ this.$backdrop.addClass(this.options.backdropClass); } if(this.options.appendToBody){ document.body.appendChild(this.$backdrop.get(0)); } else if(!isWrapped) { this.$element.before(this.$backdrop.get(0)); } if(!isWrapped){ backdropDocument.appendChild(this.element); } if (!this.element.getAttribute('tabindex')) { this.element.setAttribute('tabindex', '-1'); } if (!this.element.getAttribute('role')) { this.element.setAttribute('role', 'group'); } this._setUpEvents(); if (this.options.open) { this.open(); } else if(this.options.setDisplay){ this.$backdrop.css({display: 'none'}); } } _open(options) { let content; if(this.contentElement &amp;&amp; options &amp;&amp; options.contentId &amp;&amp; this._curContentId != options.contentId &amp;&amp; (content = document.getElementById(options.contentId))){ this._curContentId = options.contentId; this.contentElement.innerHTML = content.innerHTML; } if(this._xhr){ this.contentElement.innerHTML = ''; this.$backdrop.addClass(rb.statePrefix + 'loading'); } this.$backdrop.css({display: ''}); this.$backdrop.rbToggleState('open', true); rb.$root .rbToggleState('open{-}' + this.name +'{-}within', true) .rbToggleState('open{-}dialog{-}within', true) ; if(this._setScrollPadding &amp;&amp; this.options.scrollPadding){ document.body.style[this.options.scrollPadding] = this._setScrollPadding + 'px'; } if(options.focusElement){ this.setComponentFocus(options.focusElement); } else { this.storeActiveElement(); } this.$backdrop.rbToggleStateRaf('opened', this.isOpen); this.trigger(options); } /** * Opens the dialog * @param [options] {Object} options are passed to the change and changed event * @returns {boolean} */ open(options) { let scrollbarWidth; const mainOpts = this.options; if (this.isOpen || this.trigger(this._beforeEvtName, options).defaultPrevented) { return false; } if (!this.isReady) { this._setup(); } this.isOpen = true; if(!options){ options = {}; } if(typeof options.focusElement != 'object' &amp;&amp; (options.focusElement || mainOpts.setFocus)){ options.focusElement = this.getFocusElement(options.focusElement || mainOpts.setFocus == 'force'); } if(options.contentUrl){ this._xhr = rb.fetch(options.contentUrl, 'xhrOptions' in options ? options.xhrOptions : mainOpts.xhrOptions) .then(this._addContent) ; } if(this.options.setDisplay &amp;&amp; this._displayTimer){ clearTimeout(this._displayTimer); this._displayTimer = null; } this._setScrollPadding = this.options.scrollPadding &amp;&amp; rb.root.clientHeight + 1 &lt; rb.root.scrollHeight &amp;&amp; (scrollbarWidth = rb.scrollbarWidth) &amp;&amp; parseFloat(rb.getStyles(document.body)[this.options.scrollPadding]) + scrollbarWidth ; if(this._setScrollPadding){ this._oldPaddingValue = document.body.style[this.options.scrollPadding]; } if(!this.options.setDisplay &amp;&amp; options.focusElement &amp;&amp; regInputs.test(options.focusElement.nodeName)){ this._open._rbUnrafedFn.call(this, options); } else { this._open(options); } return true; } _close(options) { this.restoreFocus(true); if(this._setScrollPadding &amp;&amp; this._oldPaddingValue != null){ document.body.style[this.options.scrollPadding] = this._oldPaddingValue; this._setScrollPadding = 0; this._oldPaddingValue = null; } this.$backdrop .rbToggleState('open', false) .rbToggleState('opened', this.isOpen) ; rb.$root .rbToggleState('open{-}' + this.name +'{-}within', false) .rbToggleState('open{-}dialog{-}within', false) ; if(this.options.setDisplay){ clearTimeout(this._displayTimer); this._displayTimer = setTimeout(this._setDisplay, 5000); } this.trigger(options); } /** * Closes the dialog * @param [options] {Object} options are passed to the change and changed event * @returns {boolean} */ close(options) { if (!this.isOpen || this.trigger(this._beforeEvtName, options).defaultPrevented) { return false; } this.isOpen = false; this._xhr = null; this._close(options); return true; } /** * Toggles the dialog `isOpen` state. * @param [options] {Object} options are passed to the change and changed event * @returns {boolean} */ toggle(options) { this[this.isOpen ? 'close' : 'open'](options); } _addContent(data){ if(this._xhr &amp;&amp; this.contentElement){ this.contentElement.innerHTML = data.data; } this.$backdrop.removeClass(rb.statePrefix + 'loading'); this._xhr = null; } _setDisplay(){ this.$backdrop.css({display: this.isOpen ? '' : 'none'}); this._displayTimer = null; } _setUpEvents() { const options = this.options; this.$backdrop .on('click', (e)=&gt; { if (options.closeOnBackdropClick &amp;&amp; (e.target == e.currentTarget || e.target == this.backdropDocument)) { this.close(); e.preventDefault(); e.stopPropagation(); } }) ; this.$backdrop.on('keydown', (e)=&gt;{ if (e.keyCode == 27 &amp;&amp; options.closeOnEsc &amp;&amp; !e.defaultPrevented) { this.close(); e.preventDefault(); e.stopPropagation(); } }); this.trapKeyboardElemBefore.addEventListener('focus', (e)=&gt;{ if(options.trapKeyboard) { let focusElem = this.queryAll('.{name}{e}close'); e.preventDefault(); try { focusElem[focusElem.length - 1].focus(); } catch (er) { rb.logInfo('Focus error', er); } } }, true); this.trapKeyboardElemAfter.addEventListener('focus', (e)=&gt;{ if(options.trapKeyboard){ e.preventDefault(); try { this.element.focus(); } catch (er){ rb.logInfo('Focus error', er); } } }, true); } } rb.ready.then(function(){ rb.click.add('dialog', function(element, event, attr){ let dialog; let opts = rb.jsonParse(attr); if(typeof opts == 'string'){ opts = {id: opts}; } dialog = document.getElementById(opts.id); opts.event = event; if(dialog &amp;&amp; (dialog = rb.getComponent(dialog))){ dialog.open(opts); event.preventDefault(); opts.event = event; } }); }); Component.register('dialog', Dialog); export default Dialog; × Search results Close "},"components_itemscroller.js.html":{"id":"components_itemscroller.js.html","title":"Source: components/itemscroller.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/itemscroller.js import rb, {Component} from '../core'; import '../utils/resize'; import '../utils/prefixed'; import '../utils/draggy_wheel'; import cssSupports from '../utils/css-supports'; const $ = Component.$; const regIndex = /\\{index}/g; const orderProp = rb.prefixed('order') || rb.prefixed('flexOrder'); const supportSomeOrder = !!orderProp; const transformProp = rb.prefixed('transform'); const supports3dTransform = cssSupports('transform', 'translate3d(0,0,0)'); /** * Class component to create a carousel/slider/itemscroller. * @alias rb.components.itemscroller * * @param element * @param initialDefaults * * @extends rb.Component * * @fires componentName#change * @fires componentName#changed * @fires componentName#changedcompleted * @fires componentName#pagelengthchange * * @prop {Number} pageLength Returns the page length (page length depends on item cells and scrollStep option) * * @prop {$.CallbackObject} onslide * @prop {Function} onslide.add Add a onslide callback function * @prop {Function} onslide.remove Remove a onslide callback function * * @example * &lt;!-- markup example --&gt; * &lt;div class=&quot;rb-itemscroller js-rb-live&quot; data-module=&quot;itemscroller&quot;&gt; * {{#if buttons }} * &lt;button type=&quot;button&quot; class=&quot;itemscroller-btn-prev&quot; tabindex=&quot;-1&quot; aria-hidden=&quot;true&quot;&gt;{{buttons.prev}}&lt;/button&gt; * &lt;button type=&quot;button&quot; class=&quot;itemscroller-btn-next&quot; tabindex=&quot;-1&quot; aria-hidden=&quot;true&quot;&gt;{{buttons.next}}&lt;/button&gt; * {{/if}} * &lt;div class=&quot;itemscroller-viewport&quot;&gt; * &lt;div class=&quot;itemscroller-content&quot;&gt; * {{#each items}} * &lt;div class=&quot;itemscroller-cell&quot;&gt; * &lt;div class=&quot;dummy-item&quot;&gt;&lt;/div&gt; * &lt;/div&gt; * {{/each}} * &lt;/div&gt; * &lt;/div&gt; * {{#if pagination}} * &lt;div class=&quot;itemscroller-pagination&quot;&gt;&lt;/div&gt; * {{/if}} * &lt;/div&gt; * @example * //combines a select element with an itemscroller * $('.rb-itemscroller select.itemscroller-select').each(function(){ * var $itemScroller = $(this).closest('.rb-itemscroller'); * var $itemSelect = $(this); * var itemscroller = $itemScroller.rbComponent(); * * var buildOptions = function(){ * var i, option; * $itemSelect.html(''); * * for(i = 0; i &lt; itemscroller.pageLength; i++){ * option = document.createElement('option'); * option.value = i; * option.text = i; * option.selected = i == itemscroller.selectedIndex; * $itemSelect.append(option); * } * }; * * $itemScroller.on('itemscrollerpagelengthchanged', buildOptions); * * $itemScroller.on('itemscrollerchanged', function(){ * $itemSelect.prop({selectedIndex: itemscroller.selectedIndex}); * }); * * $itemSelect.on('change', function(){ * itemscroller.selectedIndex = this.selectedIndex; * }); * * buildOptions(); * }); */ class ItemScroller extends Component { /** * @static * @mixes rb.Component.prototype.defaults * * @property {Boolean} centerMode=false Whether cells/selected cell should be centered in scroller. * @property {Boolean} carousel=false Whether scroller should be an infinite carousel. * @property {Number} selectedIndex=0 Initially selected index. * @property {Number|String} scrollStep='auto' How many cells to scroll. Either number of cells or 'view' (i.e. viewport component). 'auto' means 1 for centerMode and 'view' otherwise. * @property {String} easing='ease-in-out' Easing value for the slide animation. * @property {String} dragEasing='0.1, 0.25, 0.1, 1.03' Easing value for the slide animation after drag. * @property {Number} duration=600 Average duration for the slide animation. * @property {Boolean} mouseDrag=true Whether scroller should be draggable via mouse. * @property {Boolean} wheel=true Whether scroller should be draggable via wheel/trackpad scroll. * @property {String|false} dragExclude=false Whether drag/swipe should be excluded on certain element selectors. * @property {Boolean} mandatorySnap=false Whether each page generates a mandatory snap point. * @property {String} paginationItemTpl The markup for the pagination buttons. * @property {String|false|undefined} excludeCell=false Simple selector to exclude cells from scroller cell. * @property {Boolean} excludeHiddenCells=true Excludes cells that are set to `display: none`. * @property {Boolean} switchedOff=false Whether the scroller should be turned off. * @property {Boolean} useTransform=true Whether the scroller should use CSS transform3d or left property. * @property {Boolean} usePx=false Whether the scroller should use CSS px units instead of % units. Set this to `true` if items are not using % as width unit. */ static get defaults(){ return { switchedOff: false, centerMode: false, selectedIndex: 0, scrollStep: 'auto', mouseDrag: true, dragExclude: false, easing: 'ease-in-out',//0.045, 0.235, 0.025, 1.025 dragEasing: '0.1, 0.25, 0.1, 1.03',//0.045, 0.235, 0.025, 1.025 duration: 600, paginationItemTpl: '&lt;span class=&quot;{name}{e}pagination{-}btn&quot;&gt;&lt;/span&gt;', excludeCell: false, excludeHiddenCells: true, useTransform: true, carousel: false, mandatorySnap: false, startOrder: -1, endOrder: 99, usePx: false, wheel: true, }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.usesTransform = this.options.useTransform &amp;&amp; !!transformProp; this._pos = 0; this._selectedIndex = this.options.selectedIndex; this.scroller = this.query('.{name}{e}content'); this.$scroller = $(this.scroller); this.viewport = this.query('.{name}{e}viewport'); this.$pagination = $(this.query('.{name}{e}pagination')); this.$pageLength = $(this.query('.{name}{e}page{-}length')); this.$currentIndex = $(this.query('.{name}{e}current{-}index')); this.$paginationBtns = $([]); this.onslide = $.Callbacks(); this.setOption('easing', this.options.easing); this.setOption('dragEasing', this.options.dragEasing); this.setOption('duration', this.options.duration); this.calculateLayout = this.calculateLayout.bind(this); this.throttledCalculateLayout = rb.throttle(this.calculateLayout); this.reflow = this.throttledCalculateLayout; this.setPos = rb.rAF(this._setPos, {that: this, throttle: true}); rb.rAFs(this, {throttle: true}, '_writeLayout', '_createPagination', '_switchOff', 'setSwitchedOffClass', '_updateControls'); this._slideProgress = this._slideProgress.bind(this); this._slideComplete = this._slideComplete.bind(this); this._dragStart = this._dragStart.bind(this); this._dragEnd = this._dragEnd.bind(this); this._dragMove = this._dragMove.bind(this); this._generateHelper(); this._setupEvents(); if (!this.options.switchedOff) { this.setOption('switchedOff', false); } else { this.setSwitchedOffClass(); } } static get events(){ return { 'click:closest(.{name}{e}btn{-}next)'() { if (this.options.switchedOff) { return; } if (this.isCarousel) { this.selectNext(); } else { this.selectNextIndex(); } }, 'click:closest(.{name}{e}btn{-}prev)'() { if (this.options.switchedOff) { return; } if (this.isCarousel) { this.selectPrev(); } else { this.selectPrevIndex(); } }, 'click:closest(.{name}{e}pagination{-}btn)'(e) { if (this.options.switchedOff) { return; } var index = this.$paginationBtns.index(e.delegatedTarget || e.currentTarget); this.selectedIndex = index; }, 'rb_resize:width()': 'calculateLayout', }; } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); switch (name) { case 'centerMode': case 'scrollStep': case 'carousel': this._calculatePages(); this._writeLayout(); if (name == 'carousel' &amp;&amp; value) { this.$queryAll('.{name}{e}btn{-}next, .{name}{e}btn{-}prev') .prop({disabled: false}) .removeClass(rb.statePrefix + 'disabled') ; } break; case 'easing': this._easing = rb.addEasing(value); this.easing = this._easing; break; case 'dragEasing': this._dragEasing = rb.addEasing(value); break; case 'duration': this.duration = value; this.maxDuration = value * 1.2; this.minDuration = value / 1.2; break; case 'switchedOff': if (value) { this._switchOff(); } else { this._switchOn(); } break; case 'excludeCell': case 'excludeHiddenCells': this.updateCells(); break; } } /** * Returns the selected page index * @returns {Number} */ get selectedIndex() { return this._selectedIndex; } /** * Set the selected page index. * @param {Number} index */ set selectedIndex(index) { this.selectIndex(index); } _switchOff() { if ($.fn.draggy) { $(this.viewport).draggy('destroy'); } var cellCSS = {}; this.$cells .rbToggleState('active{-}done', false) .rbToggleState('active', false) .rbToggleState('activated{-}done', false) .rbToggleState('activated', false) ; cellCSS[orderProp] = ''; this.$cells.css(cellCSS); this.$scroller.css({ position: '', left: '', transform: '', }); $(this.viewport).css({ position: '', }); this.helperElem.style.display = 'none'; // reset pagination this.$pagination.html(''); this.$paginationBtns = $([]); this.setSwitchedOffClass(); } setSwitchedOffClass(){ this.element.classList.toggle(rb.statePrefix + 'switched' + rb.nameSeparator + 'off', this.options.switchedOff); } _switchOn() { this.updateCells(); this._setupTouch(); this._mainSetup(); this._createPagination(); this.setSwitchedOffClass(); } _generateHelper(){ this.helperElem = $(document.createElement('div')) .attr({ 'class': 'js' + rb.nameSeparator + this.name + rb.elementSeparator + 'helper', style: 'width:0;padding:0;margin:0;visibility:hidden;border:0;height:100%;min-height:9px', }) .css({ webkitFlexGrow: 0, flexGrow: 0, display: this.options.switchedOff ? 'none' : '' }) .get(0) ; this._setOrder(this.helperElem, this.options.startOrder); } _mainSetup() { var that = this; rb.rAFQueue(function () { $(that.viewport).css({ position: 'relative', }); that.$scroller.css({ position: 'relative', }); that.helperElem.style.display = ''; that._updateControls(); that._slideComplete(); }, true); } _setupEvents() { this._setupFocusScroll(); } _setupFocusScroll() { var that = this; var cellSel = '.' + this.name + rb.elementSeparator + 'cell'; var isTestStopped = false; var keyboardFocusClass = rb.utilPrefix + 'keyboardfocus' + rb.nameSeparator + 'within'; var evtOpts = {capture: true, passive: true}; var resetScrollLeft = function () { that.viewport.scrollLeft = 0; }; var scrollIntoView = function (e) { var cell, pageIndex, focusedElement; if (that.options.switchedOff) { return; } if (!isTestStopped) { if(e.type == 'focus'){ focusedElement = e.target; } else { focusedElement = document.activeElement; } if (focusedElement &amp;&amp; focusedElement.closest &amp;&amp; rb.root.classList.contains(keyboardFocusClass) &amp;&amp; (cell = focusedElement.closest(cellSel)) &amp;&amp; that.isCellVisible(cell) !== true) { pageIndex = that.getPageIndexOfCell(cell); if(pageIndex != that._selectedIndex){ that.selectedIndex = pageIndex; } } } setTimeout(resetScrollLeft); resetScrollLeft(); }; var unstopTest = function () { isTestStopped = false; }; var stopTest = function () { if (!isTestStopped) { isTestStopped = true; setTimeout(unstopTest, 99); } }; this.scroller.addEventListener('mousedown', stopTest, evtOpts); this.scroller.addEventListener('touchstart', stopTest, evtOpts); this.scroller.addEventListener('touchend', stopTest, evtOpts); this.scroller.addEventListener('click', stopTest, evtOpts); this.scroller.addEventListener('focus', scrollIntoView, evtOpts); this.viewport.addEventListener('scroll', scrollIntoView); } /** * [_snapTo description] * @param {number} dir direction * @param {number} velocity px in last 300ms * @param {number} length length moved during last recognition */ _snapTo(dir, velocity, length) { var pageIndex; var fullVel = velocity + Math.abs(dir); length = Math.abs(length); this.easing = this._dragEasing; if (dir &amp;&amp; (fullVel &gt; 33 || (fullVel &gt; 9 &amp;&amp; length &gt; 99) || (fullVel &gt; 3 &amp;&amp; length &gt; 200)) ) { if (velocity &gt; 240 &amp;&amp; !this.options.mandatorySnap &amp;&amp; length &gt; 99) { velocity = (velocity - 230) / 250 * this.velUnit; if (dir &lt; 0) { velocity *= -1; } } else { velocity = 0; } pageIndex = this[dir &lt; 0 ? 'getNext' : 'getPrev'](velocity); this.selectIndex(pageIndex); } else { this.selectNearest(); } } getNearest() { var prop, curDiff; var smallestDif = Number.MAX_VALUE; var index = 0; var nowIndex = this.selectedIndex; var pos = { prev: this.getPrev() + this.baseIndex, next: this.getNext() + this.baseIndex, }; if (pos.next - pos.prev &gt; 1) { pos.cur = pos.next - 1; } for (prop in pos) { curDiff = Math.abs(this._pos - this._getPosition(pos[prop])); if (curDiff &lt; smallestDif || (nowIndex == pos[prop] &amp;&amp; curDiff - 0.9 &lt;= smallestDif)) { smallestDif = curDiff; index = pos[prop]; } } return index - this.baseIndex; } selectNearest(noAnimate) { return this.selectIndex(this.getNearest(), noAnimate); } _getPosition(index) { var halfWidth = (this.viewportWidth / 2); var curData = this.pageData[index]; var position = curData.l; if (this.options.centerMode) { position = halfWidth + (position * -1) - ((curData.r - position) / 2); } else { position *= -1; } if(!this.isCarousel &amp;&amp; position &lt; this.minScroll){ position = this.minScroll; } return (position || 0); } /** * Returns next page index from current position * @param [offset] {Number} Offset will be added to the current position to allow manipulations * @returns {number} */ getNext(offset) { var i, len, cellWidth; var curPos = ((this._pos + (offset || 0)) * -1) + 1; var index = this.pageData.length - 1; for (i = 0, len = index + 1; i &lt; len; i++) { cellWidth = this._getPosition(i) * -1; if (cellWidth &gt; curPos) { index = i; break; } } return index - this.baseIndex; } /** * Selects next page index based on current position data * @param [noAnimate] If set to true, the page index will be changed without any animations * @returns {Number|undefined} */ selectNext(noAnimate) { return this.selectIndex(this.getNext(), noAnimate); } /** * Returns previous page index from current position * @param [offset] {Number} Offset will be added to the current position to allow manipulations * @returns {number} */ getPrev(offset) { var cellWidth; var curPos = ((this._pos + (offset || 0)) * -1) - 1; var index = 0; var i = this.pageData.length - 1; while (i &gt;= 0) { cellWidth = this._getPosition(i) * -1; if (cellWidth &lt; curPos) { index = i; break; } i--; } return index - this.baseIndex; } /** * Selects previous page index based on current position data * @param [noAnimate] If set to true, the page index will be changed without any animations * @returns {Number|undefined} */ selectPrev(noAnimate) { return this.selectIndex(this.getPrev(), noAnimate); } /** * Returns page index of a specific item cell * @param cellIndex {Number|Element} Either the index of the cell or the cell DOM element * @returns {Number} */ getPageIndexOfCell(cellIndex) { if (typeof cellIndex != 'number') { cellIndex = this.$cells.index(cellIndex); } var cellData = this.cellData[cellIndex]; return cellData ? cellData[cellData.isSide ? 'uIndex' : 'pageIndex'] : -1; } /** * Selects a specifc item cell * @param cellIndex {Number|Element} Either the index of the cell or the cell DOM element * @param [noAnimate] {Boolean|Undefined} If set to true, the page index will be changed without any animations */ selectCell(cellIndex, noAnimate) { this.selectIndex(this.getPageIndexOfCell(cellIndex), noAnimate); } /** * Returns whether a specific cell is in scroller viewport * @param cellIndex {Number|Element} Either the index of the cell or the cell DOM element * @param [useEndPos=false] {boolean|Number} Wether to use the endpos in case of an animating scroller. In case a number is given this will be used. * @returns {Boolean|String} Returns either true|false or 'partial' */ isCellVisible(cellIndex, useEndPos) { let cellData, cellLeft, cellRight, roundingTolerance; let inview = false; const pos = typeof useEndPos == 'number' ? useEndPos : useEndPos &amp;&amp; this._endPos != null ? this._endPos : this._pos ; let viewportLeft = pos * -1; let viewportRight = viewportLeft + this.viewportWidth; let viewportLeftPartial = viewportLeft; let viewportRightPartial = viewportRight; if (typeof cellIndex != 'number') { cellIndex = this.$cells.index(cellIndex); } cellData = this.cellData[cellIndex]; if (cellData) { roundingTolerance = (0.6 * cellIndex) + 1; viewportLeft -= roundingTolerance; viewportRight += roundingTolerance; viewportLeftPartial += roundingTolerance; viewportRightPartial -= roundingTolerance; cellLeft = cellData.isSide ? cellData.ul : cellData.l; cellRight = cellData.isSide ? cellData.ur : cellData.r; if (viewportLeft &lt;= cellLeft &amp;&amp; viewportRight &gt;= cellRight) { inview = true; } else if ((viewportLeftPartial &lt;= cellLeft &amp;&amp; viewportRightPartial &gt;= cellLeft ) || (viewportLeftPartial &lt;= cellRight &amp;&amp; viewportRightPartial &gt;= cellRight )) { inview = 'partial'; } } return inview; } _slideProgress(tween, progress) { this._setPos((this._animEnd - this._animStart) * this.easing(progress) + this._animStart); } _slideComplete() { var curPage = this.pageData[this._selectedIndex + this.baseIndex]; var activeDone = rb.statePrefix + 'active' + rb.nameSeparator + 'done'; this.isAnimated = false; this.$cells.removeClass(activeDone); this.easing = this._easing; if (curPage) { ( curPage.$cellElems || (curPage.$cellElems = $(curPage.cellElems)) ) .addClass(activeDone) .addClass(rb.statePrefix + 'activated' + rb.nameSeparator + 'done') ; } this.trigger(this._evtName + 'completed'); } /** * Selects next page index based on current index */ selectNextIndex() { var index = this._selectedIndex + 1 + this.baseIndex; if (index &lt; this.pageData.length) { index -= this.baseIndex; this.selectedIndex = index; } } /** * Selects previous page index based on current index */ selectPrevIndex() { var index = this._selectedIndex - 1 + this.baseIndex; if (index &gt;= 0) { index -= this.baseIndex; this.selectedIndex = index; } } /** * Selects a page index * @param index {Number} The page index, that should selected * @param [noAnimate] {Boolean|Undefined} If set to true, the page index will be changed without any animations * @returns {*|number} */ selectIndex(index, noAnimate) { var trigger, duration, setPos, curIndex; var countIndex = index + this.baseIndex; if (!arguments.length || countIndex &lt; 0 || countIndex &gt;= this.pageData.length || !this.$cells.length) { return this._selectedIndex; } if (this.options.switchedOff) { return; } curIndex = this._selectedIndex || 0; setPos = this._getPosition(countIndex); if (index &lt; 0) { index = this.baseLength + index; } else if (index &gt;= this.baseLength) { index = index - this.baseLength; } if (!this.isCarousel) { setPos = Math.max(Math.min(setPos, this.maxScroll), this.minScroll); } if (setPos != this._pos) { if (curIndex != index) { if (this.trigger(this._beforeEvtName, {nextIndex: index}).defaultPrevented) { return this._selectedIndex; } trigger = true; this._selectedIndex = index; } this._animStart = false; this._animEnd = setPos; this.scroller.rbItemscrollerPos = this._pos; this.$scroller.stop(); duration = this.duration * ((setPos &lt; this._pos) ? this._pos - setPos : setPos - this._pos) / this.viewportWidth; duration = Math.max(Math.min(duration, this.maxDuration), this.minDuration); this._endPos = setPos; if (noAnimate) { this.setPos(setPos); this.isAnimated = false; } else { this.isAnimated = true; this._animStart = this._pos; this.$scroller .animate( { rbItemscrollerPos: setPos, }, { easing: 'linear', start: this._pos, progress: this._slideProgress, duration: duration, complete: this._slideComplete, } ); } this._updateControls(setPos); if (trigger) { this.trigger({prevIndex: curIndex}); if (noAnimate) { this._slideComplete(); } } } this._selectedIndex = index; return this._selectedIndex; } /** * Returns whether scroller has reached the start point * @param [position] {Number} If no pos is given the current position is used * @returns {boolean} */ isStartReached(position) { if (position == null) { position = this._pos; } return !this.isCarousel &amp;&amp; position &gt;= this.maxScroll; } /** * Returns whether scroller has reached the end point * @param [position] {Number} If no pos is given the current position is used * @returns {boolean} */ isEndReached(position) { if (position == null) { position = this._pos; } return !this.isCarousel &amp;&amp; position &lt;= this.minScroll; } _updateControls(pos) { var isEnd, isStart; var curPage = this.pageData[this._selectedIndex + this.baseIndex]; if (!this.isCarousel || this.isCarouselChanged) { isEnd = this.isEndReached(pos); isStart = this.isStartReached(pos); this.isCarouselChanged = false; this.$queryAll('.{htmlName}{e}btn{-}next') .prop({disabled: isEnd}) .rbToggleState('disabled', isEnd) ; this.$queryAll('.{htmlName}{e}btn{-}prev') .prop({disabled: isStart}) .rbToggleState('disabled', isStart) ; } this.element.setAttribute('data-current-index', this._selectedIndex + 1); this.$currentIndex.html(this._selectedIndex + 1); this.$cells.removeClass(rb.statePrefix + 'active'); if (curPage) { ( curPage.$cellElems || (curPage.$cellElems = $(curPage.cellElems)) ) .addClass(rb.statePrefix + 'activated') .addClass(rb.statePrefix + 'active') ; } this.$paginationBtns .removeClass(rb.statePrefix + 'selected') .eq(this._selectedIndex) .addClass(rb.statePrefix + 'selected') ; } _dragStart(){ this.isAnimated = false; $(this.scroller).stop(); } _dragMove(draggy){ if (draggy.relPos.x) { this._setRelPos(draggy.relPos.x, true); } } _dragEnd(draggy){ if (!draggy.movedPos.x) { this.selectNearest(); return; } var dir = draggy.lastPos.x - draggy.velPos.x; if (draggy.horizontalVel &lt; 9) { dir = 0; if (draggy.horizontalVel &lt; 9 &amp;&amp; draggy.horizontalVel &lt; 9) { draggy.allowClick(); } } this._snapTo(dir, draggy.horizontalVel, draggy.movedPos.x); } _setupTouch() { if (!$.fn.draggy) { return; } $(this.viewport).draggy({ vertical: false, useMouse: this.options.mouseDrag, useWheel: this.options.wheel, exclude: this.options.dragExclude, start: this._dragStart, end: this._dragEnd, move: this._dragMove, }); } _setRelPos(relPos, keepInBounds) { var minOverflow, maxOverflow, overflow, overflow_max; var newPos = this._pos + relPos; // reduce relative change, if the new pos is out of min/maxScroll if(keepInBounds &amp;&amp; !this.isCarousel){ minOverflow = Math.abs(Math.min(0, newPos - this.minScroll)); maxOverflow = Math.abs(Math.max(0, newPos - this.maxScroll)); overflow = minOverflow &gt; maxOverflow ? minOverflow : maxOverflow; overflow_max = this.viewportWidth / 1.5; if(overflow){ newPos = this._pos + (relPos * (1 - (overflow/overflow_max + 0.05))); } } this._pos = newPos; this.setPos(newPos); } _setOrder(elem, order){ elem.style[orderProp] = order; } _changeWrap(side, prop) { var i, len, curCell, order, unitPos; var posPages = this.posPages[side]; var cells = this.posPages[side].rbCells; if (prop == 'ul') { this.isWrap = side; } else { this.isWrap = ''; } order = (this.isWrap == 'left') ? this.options.startOrder : (this.isWrap == 'right') ? this.options.endOrder: '' ; unitPos = this.options.usePx ? posPages._helperLeft + 'px' : (posPages._helperLeft / this.viewportWidth * 100) + '%' ; this.helperElem.style.marginLeft = this.isWrap ? unitPos : '' ; if(this._isPageDirty){ this._isPageDirty = false; for(i = 0, len = this.$cells.length; i &lt; len; i++){ this.$cells.get(i).style[orderProp] = ''; } } for (i = 0, len = cells.length; i &lt; len; i++) { curCell = cells[i]; curCell.isSide = this.isWrap; this._setOrder(curCell.elem, order); } } _setPos(pos) { var shouldWrapLeft, shouldWrapRight, unWrapLeft, unWrapRight, unitPos; if (this.isCarousel) { if (pos &gt;= this.maxWrapLeft || pos &lt;= this.minWrapRight) { if (pos &gt;= this.maxWrapLeft) { pos -= this.carouselWidth; } else if (pos &lt;= this.minWrapRight) { pos += this.carouselWidth; } } shouldWrapLeft = (pos &gt;= this.minWrapLeft &amp;&amp; pos &lt;= this.maxWrapLeft); shouldWrapRight = (pos &gt;= this.minWrapRight &amp;&amp; pos &lt;= this.maxWrapRight); unWrapLeft = this.isWrap == 'left' &amp;&amp; !shouldWrapLeft &amp;&amp; (this.maxUnwrapLeft &lt;= pos &amp;&amp; this.minUnwrapLeft &gt;= pos); unWrapRight = this.isWrap == 'right' &amp;&amp; !shouldWrapRight &amp;&amp; (this.maxUnwrapRight &lt;= pos &amp;&amp; this.minUnwrapRight &gt;= pos);// if (unWrapLeft) { this._changeWrap('left', 'l'); } else if (unWrapRight) { this._changeWrap('right', 'l'); } if (this.isWrap != 'left' &amp;&amp; shouldWrapLeft) { this._changeWrap('left', 'ul'); } else if (this.isWrap != 'right' &amp;&amp; shouldWrapRight) { this._changeWrap('right', 'ul'); } } this._pos = pos; this.scroller.rbItemscrollerPos = this._pos; unitPos = this.options.usePx ? pos + 'px' : (pos / this.viewportWidth * 100) + '%' ; if (this.usesTransform) { this.scroller.style[transformProp] = (supports3dTransform) ? 'translate3d(' + unitPos + ', 0, 0)' : 'translateX(' + unitPos + ')' ; } else { this.scroller.style.left = unitPos; } this.onslide.fireWith(this); } updateCells() { var that = this; var cellSelector = ':not(.js'+ rb.nameSeparator + this.name + rb.elementSeparator + 'helper)'; if(this.options.excludeCell){ cellSelector += ':not(' + this.options.excludeCell + ')'; } this.$cells = this.$scroller.children(cellSelector); if(this.options.excludeHiddenCells){ this.$cells = this.$cells.filter(function(){ return rb.getStyles(this).display != 'none'; }); } this.calculateLayout(); rb.rAFQueue(function () { that.$scroller.prepend(that.helperElem); that.$cells.addClass(that.name + rb.elementSeparator + 'cell'); }); } _getCellWidth(element) { return $(element).outerWidth(); } calculateLayout() { if (this.options.switchedOff) { return; } if (this.cellData &amp;&amp; (!this.scroller.offsetWidth &amp;&amp; !this.scroller.offsetHeight)) { return; } this.viewportWidth = this.$scroller.width(); this._calculateCellLayout(); this._calculatePages(); this._writeLayout(); } _calculateCellLayout() { var that = this; var lastWidth = 0; this.cellData = this.$cells.map(function () { var returnWidth = lastWidth; var width = that._getCellWidth(this); lastWidth = returnWidth + width + rb.getCSSNumbers(this, ['margin-left', 'margin-right']); return {w: width, elem: this, r: lastWidth, l: returnWidth}; }).get(); this.cellData.push({l: lastWidth, w: 0, r: lastWidth, index: 'last', elem: null}); this.maxWrapRight = (lastWidth - this.viewportWidth) * -1; if(this.maxWrapRight &gt; 0){ this.maxWrapRight = 0; } } _writeLayout() { if(this.options.switchedOff){return;} var wasPos = this._pos; if(this.isWrap){ this._changeWrap(this.isWrap, this.isCarousel ? 'ul' : 'l'); } this.selectIndex(this._selectedIndex, true); if (wasPos == this._pos) { this._setPos(wasPos); this._updateControls(this._pos); } } _calculatePages() { var overScrollPos, halfViewport, roundingTolerance, i, len, absMinScroll, nextPageLeft, nextI, curPage, cellData; var scrollStep = this.options.scrollStep; var pageLength = this.pageLength; var overkillLength = 0; this.pageData = this.cellData; if (!this.$cells.length) { return; } if (scrollStep == 'auto') { scrollStep = (this.options.centerMode) ? 1 : 'view' ; } if (scrollStep.indexOf &amp;&amp; scrollStep.indexOf('cell') != -1) { scrollStep = 1; } if (this.options.carousel || !this.options.centerMode) { absMinScroll = this.maxWrapRight * -1; for (i = 0; i &lt; this.cellData.length; i++) { roundingTolerance = i + 1; if (this.cellData[i].l + roundingTolerance &gt;= absMinScroll &amp;&amp; this.cellData[i].l - roundingTolerance &lt;= absMinScroll) { this.maxWrapRight = this.cellData[i].l * -1; } } this.minWrapLeft = 0; } if (this.options.centerMode) { halfViewport = this.viewportWidth / 2; this.minScroll = halfViewport + (this.cellData[this.cellData.length - 2].l * -1) - ((this.cellData[this.cellData.length - 1].l - this.cellData[this.cellData.length - 2].l || 1) / 2); this.maxScroll = halfViewport - ((this.cellData[1].l || 1) / 2); } else { this.minScroll = this.maxWrapRight; this.maxScroll = this.minWrapLeft || 0; } overScrollPos = (this.minScroll * -1); this.pageData = []; nextPageLeft = 0; this._isPageDirty = true; for (i = 0, len = this.cellData.length - 1; i &lt; len; i++) { roundingTolerance = (i * 0.5) + 0.5; cellData = this.cellData[i]; if (!curPage || this.cellData[i + 1].l &gt;= nextPageLeft + roundingTolerance) { if (!this.options.centerMode &amp;&amp; curPage &amp;&amp; overScrollPos - roundingTolerance &lt; curPage.l) { overkillLength++; } curPage = { l: cellData.l, cells: [cellData], cellElems: [cellData.elem], i: curPage ? curPage.i + 1 : 0, }; this.pageData.push(curPage); nextPageLeft = cellData.l + this.viewportWidth; if (scrollStep != 'view') { nextI = i + scrollStep; if (nextI &gt; len) { nextI = len; } if (nextPageLeft &gt; this.cellData[nextI].l) { nextPageLeft = this.cellData[nextI].l; } } } else { curPage.cells.push(cellData); curPage.cellElems.push(cellData.elem); } curPage.r = this.cellData[i + 1].l; this.cellData[i].pageIndex = curPage.i; } this.baseIndex = 0; this.baseLength = this.pageData.length; this.carouselWidth = this.pageData[this.baseLength - 1].r; this.velUnit = Math.max(Math.min(this.carouselWidth / this.baseLength, 999), 400); this._createCarouselPages(); this.pageLength = this.baseLength - overkillLength; if (this.pageLength != pageLength) { if(pageLength != null){ this._adjustSelectedIndex(); } this._createPagination(); if (pageLength &gt; -1) { this.trigger('pagelengthchanged'); } } } _adjustSelectedIndex(){ var active = this.$cells.filter('.' + rb.statePrefix + 'active').get(0); if(active){ this._selectedIndex = this.getPageIndexOfCell(active); } else if(this.pageLength &lt; this.selectedIndex){ this.selectedIndex = this.pageLength - 1; } } _addPosCorrect(pageData, cells, pageCorrect, wrappedIndex) { var i, len, cell; for (i = 0, len = pageData.cells.length; i &lt; len; i++) { cell = pageData.cells[i]; cell.uIndex = wrappedIndex &gt; -1 ? cell.pageIndex + wrappedIndex : wrappedIndex; cell.ul = cell.l + pageCorrect; cell.ur = cell.r + pageCorrect; cells.push(cell); } return { carouselWidth: pageCorrect, ol: pageData.l, or: pageData.r, l: pageData.l + pageCorrect, r: pageData.r + pageCorrect, i: pageData.i, cells: pageData.cells, cellElems: pageData.cellElems, }; } _createCarouselPages() { var i, len, pageData, curWidth, pageCorrect, negativeIndex, lastPos; var viewport = this.viewportWidth; var wasCarousel = this.isCarousel; this.posPages = {left: [], right: []}; this.posPages.right.rbCells = []; this.posPages.left.rbCells = []; this.isCarousel = false; if(supportSomeOrder &amp;&amp; this.options.carousel &amp;&amp; this.pageData.length &gt; 1 &amp;&amp; (this.cellData[this.cellData.length - 1].l / 1.99) &gt;= this.viewportWidth){ this.isCarousel = (this.cellData[this.cellData.length - 1].l / 2.4) &gt; this.viewportWidth; if(!this.isCarousel &amp;&amp; this.cellData[0].w &gt; this.viewportWidth - 1 &amp;&amp; this.cellData[1].w &gt; this.viewportWidth - 1){ this.isCarousel = true; } } this.isCarouselChanged = wasCarousel != this.isCarousel; if (!this.isCarousel) { return; } this.maxWrapLeft = viewport; this.minWrapRight = this.maxWrapRight - viewport; pageCorrect = this.carouselWidth; for (i = 0, len = this.pageData.length; i &lt; len; i++) { pageData = this.pageData[i]; this.posPages.right.push(this._addPosCorrect(pageData, this.posPages.right.rbCells, pageCorrect, this.baseLength)); if (pageData.r &gt;= viewport) { break; } } pageCorrect *= -1; negativeIndex = 0; for (i = this.pageData.length - 1, curWidth = 0; i &gt;= 0; i--) { pageData = this.pageData[i]; curWidth += pageData.r - pageData.l; negativeIndex--; this.posPages.left.push(this._addPosCorrect(pageData, this.posPages.left.rbCells, pageCorrect, negativeIndex)); if (curWidth &gt;= viewport) { break; } } this.minUnwrapRight = viewport; lastPos = this.posPages.right[this.posPages.right.length - 1]; this.posPages.right._helperLeft = lastPos.or; this.maxUnwrapRight = (lastPos.or * -1) - viewport; lastPos = this.posPages.left[this.posPages.left.length - 1]; this.posPages.left._helperLeft = lastPos.l; this.minUnwrapLeft = (lastPos.ol * -1) + viewport; this.maxUnwrapLeft = (this.posPages.left[0].or * -1) - viewport; this.pageData.unshift.apply(this.pageData, this.posPages.left.reverse()); this.pageData.push.apply(this.pageData, this.posPages.right); this.baseIndex = this.posPages.left.length; } _createPagination() { var paginationItems, i; var baseLength = this.pageLength; var paginationItemTpl = this.interpolateName(this.options.paginationItemTpl); this.element.setAttribute('data-page-length', baseLength); this.$pageLength.html(baseLength); if (this.$pagination.length &amp;&amp; this.$paginationBtns.length != baseLength) { paginationItems = []; for (i = 0; i &lt; baseLength; i++) { paginationItems.push(paginationItemTpl.replace(regIndex, '' + (i + 1))); } this.$pagination.html(paginationItems.join('')); this.$paginationBtns = this.$pagination .find('.' + this.name + rb.elementSeparator + 'pagination' + rb.nameSeparator + 'btn') ; this.$paginationBtns.eq(this._selectedIndex).addClass(rb.statePrefix + 'selected'); } } } Component.register('itemscroller', ItemScroller); export default ItemScroller; × Search results Close "},"components_panel.js.html":{"id":"components_panel.js.html","title":"Source: components/panel.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/panel.js import rb, { Component } from '../core'; import './panelbutton'; import './_focus-component'; import '../utils/$_slide-up-down'; import '../utils/contains'; const $ = Component.$; const regInputs = /^(?:input|textarea)$/i; /** * Class component to create a panel. The visibility should be handled using CSS. The component mainly toggles the class `is-open`. * @alias rb.components.panel * @extends rb.components._focus_component * * @param element * @param initialDefaults * * @fires componentName#change Fires before a panel's `isOpen` state changes. The default behavior can be prevented. * @fires componentName#changed Fires after a panel's `isOpen` state changed. * * @property {Boolean} isOpen * * @example * &lt;button aria-controls=&quot;panel-1&quot; data-module=&quot;button&quot; type=&quot;button&quot; class=&quot;js-rb-click&quot;&gt;button&lt;/button&gt; * &lt;div id=&quot;panel-1&quot; data-module=&quot;panel&quot;&gt; * {{panelContent}} * &lt;/div&gt; * @example * rb.$('.rb-panel').rbComponent().open(); * rb.$('.rb-panel').on('panelchanged', function(){ * console.log(rb.$(this).rbComponent().isOpen); * }); */ class Panel extends rb.components._focus_component { /** * @static * @mixes rb.components._focus_component.defaults * * @property {Object} defaults * @property {String} defaults.animation='' Predefined animation: 'slide'. These should be combined with CSS transitions or animations. * @property {String} defaults.easing='' CSS Easing function for the animation. * @property {Number} defaults.duration=400 Duration of the animation. * @property {Boolean|String} defaults.setFocus=true Whether the component should set the focus on open. true: sets only focus if js-rb-autofocus is found. 'force': sets focus to panel, if no 'js-rb-autofocus' was found. * @property {Boolean} defaults.closeOnFocusout=false Similar to closeOnOutsideClick, but better from behavior. Caution behavior can be sometimes unpredictable, if multiple buttons do control the panel. * @property {Boolean} defaults.closeOnOutsideClick=false Whether the component should be closed, if clicked outside the component. * @prop {Boolean} defaults.switchedOff=false Turns off panel. * @prop {Boolean} defaults.resetSwitchedOff=true Resets panel to initial state on reset switch. * @prop {Boolean} defaults.closeOnEsc=false Whether panel should be closed on esc key. * @prop {Boolean|Number} defaults.adjustScroll=false If a panel closes and the activeElement is below the panel, the scroll position might be adjusted to hold the activeElement in view. The adjustScroll option can be combined with the 'slide' animation in a accordion component. So that closing a large panel doesn't move the opening panel out of view. Possible values: `true`, `false`, any Number but not 0. * @prop {Boolean|Number} defaults.scrollIntoView=false If a panel opens tries to scroll it into view. * @prop {String} defaults.itemWrapper='' Whether the closest itemWrapper should get the class `is-selected-within'. * @prop {Boolean|String} defaults.setDisplay=false Changes panel to display none if closed. * @prop {Number} defaults.displayTimer=5000 Sets time in ms for display setter. */ static get defaults(){ return { animation: '', // || 'slide' duration: 400, easing: '', setFocus: true, // true || false closeOnOutsideClick: false, resetSwitchedOff: true, switchedOff: false, closeOnEsc: false, closeOnFocusout: false, scrollIntoView: false, adjustScroll: false, itemWrapper: '', setDisplay: false, displayTimer: 5000, }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.isOpen = this.element.classList.contains(rb.statePrefix + 'open'); this.isDefaultOpen = this.isOpen; this._role = this.element.getAttribute('role'); this._onBodyClick = this._onBodyClick.bind(this); this._onOutSideAction = this._onOutSideAction.bind(this); rb.rAFs(this, {throttle: true}, '_opened', '_closed', '_switchOn', '_switchOff'); rb.rAFs(this, {throttle: true, that: this}, '_setDisplay'); this.setOption('easing', this.options.easing); if (!this.options.switchedOff) { this.setOption('switchedOff', false); } else { rb.rAFQueue(function () { element.classList.add(rb.statePrefix + 'switched' + rb.nameSeparator + 'off'); }, true); } } static get events(){ return { 'click .{name}{e}close': function (e) { this.close(); if (e) { e.stopPropagation(); e.preventDefault(); } }, 'keydown:keycodes(27)': function(e){ if(this.options.closeOnEsc &amp;&amp; !e.defaultPrevented){ this.close(); e.preventDefault(); e.stopPropagation(); } }, }; } _switchOff() { this.element.removeAttribute('aria-hidden'); this.element.removeAttribute('role'); this.element.removeAttribute('tabindex'); if (this.options.resetSwitchedOff) { this.isOpen = this.isDefaultOpen; } if (!this.isDefaultOpen) { this.element.classList.remove(rb.statePrefix + 'open'); } this.element.classList.add(rb.statePrefix + 'switched' + rb.nameSeparator + 'off'); this.$element.css({ visibility: '', height: '', overflow: '', display: '', }); } _switchOn() { if (this.isOpen) { this.element.classList.add(rb.statePrefix + 'open'); } this.element.classList.remove(rb.statePrefix + 'switched' + rb.nameSeparator + 'off'); this.element.setAttribute('aria-hidden', '' + (!this.isOpen)); this.$element.attr({'role': this._role || 'group', tabindex: '-1'}); } _setDisplay(){ if(!this.isOpen){ this.element.style.display = 'none'; } else if(this.element.style.display == 'none'){ this.element.style.display = typeof this.options.setDisplay == 'string' ? this.options.setDisplay : '' ; } this._displayTimer = null; } _shouldTeardown(){ if ((!this.isOpen &amp;&amp; (!this.options.closeOnOutsideClick &amp;&amp; this.options.closeOnFocusout)) || !rb.root.contains(this.element)) { this.teardownOnOpenEvts(); return true; } } _onBodyClick(e) { var that; if (this.options.closeOnOutsideClick &amp;&amp; !this._shouldTeardown() &amp;&amp; document.body.contains(e.target) &amp;&amp; !rb.contains(this.element, e.target)) { that = this; this._closeTimer = setTimeout(function () { that.close(); }, 44); } } _onOutSideAction(e){ var containers, component; if (this.options.closeOnFocusout &amp;&amp; (e.type != 'focus' || e.target.tabIndex != -1) &amp;&amp; document.body.contains(e.target) &amp;&amp; !this._shouldTeardown()) { component = this.component(e.target); if(component &amp;&amp; component.getTarget &amp;&amp; component.getTarget() == this.element){ return; } containers = [this.element]; if(this.buttonComponent){ containers.push(this.buttonComponent.element); } if(this.activeButtonComponent){ containers.push(this.activeButtonComponent.element); } if(!rb.contains(containers, e.target)){ this.close(); } } } setupOnOpenEvts() { this.teardownOnOpenEvts(); if(this.options.closeOnFocusout || this.options.closeOnOutsideClick){ document.addEventListener('click', this._onBodyClick, true); document.addEventListener('mousedown', this._onOutSideAction, true); document.addEventListener('focus', this._onOutSideAction, true); } } teardownOnOpenEvts() { clearTimeout(this._closeTimer); document.removeEventListener('click', this._onBodyClick, true); document.removeEventListener('mousedown', this._onOutSideAction, true); document.removeEventListener('focus', this._onOutSideAction, true); } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); if (name == 'easing' &amp;&amp; value &amp;&amp; typeof value == 'string') { rb.addEasing(value); } else if (name == 'switchedOff') { if (value) { this._switchOff(); } else { this._switchOn(); } } } getAnimationData(){ var animationComponent; var panel = this; var animationData = { panel: panel, options: {}, }; if (panel.options.animation) { animationComponent = this; } else if (this.options.animation !== false &amp;&amp; this.groupComponent) { animationComponent = this.groupComponent; } if(animationComponent){ animationData.component = animationComponent; animationData.options = { duration: animationComponent.options.duration, easing: animationComponent.options.easing }; animationData.animation = animationComponent.options.animation; } return animationData; } _handleAnimation(e) { var $panel; var panel = this; var animationData = {}; if (e.defaultPrevented || !e.detail || e.detail.animationPrevented) { return animationData; } animationData = this.getAnimationData(); $panel = this.$element; if (!animationData.component) { return animationData; } if(panel.groupComponent &amp;&amp; panel.groupComponent._handleAnimation){ panel.groupComponent._handleAnimation(animationData); } if(animationData.animation == 'slide'){ $panel.stop(); if (panel.isOpen) { animationData.options.getHeight = true; animationData.height = $panel.rbSlideDown(animationData.options); } else { animationData.height = 0; $panel.rbSlideUp(animationData.options); } } return animationData; } /** * Opens the panel * @param {Object} [options] Options are also dispatched with the event.detail property. * @param {Boolean} [options.animationPrevented] If `true` panel opens without animation. * @param {Boolean} [options.setFocus] Overrides the general `setFocus` option of the component instance. * @returns {boolean} * @example * //opens a panel without animation and without setting focus. * rb.$('.rb-panel').rbComponent().open({animationPrevented: true, setFocus: false}); */ open(options) { if (this.isOpen) { return false; } var setFocus; var mainOpts = this.options; var changeEvent = this.trigger(this._beforeEvtName, options); if(!options){ options = {}; } if (changeEvent.defaultPrevented) { return false; } setFocus = 'setFocus' in options ? options.setFocus : mainOpts.setFocus ; this.isOpen = true; if (this.groupComponent) { this.groupComponent.panelChangeCB(this, 'beforeopen'); } clearTimeout(this._closeTimer); if(this._displayTimer){ clearTimeout(this._displayTimer); } options.animationData = this._handleAnimation(changeEvent); if (setFocus &amp;&amp; !options.focusElement) { options.focusElement = this.getFocusElement(setFocus == 'force'); } if(options.focusElement &amp;&amp; regInputs.test(options.focusElement.nodeName)){ this._opened._rbUnrafedFn.call(this, options); } else { this._opened(options); } return true; } _getFocusDelay(actionOptions) { var mainOpts = this.options; var delay = (actionOptions &amp;&amp; actionOptions.focusDelay) || (mainOpts.animation &amp;&amp; mainOpts.duration) || (this.groupComponent &amp;&amp; this.groupComponent.options.animation &amp;&amp; this.groupComponent.options.duration) ; return delay || mainOpts.focusDelay || 0; } _opened(options) { if(!this.isOpen){return;} var delay = this._getFocusDelay(options); this.element.classList.add(rb.statePrefix + 'open'); this.element.setAttribute('aria-hidden', 'false'); if(this.options.setDisplay){ this._setDisplay(); } if(this.options.itemWrapper){ $(this.element.closest(this.interpolateName(this.options.itemWrapper))) .rbToggleState('selected{-}within', true); } if (this.groupComponent) { this.groupComponent.panelChangeCB(this, 'afteropen'); } if (options.focusElement) { this.setComponentFocus(options.focusElement, delay); } else { this.storeActiveElement(); } clearTimeout(this._closeTimer); if (this.options.closeOnOutsideClick) { this.setupOnOpenEvts(); } this.scrollIntoView(options); this.trigger(); } /** * Toogles the panel * @param {Object} [options] Options are also dispatched with the event.detail property. * @returns {boolean} * @example * rb.$('.rb-panel').rbComponent().toggle(); */ toggle(options) { return this[this.isOpen ? 'close' : 'open'](options); } /** * Closes the panel * @param {Object} [options] Options are dispatched with the event.detail property. * @param {Boolean} [options.animationPrevented] If `true` panel closes without animation. * @returns {boolean} * @example * rb.$('.rb-panel').rbComponent().close(); */ close(options) { if (!this.isOpen) { return false; } var changeEvent = this.trigger(this._beforeEvtName, options); if (changeEvent.defaultPrevented) { return false; } this.isOpen = false; if (this.groupComponent) { this.groupComponent.panelChangeCB(this, 'beforeclose'); } this.adjustScroll(); this._handleAnimation(changeEvent); this._closed(options); clearTimeout(this._closeTimer); return true; } _closed(options) { if(this.isOpen){return;} this.element.classList.remove(rb.statePrefix + 'open'); this.element.setAttribute('aria-hidden', 'true'); if(this.options.itemWrapper){ $(this.element.closest(this.interpolateName(this.options.itemWrapper))) .rbToggleState('selected{-}within', false); } if (this.groupComponent) { this.groupComponent.panelChangeCB(this, 'afterclose'); } this.trigger(); clearTimeout(this._closeTimer); if (this.options.closeOnOutsideClick) { this.teardownOnOpenEvts(); } if ((!options || options.setFocus !== false) &amp;&amp; (this.options.setFocus || (options &amp;&amp; options.setFocus))) { this.restoreFocus(true); } if(this._displayTimer){ clearTimeout(); } if(this.options.setDisplay){ this._displayTimer = setTimeout(this._setDisplay, this.options.displayTimer || 5000); } } _scroll(relPos, animationData){ var scrollingElement, scrollTop; if (relPos) { scrollingElement = rb.getPageScrollingElement(); scrollTop = Math.max(scrollingElement.scrollTop + relPos, 0); if(animationData.animation){ $(scrollingElement) .animate( { scrollTop: scrollTop, }, animationData.options ) ; } else { scrollingElement.scrollTop = scrollTop; } } } scrollIntoView(opts){ var activeElement, animationData, box, viewHeight, comparePos, elemHeight, scrollTop; var options = this.options; if(!options.scrollIntoView){return;} activeElement = document.activeElement; if(!activeElement || !activeElement.compareDocumentPosition || !(comparePos = activeElement.compareDocumentPosition(this.element)) || (comparePos != 4 &amp;&amp; comparePos != 2)){ return; } animationData = opts.animationData; box = this.element.getBoundingClientRect(); viewHeight = rb.root.clientHeight; elemHeight = animationData.height || box.height; if(comparePos == 4 &amp;&amp; box.top + elemHeight &gt; viewHeight){ scrollTop = box.top + Math.min(elemHeight, viewHeight - 9) - viewHeight; } else if(comparePos == 2 &amp;&amp; box.top &lt; 0) { scrollTop = box.top; } if(scrollTop){ if(typeof options.scrollIntoView == 'number'){ scrollTop += options.scrollIntoView; } this._scroll(scrollTop, animationData); } } adjustScroll(){ var activeElement, animationData, height; var options = this.options; var adjustScroll = options.adjustScroll; if(!adjustScroll){return;} activeElement = document.activeElement; if(!activeElement || !activeElement.compareDocumentPosition || activeElement.compareDocumentPosition(this.element) != 2){ return; } animationData = this.getAnimationData(); height = this.$element.outerHeight(); if (typeof adjustScroll == 'number') { height -= activeElement.getBoundingClientRect().top - adjustScroll; } if(height &gt; 0){ this._scroll(height * -1, animationData); } } } Component.register('panel', Panel); export default Panel; × Search results Close "},"components_popover.js.html":{"id":"components_popover.js.html","title":"Source: components/popover.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/popover.js import rb, { Component } from '../core'; import getCss from '../utils/get-css'; import './panel'; import '../utils/position'; const Position = rb.Position; /** * Creates a popover that is positioned/anchored to another element. * * A11y-Notes: If the popover has structured content use the class `js-rb-autofocus` inside of/at the popover. If it contains simple text use a aria-live=&quot;polite&quot; or an appropriate role. * * @alias rb.components.popover * * @extends rb.components.panel * * @param element * @param initialDefaults * * @example * &lt;button aria-controls=&quot;popover-1&quot; data-module=&quot;panelbutton&quot; type=&quot;button&quot; class=&quot;js-rb-click&quot;&gt;button&lt;/button&gt; * &lt;div id=&quot;popover-1&quot; data-module=&quot;popover&quot;&gt; * {{popoverContent}} * &lt;/div&gt; */ class Popover extends rb.components.panel { /** * @static * @mixes rb.components.panel.defaults * * @property {Object} defaults * @prop {Boolean} positioned=true indicates wether the panel is positioned * @prop {String} my='center bottom' Indicates the position of the panel. First x than y. Possible values for x 'left', 'center', 'right'. Possible values for y: 'top', 'middle', 'bottom'. Or numeric value: '0' indicates 'left' or 'top' and '50' 'center'/'middle' * @prop {String} at='center top' Indicates the position of the anchor element. Same possible values as 'my' * @prop {String} collision='flip' The collision handling. Possible values: 'flip', 'none'. Can be declared separatly for x and y. (i.e. 'flip none') * @prop {String} anchor='button' The anchor element to position the panel against. 'button' means the associated panelbutton module or if no associated panelbutton is found the opening button module. Accepts als string that are processed with rb.elementFromStr. * @prop {Boolean} updateOnResize=true Wether panel position should be updated on resize. * @prop {Boolean} closeOnOutsideClick=true Closes panel on outside click. * @prop {Boolean} closeOnEsc=true Closes panel on ESC keydown. * @prop {Boolean|String} setDisplay=true Changes panel option setDisplay to true. */ static get defaults(){ return { positioned: true, my: 'center bottom', at: 'center top', collision: 'flip', anchor: 'button', // 'button' || 'activeButton' || 'id' || closest(.bla) || sel(.yo) updateOnResize: true, closeOnOutsideClick: true, closeOnEsc: true, setDisplay: true, }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.reflow = rb.throttle(this._reflow, {that: this}); this.scrollRepostion = this.scrollRepostion.bind(this); if (this.options.positioned) { this.setOption('positioned', true); } } setOption(name, value, isSticky) { const options = this.options; super.setOption(name, value, isSticky); if (name == 'positioned') { if (value) { if (!this.position) { this.initPositionedElement(); } else { this.$element.css({position: 'absolute'}); } } else { this.$element.css({position: '', left: '', top: ''}); } } else if (this.position &amp;&amp; name == 'my' || name == 'at' || name == 'collision') { this.position.setOptions({ my: options.my, at: options.at, collision: options.collision, }); } } initPositionedElement() { this.position = new Position(this.element); this.$element.cssRaf({display: 'block'}); this.setOption('my', this.options.my); } _reflow(e) { if (!rb.root.contains(this.element)) { this.teardownPopoverResize(); return; } if ((!e || this.options.updateOnResize)) { this.connect(false, this.lastOpeningOptions); } } scrollRepostion(e){ if (!rb.root.contains(this.element)) { this.teardownPopoverResize(); return; } if(!e || (this.options.updateOnResize &amp;&amp; e.target.contains &amp;&amp; this.getAnchor(this.lastOpeningOptions))){ this._reflow(); } } setupPopoverResize() { this.teardownPopoverResize(); window.addEventListener('resize', this.reflow); document.addEventListener('scroll', this.scrollRepostion, true); } teardownPopoverResize() { window.removeEventListener('resize', this.reflow); document.removeEventListener('scroll', this.scrollRepostion, true); } getAnchor(options) { let anchor = options &amp;&amp; options.anchor || this.options.anchor || ''; if (anchor.nodeType != 1) { if (anchor == 'activeButton') { anchor = (this.activeButtonComponent &amp;&amp; this.activeButtonComponent.element) || (this.buttonComponent &amp;&amp; this.buttonComponent.element); } else if (Popover.mainbutton[anchor]) { anchor = (this.buttonComponent &amp;&amp; this.buttonComponent.element) || (this.activeButtonComponent &amp;&amp; this.activeButtonComponent.element); } else if (typeof anchor == 'string') { anchor = rb.elementFromStr(anchor, this.element)[0]; } } return anchor; } connect(isOpening, options) { const anchor = (isOpening || this.isOpen) &amp;&amp; this.getAnchor(options); if (anchor &amp;&amp; this.position) { this.position.connect(anchor); } } /** * Opens the popover * @param {Object} options * @param {String|Element} options.anchor Overrides anchor option of instance for current opening. * @returns {Boolean} */ open(options) { const isOpening = super.open(options); this.lastOpeningOptions = options; if (this.options.positioned) { if(getCss(this.element, 'display') == 'none'){ this.element.style.display = typeof this.options.setDisplay == 'string' ? this.options.setDisplay : 'block' ; } this.connect(isOpening, options); if (isOpening &amp;&amp; this.options.updateOnResize) { this.setupPopoverResize(); } } return isOpening; } close(_options) { const isClosing = super.close(_options); if (this.options.positioned) { if (isClosing) { this.lastOpeningOptions = null; this.teardownPopoverResize(); } } return isClosing; } } Object.assign(Popover, { mainbutton: { button: 1, mainButton: 1, panelButton: 1, }, }); Component.register('popover', Popover); export default Popover; × Search results Close "},"components_range.js.html":{"id":"components_range.js.html","title":"Source: components/range.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/range.js import rb, { Component } from '../core'; import '../utils/draggy'; const $ = Component.$; if (!rb.i18n) { rb.i18n = {}; } /** * Creates a range input control with one are more thumbs. * * @alias rb.components.range * * @extends rb.Component * @fires componentName#changed * * * @prop {Number[]} values Returns current values of the range control * @prop {$.CallbackObject} oninput * @prop {$.CallbackObject} oninput.add Adds a callback function. * @prop {$.CallbackObject} oninput.remove Removes a callback function. * * * @param element * @param initialDefaults * * @example * &lt;div class=&quot;rb-range js-rb-live&quot; data-module=&quot;range&quot; data-values=&quot;[0, 100]&quot;&gt;&lt;/div&gt; * * &lt;!-- combined with visible input --&gt; * &lt;label for=&quot;range-1&quot;&gt;range&lt;/label&gt; * &lt;input value=&quot;10&quot; min=&quot;1&quot; max=&quot;10&quot; type=&quot;number&quot; id=&quot;range-1&quot; /&gt; * &lt;div class=&quot;rb-range js-rb-live&quot; data-module=&quot;range&quot; data-inputs=&quot;range-1&quot;&gt;&lt;/div&gt; * * @example * * rb.$('.rb-range').rbComponent().oninput.add(function(index){ * console.log('value changing', this.getValues(index)); * }); * * rb.$('.rb-range').on('rangechanged', function(){ * console.log('values changed', rb.$(this).rbComponent().getValues()); * }); */ class Range extends Component { /** * @static * @mixes rb.Component.defaults * * @prop {Object} defaults * @prop {Boolean} animate Whether component should set animation class `is-animate`. Animation has to be done in CSS. * @prop {String} axis='auto' Possible values: 'auto', 'horizontal', 'vertical'. ('auto' does not work, if we are in a display none wrapper and also adds some perf penalty) * @prop {String|Boolean} inputs='find(input)' input element(s) to combine with the range. String is processed by rb.elementsFromStr. * @prop {Number|Number[]} values=50 The initial/default value(s) of the range. Only if no inputs are found. * @prop {Number|String} step=1 Stepping for the range. Also allows the string 'any'. * @prop {Number} max=100 The maximum value of the range. If an input with a `data-max` or `max` attribute is found its this value is used. * @prop {Number} min=0 The minimum value of the range. If an associated input with a `data-max` or `max` attribute is found its value is used. * @prop {null|String|String[]} titles=null The title attribute for the thumb(s). (Only if no inputs with a title is found.) * @prop {null|String|String[]} labelIds=null The labelIds for the thumb(s). To be used with aria-labelledby. (Only if no inputs with a label are found.) * @prop {null|String|String[]} labels=null The labels for the thumb(s). To be used with aria-label. (Only if no inputs with a label are found.) */ static get defaults(){ return { animate: true, axis: 'auto', inputs: 'find(input)', values: 50, step: 1, max: 100, min: 0, titles: null, labelIds: null, labels: null, }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.pos = []; this._origin = 'component'; this.oninput = $.Callbacks(); this.rAFs({batch: true}, '_setThumbValues', '_setInputValues'); this.rAFs('_setActivateClass', '_setAnimateClass', '_generateMarkup', '_updateMinMax'); this.oninput.fireWith = rb.rAF(this.oninput.fireWith); this._updateOptions = rb.throttle(function () { this.updateInputData(); this._setThumbValues(); this._updateMinMax(); }, {simple: true, delay: 0}); this._detectAxis(); this._getOptionsByInputs(); this._generateMarkup(); } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); if (name == 'max' || name == 'min' || name == 'step') { this._updateOptions(); } else if (name == 'inputs') { this._getOptionsByInputs(); this._generateMarkup(); } } /** * Returns values or values[index] * @param {Number} [index] * @returns {Number|Number[]} */ getValues(index) { return (index == null) ? this.values : this.values[index]; } /** * Set the value of a thumb (and associated input) in the range control. * @param {Number} value * @param {Number} [index=0] * @param {Boolean} [animate=false] */ setValue(value, index, animate) { if (typeof index == 'boolean') { animate = index; index = 0; } if (animate == null) { animate = this.options.animate; } index = index || 0; this._origin = 'external'; this._setValue(this.constrainMinMax(value), index, animate); this.trigger({origin: 'external', index: index}); this._origin = 'component'; } /** * Sets the value of a thumb (and associated input) to the next higher value. * @param {Number} [factor] * @param {Number} [index=0] * @param {Boolean} [animate=false] */ stepUp(factor, index, animate) { if (typeof index == 'boolean') { animate = index; index = 0; } if (!index) { index = 0; } this._origin = 'external'; this._doStep(factor, index, animate); this.trigger({origin: 'external', index: index}); this._origin = 'component'; } /** * Sets the value of a thumb (and associated input) to the next lower value. * @param {Number} [factor] * @param {Number} [index=0] * @param {Boolean} [animate=false] */ stepDown(factor, index, animate) { if (!factor) { factor = 1; } this.stepUp(factor * -1, index, animate); } /** * Parses a string to a number. Use `rb.i18n.parseNumber`, if available. Can be overridden. * @param {String|Number} number * @returns {Number} */ parseNumber(string) { if (typeof string != 'number') { if (rb.i18n.formatNumber) { string = rb.i18n.parseNumber.apply(rb.i18n, arguments); } else { string = parseFloat(string); } } return string; } /** * Formats a number to a string. Use `rb.i18n.formatNumber`, if available. Can be overridden. * @param {String|Number} number * @returns {Number} */ formatNumber(number) { if (rb.i18n.formatNumber) { number = rb.i18n.formatNumber.apply(rb.i18n, arguments); } else if (typeof number != 'string') { number = number + ''; } return number; } constrainMinMax(value) { let valModStep, alignValue; const step = this.options.step; if (value &gt; this.max) { value = this.max; } else if (value &lt; this.min) { value = this.min; } else if (this.options.step != 'any') { valModStep = (value - this.min) % step; alignValue = value - valModStep; if (Math.abs(valModStep) * 2 &gt;= step) { alignValue += ( valModStep &gt; 0 ) ? step : ( -step ); } value = ((alignValue).toFixed(5)) * 1; } return value; } posToValue(pos) { let value = ((this.max - this.min) * (pos / 100)) + this.min; value = this.constrainMinMax(value); return value; } valueToPos(value) { let pos; value = this.constrainMinMax(this.parseNumber(value)); pos = 100 * ((value - this.min) / (this.max - this.min)); return pos; } updateInputData() { const options = this.options; this.max = null; this.min = null; this.step = null; if (this.inputs.length) { this._parseInputsProperties(); } if (this.max == null) { this.max = options.max; } if (this.min == null) { this.min = options.min; } if (this.step == null) { this.step = options.min; } if (!this.values.length) { this.values = Range.makeArray(options.values); } this._clacSteps(); } _generateMarkup() { let $progress, list, tmp; const that = this; const $rail = $(document.createElement('span')); const namePrefix = this.name + rb.elementSeparator; const progressClass = namePrefix + 'progress'; const thumbClass = namePrefix + 'thumb'; const tooltipClass = namePrefix + 'tooltip'; const tooltipValueClass = tooltipClass + rb.nameSeparator + 'value'; const trackClass = namePrefix + 'track'; let handles = '&lt;span class=&quot;' + thumbClass + '&quot; role=&quot;slider&quot; tabindex=&quot;0&quot;&gt;' + '&lt;span class=&quot;' + tooltipClass + '&quot;&gt; ' + '&lt;span class=&quot;' + tooltipValueClass + '&quot;&gt;&lt;/span&gt;' + '&lt;/span&gt;' + '&lt;/span&gt;' ; tmp = '&lt;span class=&quot;' + progressClass + ' ' + progressClass + '-min&quot;&gt;&lt;/span&gt;'; if (this.values.length &gt; 1) { tmp += '&lt;span class=&quot;' + progressClass + ' ' + progressClass + '-max&quot;&gt;&lt;/span&gt;'; } handles = tmp + handles.repeat(this.values.length); $rail.prop({ className: namePrefix + 'rail', innerHTML: '&lt;span class=&quot;' + trackClass + '&quot;&gt;' + handles + '&lt;/span&gt;', }); this.track = $rail.find('.' + trackClass).get(0); this.thumbs = $rail.find('.' + thumbClass).get(); this.tooltips = $rail.find('.' + tooltipValueClass).get(); $progress = $rail.find('.' + progressClass); this.progressMin = $progress.get(0); this.progressMax = $progress.get(1); if (this.thumbs.length &gt; 1) { this.thumbs[0].setAttribute('aria-controls', this.getId(this.thumbs[1])); this.thumbs[this.thumbs.length - 1].setAttribute('aria-controls', this.getId(this.thumbs[this.thumbs.length - 2])); } this._setupEvents(); this._setThumbValues(); this._updateMinMax(); list = that.element.querySelector(that.name + rb.elementSeparator + 'list'); if (list) { that.track.appendChild(list); } this._addLabelTitles(); that.$element.append($rail.get(0)); } _addLabelTitles() { const that = this; const options = this.options; const titles = Range.makeArray(options.titles); const labelIds = Range.makeArray(options.labelIds); const labels = Range.makeArray(options.labels); if (this.inputs.length &amp;&amp; !titles.length &amp;&amp; !labelIds.length &amp;&amp; !labels.length) { this.inputs.forEach(function (input) { const title = input.title; let id = ''; let elem = input.labels &amp;&amp; input.labels[0]; if (!('labels' in input) &amp;&amp; input.id) { elem = document.querySelector('label[for=&quot;' + input.id + '&quot;]'); } if (elem) { id = that.getId(elem); } titles.push(title); labelIds.push(id); }); } this.thumbs.forEach(function (thumb, index) { if (titles[index]) { thumb.title = titles[index]; } if (labels[index]) { thumb.setAttribute('aria-label', labels[index]); } if (labelIds[index]) { thumb.setAttribute('aria-labelledby', labelIds[index]); } }); } _detectAxis() { this.axis = this.options.axis; if (this.axis == 'auto') { this.axis = 'horizontal'; if (this.element.offsetHeight - 9 &gt; this.element.offsetWidth) { this.axis = 'vertical'; } } this.props = Range[this.axis]; if (!this.props) { this.log('unknown axis: ' + this.axis, this); } } _getOptionsByInputs() { var inputOpts = this.options.inputs; this.inputs = []; this.values = []; if (inputOpts) { this.inputs = rb.elementFromStr(inputOpts, this.element); } this.updateInputData(); } _updateMinMax() { $(this.thumbs).attr({ 'aria-valuemax': this.max, 'aria-valuemin': this.min, }); } _setActivateClass() { this.element.classList[this.isActivated ? 'add' : 'remove'](rb.statePrefix + 'active'); } _activate(index) { if (!this.isActivated) { this.isActivated = true; if (index != null) { $(this.thumbs[index]).stop(); } this._setActivateClass(); } } _deactivate(index) { if (this.isActivated) { this.isActivated = false; this._setActivateClass(); this.trigger({origin: 'component', index: index}); } } _setAnimateClass() { this.element.classList[this.isAnimated ? 'add' : 'remove'](rb.statePrefix + 'animate'); } _setAnimate(animate) { animate = !!animate; if (animate != this.isAnimated) { this.isAnimated = animate; this._setAnimateClass(); } } _getNearestThumb(pos) { return Range.getNearestIndex(pos, this.pos); } _setupEvents() { let outerBox, notMoved, index; const that = this; this.$element.draggy('destroy'); this.$element .draggy({ vertical: this.axis == 'vertical', horizontal: this.axis == 'horizontal', start: function (draggy) { let pos; notMoved = true; outerBox = that.track.getBoundingClientRect(); //y pos = (draggy.curPos[that.props.viewPos] - outerBox[that.props.pos]) / outerBox[that.props.dim] * 100; if (that.axis == 'vertical') { pos *= -1; } index = that._getNearestThumb(pos); that._setValue(that.posToValue(pos), index, that.options.animate); that.setFocus(that.thumbs[index]); that._activate(index); }, move: function (draggy) { var pos = (draggy.curPos[that.props.viewPos] - outerBox[that.props.pos]) / outerBox[that.props.dim] * 100; if (that.axis == 'vertical') { pos *= -1; } if (notMoved) { $(that.thumbs[index]).stop(); notMoved = false; } that._setValue(that.posToValue(pos), index); }, end: function () { that._deactivate(index); }, }) ; $(this.inputs).each(function (index, input) { const change = rb.throttle(function () { const value = that.parseNumber(input.value); if (!isNaN(value)) { that._setValue(that.constrainMinMax(value), index, that.options.animate); } }, {delay: 99, simple: true}); $(input).on('change', change).on('input', change); }); $(this.thumbs).each(function (index, thumb) { $(thumb) .on('keyup', function () { that._deactivate(index); }) .on('keydown', function (e) { let step, value; const code = e.keyCode; if (code == 39 || code == 38) { step = that.defaultStep; } else if (code == 37 || code == 40) { step = that.defaultStep * -1; } else if (code == 33) { step = that.largeStep; } else if (code == 34) { step = that.largeStep * -1; } else if (code == 36) { value = that.min; } else if (code == 35) { value = that.max; } if (step != null || value != null) { e.preventDefault(); that._activate(index); if (step != null) { that._doStep(step, index); } else { that._setValue(value, index); } } }) ; }); } _handleInputProperties(input) { let max = input.getAttribute('data-max') || input.getAttribute('max'); let min = input.getAttribute('data-min') || input.getAttribute('min'); const value = this.parseNumber(input.value); const step = this.step == null &amp;&amp; (input.getAttribute('data-step') || input.getAttribute('step')); if (max) { max = parseFloat(max); if (this.max == null || max &gt; this.max) { this.max = max; } } if (min) { min = parseFloat(min); if (this.min == null || min &lt; this.min) { this.min = min; } } if (step) { this.step = step; } return value; } _parseInputsProperties() { this.values = this.inputs.map(this._handleInputProperties, this); } _doStep(factor, index, animate) { if (!factor) { factor = 1; } this._setValue(this.constrainMinMax(this.getValues(index) + (this.defaultStepping * factor)), index, animate); } _setValue(value, index, animate) { let changed, beforeValue, afterValue; if (index == null) { index = 0; } if (this.values[index] !== value) { changed = true; beforeValue = this.values[index - 1]; afterValue = this.values[index + 1]; if (beforeValue != null &amp;&amp; beforeValue &gt; value) { this._setValue(value, index - 1, animate); } else if (afterValue != null &amp;&amp; afterValue &lt; value) { this._setValue(value, index + 1, animate); } this.values[index] = value; } if (changed) { this._setAnimate(animate); this._setThumbValues(index); this._setInputValues(index); this.oninput.fireWith(this, [index, this._origin]); } } _clacSteps() { const range = this.max - this.min; this.defaultStep = 1; this.defaultStepping = (this.options.step == 'any') ? Math.min(1, range / 100) : this.options.step; this.largeStep = Math.max(this.defaultStep * 2, range / this.defaultStep / 10); } _setThumbValue(thumb, index) { const value = this.values[index]; const pos = this.valueToPos(value); const formatted = this.formatNumber(value); this.pos[index] = pos; thumb.style[this.props.pos] = pos + '%'; thumb.setAttribute('aria-valuenow', value); thumb.setAttribute('aria-valuetext', this.formatNumber(value)); this.tooltips[index].setAttribute('data-value', formatted); if (index === 0) { this.progressMin.style[this.props.dim] = pos + '%'; } else if (index == this.thumbs.length - 1 &amp;&amp; this.progressMax) { this.progressMax.style[this.props.dim] = (100 - pos) + '%'; } } _setThumbValues(index) { if (index == null) { this.thumbs.forEach(this._setThumbValue, this); } else if (this.thumbs[index]) { this._setThumbValue(this.thumbs[index], index); } } _setInputValue(input, index) { let value = this.values[index]; value = input.type == 'text' ? this.formatNumber(this.values[index]) : value ; if (value != input.value) { input.value = value; } } _setInputValues(index) { if (index == null) { this.inputs.forEach(this._setInputValue, this); } else if (this.inputs[index]) { this._setInputValue(this.inputs[index], index); } } } Object.assign(Range, { horizontal: { pos: 'left', dim: 'width', viewPos: 'x', mousePos: 'clientX', }, vertical: { pos: 'bottom', dim: 'height', viewPos: 'y', mousePos: 'clientY', }, getNearestIndex: function (pos, array) { let i, len, cur, tmp; let index = -1; for (i = 0, len = array.length; i &lt; len; i++) { tmp = Math.abs(pos - array[i]); if (!cur || cur &gt; tmp) { index = i; cur = tmp; } } return index; }, makeArray: function (array) { if (!Array.isArray(array)) { array = array != null ? [array] : []; } return array; }, }); Component.register('range', Range); export default Range; × Search results Close "},"components_scrolly.js.html":{"id":"components_scrolly.js.html","title":"Source: components/scrolly.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/scrolly.js import rb, { Component } from '../core'; const $ = Component.$; const docElem = rb.root; /** * Adds a class `is-in-scrollrange` if component is inside of a defined viewport range. Additionally can animate child elements based on this range progress. * * @alias rb.components.scrolly * * @param element * @param initialDefaults * * @extends rb.components._childfx * * @example * &lt;style type=&quot;sass&quot;&gt; * .rb-logos { * (at)include rb-js-export(( * from: '-50eh', * to: '100vh - 50eh', * once: true, * throttleDelay: 300, * )); * * .logo { * opacity: 0; * transition: all 400ms; * } * * &amp;.is-in-scrollrange { * .logo { * opacity: 1; * } * } * } * &lt;/style&gt; * * &lt;div class=&quot;rb-logos js-rb-live&quot; data-module=&quot;scrolly&quot;&gt; * &lt;img class=&quot;logo&quot; src=&quot;...&quot; /&gt; * &lt;/div&gt; * * @example * &lt;style type=&quot;scss&quot;&gt; * .rb-logo { * (at)include rb-js-export(( * from: &quot;-50eh&quot;, * to: &quot;100vh - 50eh&quot;, * once: true, * throttleDelay: 100, * childSel: 'find(.logo-item)', * )); * * .logo-item { * top: 0; * transition: all 50ms; * * (at)include rb-js-export(( * top: 50, * //complicated values like transform/backgroundColor... * transform: ( * start: &quot;rotate(0deg)&quot;, * value: &quot;rotate(10deg)&quot;, * ) * )); * } * } * &lt;/style&gt; * * &lt;div class=&quot;rb-logos js-rb-live&quot; data-module=&quot;scrolly&quot;&gt; * &lt;img class=&quot;logo&quot; src=&quot;...&quot; /&gt; * &lt;/div&gt; * */ class Scrolly extends (rb.components._childfx || Component) { /** * @mixes rb.components._childfx.defaults * * @prop {{}} defaults * * @prop {String} from='-100eh' Start point of in range position relative to viewport top. Can be a simple calculation (addition and subtraction) with the following units (vh = viewport height / 100, vw = viewport width / 100, eh = element height / 100, ew = element width / 100, px). See also 'to'. * @prop {String} to='100vh' End point of in range position relative to viewport top. Example: '100vh' places the top of the element at the bottom of the viewport. '100vh - 20eh' Means 20% of the elements top is visible at the bottom of the viewport. * @prop {Boolean|String} once=false Possible values: true, false, 'entered'. Whether the component should destroy itself after it was executed once. * @prop {String} switchedOff=false Switches the component off. * @prop {Boolean} restSwitchedOff=true Whether there should be a full reset after switchedOff option change. * @prop {Number} throttleDelay=0 Delay in ms to check for position change. Setting this to a higher number (50-300) can improve performance. * @prop {String} defaults.childSel='find(.{name}-element)' Child elements that should be animated. String is processed by rb.elementFromStr. * @prop {String|Boolean} defaults.scrollContainer=false Defines a scrollcontainer, if different from html. */ static get defaults(){ return { switchedOff: false, from: '-100eh', to: '100vh', once: false, restSwitchedOff: true, throttleDelay: 0, fixedSel: 'find(.{name}{e}scrollfixed)', setFixedWidth: true, preparePadding: 0, scrollContainer: false, }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.minScroll = Number.MAX_VALUE; this.maxScroll = -1; this.checkTime = 4000 + (999 * Math.random()); this.entered = false; this.onprogress = $.Callbacks(); this.updateChilds = this.updateChilds || $.noop; rb.rAFs(this, {throttle: true}, 'changeState', 'setSwitchedOffClass', 'updateScrollFixedElement', 'changePrepareState'); rb.rAFs(this.onprogress, 'fireWith'); this.checkPosition = this.checkPosition.bind(this); this.calculateLayout = this.calculateLayout.bind(this); this._setupThrottleDelay(this.options.throttleDelay); this.reflow = rb.throttle(function () { if (this.checkChildReflow) { this.checkChildReflow(); } this.calculateLayout(); }, {that: this}); this._setScrollinElement(); this.parseOffsets(); this.calculateLayout(); if(this.options.switchedOff){ this.setSwitchedOffClass(); } } _setupThrottleDelay(delay) { if (delay &amp;&amp; delay &gt; 30) { this.throtteldCheckPosition = rb.throttle(this.checkPosition, {delay: delay}); } else { this.throtteldCheckPosition = this.checkPosition; } } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); if (name == 'switchedOff' || name == 'restSwitchedOff' &amp;&amp; this.options.switchedOff &amp;&amp; this.options.restSwitchedOff) { this.changeState(false); this.updateChilds(true); this.progress = -2; } else if (name == 'from' || name == 'to' || (name == 'switchedOff' &amp;&amp; !value)) { this.parseOffsets(); this.calculateLayout(); } else if (name == 'throttleDelay') { this.detached(); this._setupThrottleDelay(value); if (rb.root.contains(this.element)) { this.attached(); } } else if(name == 'scrollContainer'){ this._setScrollinElement(); this.calculateLayout(); } if(name == 'switchedOff'){ this.setSwitchedOffClass(); } } setSwitchedOffClass(){ this.element.classList[this.options.switchedOff ? 'add' : 'remove'](rb.statePrefix + 'switched' + rb.nameSeparator + 'off'); } parseOffsets() { this.parsedFrom = this.parseOffset(this.options.from); this.parsedTo = this.parseOffset(this.options.to); } parseOffset(val) { let prop; val = ('' + val).replace(Scrolly.regWhite, ''); let match = Scrolly.regCalc.exec(val); const parsedPos = {}; while (match != null) { prop = Scrolly.knownUnits[match[3]] ? match[3] : 'px'; parsedPos[prop] = parseFloat(match[2]); match = Scrolly.regCalc.exec(val); } return parsedPos; } addOffset(offset) { let prop, element, dimProp; let value = 0; for (prop in offset) { if (prop == 'eh' || prop == 'ev') { element = this.element; } else if (prop == 'vw' || prop == 'vh') { element = docElem; } if (element) { dimProp = prop.charAt(1) == 'w' ? 'clientWidth' : 'clientHeight' ; value += element[dimProp] / 100 * offset[prop]; } else { value += offset[prop]; } } return value; } calculateLayout() { if (this.options.switchedOff) { return; } const box = this.element.getBoundingClientRect(); this.lastCheck = Date.now(); if (!box.top &amp;&amp; !box.bottom &amp;&amp; !box.right &amp;&amp; !box.left) { return; } this.boxTop = box.top + this.scrollingElement.scrollTop; this.boxWidth = box.width; this.scrollPos = this.scrollingElement.scrollTop; this.minScroll = this.boxTop; this.maxScroll = this.minScroll; this.minScroll -= this.addOffset(this.parsedTo); this.maxScroll -= this.addOffset(this.parsedFrom); this.minFixed = this.minScroll - 666; this.maxFixed = this.maxScroll + 666; this.minPrepareScroll = this.minScroll - this.options.preparePadding; this.maxPrepareScroll = this.maxScroll + this.options.preparePadding; this.scrollFixedElement = this.getElementsByString(this.options.fixedSel)[0]; this.checkPosition(); } checkPosition() { let that, wasProgress, shouldEnter, shouldEnterScrollFix, prepareEntered, progress; if (this.options.switchedOff) { return; } const pos = this.scrollingElement.scrollTop; this.scrollPos = pos; if (Date.now() - this.lastCheck &gt; this.checkTime) { this.lastCheck = Date.now(); rb.rIC(this.calculateLayout); } shouldEnterScrollFix = this.minFixed &lt;= pos &amp;&amp; this.maxFixed &gt;= pos; prepareEntered = this.minPrepareScroll &lt;= pos &amp;&amp; this.maxPrepareScroll &gt;= pos; shouldEnter = prepareEntered &amp;&amp; shouldEnterScrollFix &amp;&amp; this.minScroll &lt;= pos &amp;&amp; this.maxScroll &gt;= pos; if (shouldEnter || (this.progress !== 0 &amp;&amp; this.progress !== 1)) { progress = Math.max(Math.min((pos - this.minScroll) / (this.maxScroll - this.minScroll), 1), 0); wasProgress = this.progress; this.progress = progress; if (wasProgress == progress || (wasProgress == -2 &amp;&amp; !progress)) { return; } this.updateChilds(); this.onprogress.fireWith(this, [progress]); if (this.options.once === true &amp;&amp; this.progress === 1) { that = this; shouldEnter = true; rb.rAFQueue(function () { that.destroy(); }, true); } } if(this.scrollFixedElement &amp;&amp; (shouldEnterScrollFix || shouldEnterScrollFix != this.enteredFixed)){ this.updateScrollFixedElement(shouldEnterScrollFix); } if(this.prepareEntered != prepareEntered){ this.prepareEntered = prepareEntered; this.changePrepareState(); } if (this.entered != shouldEnter) { this.changeState(shouldEnter); } } updateScrollFixedElement(isEntered){ const elemStyle = this.scrollFixedElement.style; if(this.enteredFixed != isEntered){ this.scrollFixedElement.classList.toggle(rb.statePrefix + 'fixed-entered', isEntered); if(isEntered){ elemStyle.position = 'fixed'; } } if(isEntered){ elemStyle.top = this.boxTop - this.scrollPos + 'px'; if(this.options.setFixedWidth &amp;&amp; this.boxWidth != this.setBoxWidth){ this.setBoxWidth = this.boxWidth; elemStyle.width = this.boxWidth + 'px'; } } else { elemStyle.position = ''; elemStyle.top = ''; if(this.options.setFixedWidth){ this.setBoxWidth = ''; elemStyle.width = ''; } } this.enteredFixed = isEntered; } changePrepareState(){ this.element.classList.toggle(rb.statePrefix + 'scrollrange' + rb.nameSeparator + 'prepared', this.prepareEntered); } changeState(shouldEnter) { const once = this.options.once; if (this.entered != shouldEnter) { this.entered = shouldEnter; this.element.classList[shouldEnter ? 'add' : 'remove'](rb.statePrefix + 'in' + rb.nameSeparator + 'scrollrange'); this.trigger(); if (once == 'entered' || (once &amp;&amp; (!this.childs || !this.childs.length))) { this.destroy(); } } } _setScrollinElement(){ const oldScrollingEvtElement = this.scrollingEvtElement; if(this.options.scrollContainer){ this.scrollingElement = this.element.closest(this.options.scrollContainer); } if(!this.scrollingElement || !this.options.scrollContainer){ this.scrollingElement = rb.getPageScrollingElement(); } this.scrollingEvtElement = (this.scrollingElement.matches('html, body')) ? window : this.scrollingElement ; if(oldScrollingEvtElement){ oldScrollingEvtElement.removeEventListener('scroll', this.throtteldCheckPosition); } this.scrollingEvtElement.addEventListener('scroll', this.throtteldCheckPosition); } attached() { this.detached(); this._setScrollinElement(); rb.resize.on(this.reflow); clearInterval(this.layoutInterval); this.layoutInterval = setInterval(this.reflow, Math.round(9999 + (5000 * Math.random()))); } detached() { if(this.scrollingEvtElement){ this.scrollingEvtElement.removeEventListener('scroll', this.throtteldCheckPosition); } rb.resize.off(this.reflow); clearInterval(this.layoutInterval); } } Object.assign(Scrolly, { regWhite: /\\s/g, regCalc: /(([+-]*\\d+[.\\d]*)(px|vh|eh|vw|ew))/g, knownUnits: {vh: 1, eh: 1, vw: 1, ew: 1}, }); Component.register('scrolly', Scrolly); export default Scrolly; × Search results Close "},"components_shrinknav.js.html":{"id":"components_shrinknav.js.html","title":"Source: components/shrinknav.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/shrinknav.js import rb, { Component } from '../core'; import '../utils/resize'; const regPoint = /^./; const $ = Component.$; /** * Class component to create a ShrinkNav. * * @alias rb.components.shrinknav * * @extends rb.Component * * @param element {Element} * @param [initialDefaults] {OptionsObject} * * @fires componentName#changed * * @example * &lt;div class=&quot;js-rb-live&quot; data-module=&quot;shrinknav&quot;&gt;&lt;/div&gt; */ class ShrinkNav extends Component { /** * @static * @mixes rb.Component.defaults * * @prop {String} measureElement='self' The element that is used to measure the full width. Either self or a selector. * @prop {String} items='.children(.{name}{e}item)' The items which may be overflowed. * @prop {String} toggleItemSelector='.{name}{e}toggle{-}item' The items which may be overflowed. * @prop {Number} minItems=2 The minimum items to see in the main bar. * @prop {Number} minSubItems=2 The minimum items to see in the submenu. * @prop {Boolean} growItems=false */ static get defaults() { return { measureElement: 'self', items: '.children(.{name}{e}item)', toggleItemSelector: '.is{-}toggle{-}item', togglePanel: 'find(.{name}{e}panel)', minItems: 2, minSubItems: 2, growItems: false, }; } static get events(){ return { 'rb_resize': 'measureElements', }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.rAFs('addItemsTo'); this.reflow = rb.throttle(this.measureElements); this._getMeasureElement(); this._getItems(); this._calcMinItems(); this.measureElements(); } setOption(name, value, isSticky){ super.setOption(name, value, isSticky); if(name == 'measureElement'){ this._getMeasureElement(); this.reflow(); } else if(name == 'minSubItems' || name == 'minItems'){ this._calcMinItems(); this.reflow(); } } _switchOff(){ } _switchOn(){ } _calcMinItems(){ const fullLength = this.allItems.length; const {minSubItems, minItems} = this.options; const needItems = minSubItems + minItems; if(needItems &gt; fullLength){ if(minItems &lt; fullLength){ this.minSubItems = fullLength - minItems; } else { this.minItems = 0; this.minSubItems = 0; } } else { this.minItems = minItems; this.minSubItems = minSubItems ; } if(this.minItems &lt; 2){ this.minItems = 0; } if(this.minSubItems &lt; 2){ this.minSubItems = 0; } } hideItems(){ const hideItems = []; let currentMenuLength = this.panelmenuItems.length; let currentVisibleLength = this.mainbarItems.length; this.mainbarItems.forEach((item)=&gt;{ if(this.remainingWidth &lt; 0 || currentMenuLength &lt; this.minSubItems || currentVisibleLength &lt; this.minItems ){ hideItems.push(item); currentVisibleLength--; currentMenuLength++; } this.remainingWidth += item.width; }); this.addItemsTo(hideItems); } showElements(){ let run = true; const changeItems = []; const lastIndex = this.panelmenuItems.length - 1; let currentMenuLength = this.panelmenuItems.length; let currentVisibleLength = this.mainbarItems.length; this.panelmenuItems.forEach((item, index) =&gt; { if(run){ if(index == lastIndex){ this.remainingWidth += this.toggleItemWidth; } if(this.remainingWidth &gt; item.width){ changeItems.push(item); currentVisibleLength++; currentMenuLength--; this.remainingWidth -= item.width; } else { run = false; } } }); if(currentMenuLength){ while(changeItems.length &amp;&amp; currentMenuLength &lt; this.minSubItems){ changeItems.pop(); currentVisibleLength--; currentMenuLength++; } if(currentVisibleLength &lt; this.minItems){ return; } } if(changeItems.length){ this.addItemsTo(changeItems, true); } } addItemsTo(items, isVisibleBar){ const hadSubmenu = !!this.panelmenuItems.length; if(isVisibleBar){ items.forEach(this.addItemToBar, this); } else { items.forEach(this.addItemToPanel, this); } const hasMenus = !!this.panelmenuItems.length; if(this.hasSubmenu !== hasMenus){ this.hasSubmenu = hasMenus; this.$element.rbToggleState('submenu-within', hasMenus); } this.trigger({hadSubmenu, changedItems: items, setToBar: !!isVisibleBar}); } addItemToBar(item){ const index = this.panelmenuItems.indexOf(item); let setElement = false; let position = item.position - 1; while(position &gt;= 0 &amp;&amp; !setElement){ const posItem = this.allItems[position]; if(posItem &amp;&amp; posItem.parent == posItem.$item.parent().get(0)){ posItem.$item.after(item.$item); setElement = true; break; } position--; } if(!setElement){ $(item.parent).prepend(item.$item); } if(index != -1){ this.panelmenuItems.splice(index, 1); this.mainbarItems.unshift(item); } } addItemToPanel(item){ const index = this.mainbarItems.indexOf(item); this.$submenu.prepend(item.$item); if(index != -1){ this.mainbarItems.splice(index, 1); this.panelmenuItems.unshift(item); } } measureElements(){ const add = this.options.growItems ? -0.1 : 0.1; const {panelmenuItems} = this; this.innerWidth = this.$measureElement.innerWidth(); this.neededWidth = this.mainbarItems.reduce((value, item) =&gt; { item.width = item.$item.outerWidth() + add; return value + item.width; }, 0); this.toggleItemWidth = this.$toggleItem.outerWidth() || this.toggleItemWidth || 0; this.remainingWidth = this.innerWidth - this.neededWidth - this.toggleItemWidth; if(this.remainingWidth &lt; (panelmenuItems.length ? 0 : -this.toggleItemWidth) + 0.1){ this.hideItems(); } else if(this.panelmenuItems.length) { const itemWidth = panelmenuItems.length == 1 ? panelmenuItems[0].width - this.toggleItemWidth : panelmenuItems[0].width ; if(this.remainingWidth &gt; itemWidth + 0.1){ this.showElements(); } } } _getItems(){ const {items, toggleItemSelector, togglePanel} = this.options; const toggleItem = this.query(toggleItemSelector); this.$submenu = $(this.getElementsByString(togglePanel)[0]); this.$toggleItem = $(toggleItem); this.allItems = this.getElementsByString(items) .filter(item =&gt; item != toggleItem) .map((item, position)=&gt; ({ $item: $(item), width: 0, position, parent: item.parentNode, priority: (parseInt(item.getAttribute('data-priority'), 10) || 0), })) ; if(!this.$submenu.is('ul, ol') &amp;&amp; (this.allItems[0] &amp;&amp; this.allItems[0].$item.is('li'))){ const $menuWrapper = this.$submenu; this.$submenu = $(document.createElement('ul')); this.$submenu.prop({className: this.interpolateName(`${togglePanel.replace(regPoint, '')}{-}list`)}); $menuWrapper.appendRaf(this.$submenu); } this.mainbarItems = [...this.allItems]; this.mainbarItems .sort( (item1, item2) =&gt; (item2.priority - item1.priority) ) ; this.mainbarItems.reverse(); this.panelmenuItems = []; } _getMeasureElement(){ const {measureElement} = this.options; this.$measureElement = measureElement == 'self' ? this.$element : this.$element.closest(measureElement) ; } } Component.register('shrinknav', ShrinkNav); export default ShrinkNav; × Search results Close "},"components_sticky.js.html":{"id":"components_sticky.js.html","title":"Source: components/sticky.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/sticky.js import rb, { Component } from '../core'; import getCss from '../utils/get-css'; const $ = Component.$; const isContainerScroll = {scroll: 1, auto: 1}; const isContainerAncestor = {parent: 'parentNode', positionedParent: 'offsetParent'}; const docElem = document.documentElement; if (!rb.components._childfx) { rb.log('_childfx not included'); } /** * Component creates a sticky element, that can be stuck to the top or the bottom of the viewport. Optionally can animate child elements after it has become stuck according to the scroll position. * * @alias rb.components.sticky * * @extends rb.components._childfx * * @param element * @param initialDefaults * * * * @example * &lt;header class=&quot;rb-header js-rb-live&quot; data-module=&quot;sticky&quot;&gt; * &lt;div class=&quot;header-fx&quot;&gt; * &lt;img class=&quot;logo&quot; /&gt; * &lt;nav&gt;&lt;!-- ... --&gt;&lt;/nav&gt; * &lt;/div&gt; * &lt;/header&gt; * * &lt;style type=&quot;text/scss&quot;&gt; * .rb-header { * (at)include rb-js-export(( * container: false, * progress: 100, * childSel: 'find(.header-fx)', * )); * * .header-fx { * padding: 20px; * font-size: 16px; * * (at)include rb-js-export(( * fontSize: 12, * paddingTop: 10, * paddingBottom: 10 * )); * } * * .logo, * nav { * height: 1em; * } * } * &lt;/style&gt; */ class Sticky extends (rb.components._childfx || Component) { /** * @mixes rb.components._childfx.defaults * * @prop {String|Boolean} container=&quot;.is{-}{name}{-}parent&quot; The container element, that is used to calculate the bounds in which the element should be sticky to the viewport. If `false` its always sticky. Possible values: `false`, `&quot;parent&quot;`(direct parent element), `&quot;positionedParent&quot;`, `&quot;.closest-selector&quot;`. * @prop {Boolean|Number} topOffset=false If a number/string it sets sticky offset to the number. * @prop {Boolean|Number} bottomOffset=false If a number/string it sets sticky offset to the number. * @prop {String} offsetElements=&quot;&quot; The height of these elements will be added to the calculated top or bottom offset. The elements are retrieved by `this.getElementsByString`. * @prop {String} marginBottomElements=&quot;&quot; The height of these elements will be added to the calculated top or bottom offset. The elements are retrieved by `this.getElementsByString`. * @prop {Number} progress=0 Defines the distance in pixel a child animation should be added after an animation should be added. * @prop {Boolean} setWidth=true Whether the width of the sticky element should be set, while it is stuck. * @prop {Boolean} switchedOff=false Turns off the stickyness. (to be used in responsive context). * @prop {Boolean} resetSwitchedOff=true Whether a switchedOff change fully resets the styles. * @prop {Boolean} autoThrottle=true Tries to throttle layout reads if current scroll position is far away from a changing point. * @prop {String} scrollContainer='' */ static get defaults(){ return { container: '.is{-}{name}{-}parent', // false || 'parent' || 'positionedParent' || '.selector' switchedOff: false, topOffset: false, bottomOffset: false, offsetElements: '', progress: 0, setWidth: true, resetSwitchedOff: true, autoThrottle: true, scrollContainer: '', }; } static filterPos(pos) { return pos != null &amp;&amp; pos &gt; -1 &amp;&amp; pos &lt; Number.MAX_VALUE; } constructor(element, initialDefaults){ super(element, initialDefaults); this.isFixed = false; this.isScrollFixed = false; this.checkTime = 666 + (666 * Math.random()); this.isProgressDone = false; this.onprogress = $.Callbacks(); this._throttleOptions = {that: this, unthrottle: true}; this.updateChilds = this.updateChilds || $.noop; this.onprogress.fireWith = rb.rAF(this.onprogress.fireWith, {throttle: true}); rb.rAFs(this, {throttle: true}, 'updateLayout', '_setProgressClass', 'setSwitchedOffClass'); this.calculateLayout = this.calculateLayout.bind(this); this.checkPosition = rb.throttle(this.checkPosition, this._throttleOptions); this.reflow = rb.throttle(function () { if (this.checkChildReflow) { this.checkChildReflow(); } this.calculateLayout(); }, {that: this}); this._getElements(); this.calculateLayout(); if(this.options.switchedOff){ this.setSwitchedOffClass(); } } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); if (name == 'switchedOff' || name == 'resetSwitchedOff' &amp;&amp; this.options.switchedOff &amp;&amp; this.options.resetSwitchedOff) { this._unfix(); this.updateChilds(true); this.progress = -2; } else if (name == 'offsetElements' || name == 'bottomOffset' || name == 'topOffset' || (name == 'switchedOff' &amp;&amp; !value)) { this._unfix(); this.element.style.top = ''; this.element.style.bottom = ''; this._getElements(); this.calculateLayout(); } else if (name == 'autoThrottle' &amp;&amp; !value &amp;&amp; !this._throttleOptions.unthrottle) { this._throttleOptions.unthrottle = true; } else if(name == 'scrollContainer'){ this._setScrollingElement(); } if(name == 'switchedOff'){ this.setSwitchedOffClass(); } } setSwitchedOffClass(){ this.element.classList.toggle(rb.statePrefix + 'switched' + rb.nameSeparator + 'off', this.options.switchedOff); } _getElements() { let offsetName; const options = this.options; this.isContainerScroll = false; this.elemStyles = rb.getStyles(this.element); this.offsetElements = options.offsetElements ? this.getElementsByString(options.offsetElements) : [] ; this.posProp = (options.bottomOffset !== false) ? 'bottom' : 'top' ; offsetName = this.posProp + 'Offset'; this.offset = 0; if (options[offsetName] !== false) { this.offset -= options[offsetName]; } if (options.container) { this.container = this.element[options.container] || this.element[isContainerAncestor[options.container]] || this.element.closest(this.interpolateName(options.container)); // if (this.container == document.body || this.container == docElem) { // this.container = null; // } else // if (this.container) { this.isContainerScroll = !!isContainerScroll[getCss(this.container, 'overflowY', false, this.containerStyles) || getCss(this.container, 'overflow', false, this.containerStyles)]; this.containerStyles = rb.getStyles(this.container); } } else { this.container = document.body; } this.calcedOffset = this.offset; this._setScrollingElement(); } _setScrollingElement(){ let curScrollingEventElement; const oldEventElement = this.$scrollEventElem &amp;&amp; this.$scrollEventElem.get(0); if(this.options.scrollContainer){ this.$scrollEventElem = $(this.element).closest(this.options.scrollContainer); curScrollingEventElement = this.$scrollEventElem.get(0); this.scrollingElement = curScrollingEventElement; } if(!this.options.scrollContainer || !this.scrollingElement){ // if (this.isContainerScroll) { // this.$scrollEventElem = this.$container; // curScrollingEventElement = this.$container.get(0); // this.scrollingElement = curScrollingEventElement; // } else { // // } curScrollingEventElement = window; this.$scrollEventElem = $(curScrollingEventElement); this.scrollingElement = document.scrollingElement; } if(oldEventElement != curScrollingEventElement){ if(oldEventElement){ $(oldEventElement).off('scroll', this.checkPosition); } this.$scrollEventElem.on('scroll', this.checkPosition); } } getCalculatedLayout(){ let box, elemOffset, containerBox, containerOffset; const boxes = { minFixedPos: -1, maxFixedPos: Number.MAX_VALUE, minScrollPos: -1, maxScrollPos: Number.MAX_VALUE, }; box = (this.isFixed ? this.clone : this.element).getBoundingClientRect(); if (!box.right &amp;&amp; !box.bottom &amp;&amp; !box.top &amp;&amp; !box.left) { return boxes; } elemOffset = box[this.posProp] + this.scroll; if(this.offsetElements.length){ this.calcedOffset = this.offset - this.offsetElements.reduce((prevValue, element) =&gt; prevValue + element.offsetHeight, 0); } if (this.options.setWidth) { this.elemWidth = (this.isFixed ? this.clone : this.element).offsetWidth; } if (this.posProp == 'top') { boxes.minFixedPos = elemOffset + this.calcedOffset; if (this.options.progress) { boxes.minProgressPos = boxes.minFixedPos; boxes.maxProgressPos = boxes.minFixedPos + this.options.progress; } } else { boxes.maxFixedPos = elemOffset - this.calcedOffset - this.viewportheight; if (this.options.progress) { boxes.minProgressPos = boxes.maxFixedPos - this.options.progress; boxes.maxProgressPos = boxes.maxFixedPos; } } if (this.container) { containerBox = this.container.getBoundingClientRect(); containerOffset = containerBox[this.posProp == 'top' ? 'bottom' : 'top'] + this.scroll; if (this.posProp == 'top') { boxes.maxFixedPos = containerOffset + this.calcedOffset; boxes.minScrollPos = boxes.maxFixedPos - box.height - getCss(this.container, 'padding-bottom', true, this.containerStyles) - getCss(this.element, 'margin-bottom', true, this.elemStyles); boxes.maxFixedPos += 9 - this.calcedOffset; boxes.maxScrollPos = boxes.maxFixedPos; } else { boxes.minFixedPos = containerOffset - docElem.clientHeight - this.calcedOffset; boxes.maxScrollPos = boxes.minFixedPos + box.height + getCss(this.container, 'padding-top', true, this.containerStyles) + getCss(this.element, 'margin-top', true, this.elemStyles); boxes.minFixedPos += 9 + this.calcedOffset; boxes.minScrollPos = boxes.minFixedPos; } } return boxes; } calculateLayout() { this.scroll = this.scrollingElement.scrollTop; this.viewportheight = docElem.clientHeight; this.lastCheck = Date.now(); Object.assign(this, this.getCalculatedLayout()); this._poses = [this.minScrollPos, this.minFixedPos, this.maxFixedPos, this.maxScrollPos, this.minProgressPos, this.maxProgressPos].filter(Sticky.filterPos); this.checkPosition(); } _isNearScroll(pos) { const dif = this.scroll - pos; return dif &lt; 700 + this.viewportheight &amp;&amp; dif &gt; -700 - this.viewportheight; } checkPosition() { if (this.options.switchedOff) { return; } let shouldFix, shouldScroll, shouldWidth, progress, wasProgress; this.scroll = this.scrollingElement.scrollTop; if (Date.now() - this.lastCheck &gt; this.checkTime) { this.calculateLayout(); return; } shouldFix = this.scroll &gt;= this.minFixedPos &amp;&amp; this.scroll &lt;= this.maxFixedPos; shouldScroll = shouldFix &amp;&amp; (this.scroll &gt;= this.minScrollPos &amp;&amp; this.scroll &lt;= this.maxScrollPos); if (this.options.autoThrottle) { this._throttleOptions.unthrottle = this._poses.some(this._isNearScroll, this); } if (shouldFix &amp;&amp; !this.isFixed) { this.elemHeight = this.element.offsetHeight; if (this.options.setWidth) { this.elemWidth = this.element.offsetWidth; } } shouldWidth = shouldFix &amp;&amp; this.isFixed &amp;&amp; this.options.setWidth &amp;&amp; this.element.offsetWidth != this.elemWidth; if (shouldFix != this.isFixed || shouldScroll || this.isScrollFixed || shouldWidth || (this.isFixed &amp;&amp; this._setCalcedOffset != this.calcedOffset)) { this.updateLayout(shouldFix, shouldScroll, shouldWidth); } if ( this.options.progress &amp;&amp; ( (shouldFix &amp;&amp; this.scroll &gt;= this.minProgressPos &amp;&amp; this.scroll &lt;= this.maxProgressPos) || (this.progress !== 0 &amp;&amp; this.progress !== 1) ) ) { progress = Math.max(Math.min((this.scroll - this.minProgressPos) / (this.maxProgressPos - this.minProgressPos), 1), 0); wasProgress = this.progress; if (!shouldFix &amp;&amp; wasProgress == -2) { return; } if (wasProgress != progress) { this.progress = progress; if (progress == 1) { if (!this.isProgressDone) { this.isProgressDone = true; this._setProgressClass(); } } else if (this.isProgressDone) { this.isProgressDone = false; this._setProgressClass(); } this.updateChilds(); this.onprogress.fireWith(this, [progress]); } } } _setProgressClass() { this.element.classList.toggle(rb.statePrefix + 'fixed' + rb.nameSeparator + 'progressed', this.isProgressDone); } updateLayout(shouldFix, shouldScroll, shouldWidth) { let offset, trigger; if (this.options.switchedOff) { return; } if (shouldWidth) { this.element.style.width = this.elemWidth + 'px'; } if (shouldFix) { if (!this.isFixed) { this._fix(); trigger = true; } if (shouldScroll) { this.isScrollFixed = true; offset = this.calcedOffset * -1; if (this.posProp == 'top') { offset += (this.minScrollPos - this.scroll); } else { offset -= this.maxScrollPos - this.scroll; } this.element.style[this.posProp] = offset + 'px'; } else if (this.isScrollFixed || this._setCalcedOffset != this.calcedOffset) { this.isScrollFixed = false; this.element.style[this.posProp] = (this.calcedOffset * -1) + 'px'; } } else if (this.isFixed) { this._unfix(); trigger = true; } this._setCalcedOffset = this.calcedOffset; if (trigger) { this.trigger(); } } _unfix() { if (!this.isFixed) { return; } this.isFixed = false; this.isScrollFixed = false; this.element.classList.remove(rb.statePrefix + 'fixed'); this.detachClone(); this.element.style.position = ''; this.element.style.width = ''; this.element.style[this.posProp] = ''; } _fix() { if (this.isFixed) { return; } this.isFixed = true; this.isScrollFixed = false; this.attachClone(); this.element.classList.add(rb.statePrefix + 'fixed'); this.element.style.position = 'fixed'; if (this.options.setWidth) { this.element.style.width = this.elemWidth + 'px'; } this.element.style[this.posProp] = (this.calcedOffset * -1) + 'px'; } attachClone() { if (!this.$clone) { this.clone = this.element.cloneNode(); this.$clone = $(this.clone); this.$clone .css({visibility: 'hidden'}) .removeClass('js' + rb.nameSeparator + 'rb' + rb.nameSeparator + 'live') .addClass('js' + rb.nameSeparator + 'sticky' + rb.nameSeparator + 'clone') .attr({ 'data-module': '', 'aria-hidden': 'true', }) ; } this.$clone.css({height: this.elemHeight + 'px'}); this.$element.after(this.clone); } detachClone() { if (this.$clone) { this.$clone.detach(); } } attached() { this._setScrollingElement(); rb.resize.on(this.reflow); clearInterval(this.layoutInterval); this.layoutInterval = setInterval(this.reflow, Math.round((999 * Math.random()) + 9999)); } detached() { this.$scrollEventElem.off('scroll', this.checkPosition); rb.resize.off(this.reflow); clearInterval(this.layoutInterval); this.$scrollEventElem = null; } } export default Component.register('sticky', Sticky); × Search results Close "},"utils_contains.js.html":{"id":"utils_contains.js.html","title":"Source: utils/contains.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/contains.js const rb = window.rb; const _contains = function (element) { return element == this || element.contains(this); }; /** * Tests whether an element is inside or equal to a list of elements. * @memberof rb * @param containerElements {Element[]|Element} Array of elements that might contain innerElement. * @param innerElement {Element} An element that might be inside of one of containerElements. * @returns {Element|undefined|null} The first element in containerElements, that contains innerElement or is the innerElement. */ rb.contains = function (containerElements, innerElement) { return Array.isArray(containerElements) ? containerElements.find(_contains, innerElement) : _contains.call(innerElement, containerElements) ? containerElements : null ; }; rb.contains._contains = _contains; export default rb.contains; × Search results Close "},"utils_pubsub.js.html":{"id":"utils_pubsub.js.html","title":"Source: utils/pubsub.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/pubsub.js import rb from './global-rb'; import Callbacks from '../rb_$/$_callbacks'; const eventSpecial = rb.events &amp;&amp; rb.events.special || {}; const throttle = function (fn) { let isRunning, that, args; const promise = Promise.resolve(); const waits = []; const run = ()=&gt;{ isRunning = false; fn.apply(that, args); }; const cleanupWaits = function(){ while(waits.length){ waits.shift()(); } }; const throttled = function(){ that = this; args = arguments; if(!isRunning){ isRunning = true; promise.then(run); } else if(waits.length) { cleanupWaits(); } }; const afterRun = (fn)=&gt;{ if(isRunning){ waits.push(fn); } else { fn(); } }; return { throttled, afterRun, }; }; /** * extends an object with subscribe, unsubscribe and optionally with a publish method. * @param obj {{}} * @param [options] {{}} * @param options.privatePublish=false {boolean} * @param options.topicSeparator=':/' {boolean|string} * @param options.eventName=false {boolean|string} * @param options.eventPromise=false {undefined|boolean|Promise|rb.deferred} * @returns {function} the publish function. */ rb.createPubSub = function(obj, options){ const stores = {}; const stored = {}; const publish = function(topic, data, memoize){ if(stores[topic]){ stores[topic].fireWith(data, [data]); } if(memoize){ stored[topic] = data; } else if(topic in stored){ rb.log('memoize once, memoize always'); } }; const pub = function(topic, data, memoize){ let topics, tmp; if(arguments.length == 3){ if(typeof memoize != 'boolean'){ tmp = data; data = memoize; memoize = tmp; } } publish('', data, memoize); if(options.topicSeparator){ topics = topic.split(options.topicSeparator); if(topics.length &gt; 1){ topic = topics.reduce((mainTpoic, subTopic)=&gt;{ if(mainTpoic){ publish(mainTpoic, data, memoize); } return mainTpoic + options.topicSeparator + subTopic; }); } } if(topic){ publish(topic, data, memoize); } return this; }; options = Object.assign({ privatePublish: false, topicSeparator: ':/', }, options || {}); Object.assign(obj, { subscribe: function(topic, handler, getStored){ let tmp; if(typeof getStored == 'function'){ tmp = handler; handler = getStored; getStored = tmp; } if(!topic){ topic = ''; } if(!stores[topic]){ stores[topic] = Callbacks(); if(options.throttle){ stores[topic]._throttle = throttle(stores[topic].fireWith); stores[topic].fireWith = stores[topic]._throttle.throttled; } } if(options.throttle){ stores[topic]._throttle.afterRun(()=&gt;{ stores[topic].add(handler); }); } else { stores[topic].add(handler); } if(getStored &amp;&amp; topic in stored){ handler.call(stored[topic], stored[topic]); } return this; }, unsubscribe: function(topic, handler){ if(!topic){ topic = ''; } if(stores[topic]){ stores[topic].remove(handler); } return this; }, }); if(!options.privatePublish){ obj.publish = pub; } if(options.eventName){ if(typeof process != 'undefined' &amp;&amp; process.env &amp;&amp; process.env.NODE_ENV != 'production'){ if(rb.events.special[options.eventName]){ rb.logWarn(`special event for ${options.eventName} already exists.`, rb.events.special[options.eventName]); } } eventSpecial[options.eventName] = {}; [['add', 'subscribe'], ['remove', 'unsubscribe']].forEach((action) =&gt; { eventSpecial[options.eventName][action[0]] = function(element, handler, eventOpts = {}){ if(typeof process != 'undefined' &amp;&amp; process.env &amp;&amp; process.env.NODE_ENV != 'production'){ if(element != window &amp;&amp; element != document){ rb.logError('subscribe/unsubscribe only to window/document', arguments); } } const addRemove = ()=&gt;{ obj[action[1]](options.topic, handler, eventOpts.getStored); }; if(eventOpts.eventPromise &amp;&amp; !eventOpts.eventPromise.isDone){ eventOpts.eventPromise.then(addRemove); } else { addRemove(); } }; }); } return pub; }; rb.createPubSub(rb); export default rb.createPubSub; × Search results Close "},"crucial.js.html":{"id":"crucial.js.html","title":"Source: crucial.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: crucial.js import rb from './utils/global-rb'; import getStyles from './utils/get-styles'; let getPseudoToParse; const regStartQuote = /^&quot;?'?&quot;?/; const regEndQuote = /&quot;?'?&quot;?$/; const regEscapedQuote = /\\\\&quot;/g; const removeLeadingQuotes = function (str) { return str &amp;&amp; str.replace(regStartQuote, '').replace(regEndQuote, '').replace(regEscapedQuote, '&quot;'); }; /** * Parses a string using JSON.parse without throwing an error. * @memberof rb * @param str * @returns {*} */ rb.jsonParse = function (str) { let ret; if(str){ try { ret = JSON.parse(str); } catch (e) { //continue } } return ret; }; /** * Parses the CSS content value of a pseudo element using JSON.parse. * @memberof rb * @param element {Element} The element to parse. * @param privateExpando {Symbol|String} * @returns {Object|undefined} */ rb.parsePseudo = function (element, privateExpando) { let ret; const isString = typeof element == 'string'; const value = isString ? element : getPseudoToParse(element) ; if(element &amp;&amp; !isString &amp;&amp; privateExpando){ element[privateExpando] = value; } ret = rb.jsonParse(removeLeadingQuotes(value)); return ret; }; /** * * @param element * @returns {*} */ rb.getPseudo = function(element){ // Get data from hidden elements can be tricky: // IE11 on Win7 does return content: 'none' for before. But can return fontFamily for the before element. (Safari 10 does not return the right fontFamily!.) // Safari 8 does return content: ''|null for before. But can only read content for the element itself. const beforeStyles = rb.getStyles(element, '::before'); let value = beforeStyles.content; const isValueNone = value == 'none'; if((isValueNone || !value) &amp;&amp; element){ if(isValueNone){ value = beforeStyles.fontFamily; } else { value = rb.getStyles(element).content; } } return value; }; /** * @memberof rb * @param element {Element} * @param privateExpando {Symbol|String} * @returns {boolean} */ rb.hasPseudoChanged = function(element, privateExpando){ const value = element[privateExpando]; return getPseudoToParse(element) != value; }; rb.getStyles = getStyles; /** * Parsed global data from Stylesheet (html::before and html::before) * @alias rb.cssConfig * @property cssConfig {Object} * @property cssConfig.mqs {Object} Map of different media queries * @property cssConfig.currentMQ {String} Currently active media query * @property cssConfig.beforeMQ {String} Media query that was active before * @property cssConfig.mqChange {Object} jQuery Callback object to listen for media query changes. * */ const cssConfig = {mqs: {}, currentMQ: '', beforeMQ: ''}; const parseCSS = function () { let mqCallbacks; const root = document.documentElement; const styles = rb.parsePseudo(root) || {}; const currentMQStyle = rb.getStyles(root, '::after'); let currentStyle = ''; const detectMQChange = function () { const nowStyle = currentMQStyle.content; if (currentStyle != nowStyle) { currentStyle = nowStyle; rb.cssConfig.beforeMQ = rb.cssConfig.currentMQ; rb.cssConfig.currentMQ = removeLeadingQuotes(currentStyle); if (rb.$ &amp;&amp; rb.$.Callbacks) { rb.cssConfig.mqChange.fireWith(rb.cssConfig); } } }; const timedDetectMQChange = (function(){ let running = false; let run = function(){ detectMQChange(); run = false; }; return function(){ if(!running){ running = true; setTimeout(run, 9); } }; })(); Object.defineProperty(rb, 'cssConfig', { configurable: true, enumerable: true, writable: true, value: Object.assign(cssConfig, styles), }); Object.defineProperty(cssConfig, 'mqChange', { configurable: true, enumerable: true, get: function () { if (!mqCallbacks) { rb.resize.on(detectMQChange); mqCallbacks = rb.$.Callbacks(); } return mqCallbacks; }, }); document.addEventListener('DOMContentLoaded', timedDetectMQChange); window.addEventListener('load', timedDetectMQChange); detectMQChange(); }; Object.defineProperty(rb, 'cssConfig', { configurable: true, enumerable: true, get: function () { parseCSS(); return cssConfig; }, }); getPseudoToParse = rb.getPseudo; export default rb; × Search results Close "},"utils_debounce.js.html":{"id":"utils_debounce.js.html","title":"Source: utils/debounce.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/debounce.js import rb from './global-rb'; import rAFQueue from './rafqueue'; import rIC from './request-idle-callback'; /** * * @memberof rb * * @param fn {Function} * @param opts * @param opts.delay * @param opts.that * @param opts.write * @returns {Function} * */ rb.debounce = function(fn, opts){ let args, that, timestamp, timeout, isWriteCalled, isReadCalled, frames; const later = function(){ const last = Date.now() - timestamp; if (last &lt; opts.delay || frames &lt; opts.minFrame) { isWriteCalled = false; isReadCalled = false; timeout = setTimeout(later, Math.max(opts.delay - last, (opts.minFrame - frames) * 17)); } else if(!isWriteCalled) { isWriteCalled = true; rAFQueue(later); } else if(!isReadCalled &amp;&amp; !opts.write) { isReadCalled = true; rIC(later); } else { timeout = null; fn.apply(that, args); } }; const countFrames = function(){ frames++; if(timeout){ rAFQueue(countFrames); } }; opts = Object.assign({delay: 100, minFrame: 0}, opts); opts.delay = Math.max(40, opts.delay) - 18; return function(){ timestamp = Date.now(); frames = 0; args = arguments; that = opts.that || this; if (!timeout) { if(opts.minFrame){ rAFQueue(countFrames); } timeout = setTimeout(later, opts.delay); } }; }; export default rb.debounce; × Search results Close "},"utils_escape.js.html":{"id":"utils_escape.js.html","title":"Source: utils/escape.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/escape.js import rb from './global-rb'; const escapeMap = { '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '&gt;': '&amp;gt;', '&quot;': '&amp;quot;', &quot;'&quot;: '&amp;#x27;', '`': '&amp;#x60;', }; // Functions for escaping and unescaping strings to/from HTML interpolation. const createEscaper = function (map) { const escaper = function (match) { return map[match]; }; // Regexes for identifying a key that needs to be escaped const source = '(?:' + Object.keys(map).join('|') + ')'; const testRegexp = new RegExp(source); const replaceRegexp = new RegExp(source, 'g'); return function (string) { string = string == null ? '' : '' + string; return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string; }; }; /** * Converts the characters &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, '&quot;', &quot;'&quot;, and &quot;\\`&quot; in `string` to * their corresponding HTML entities. * * @static * @memberOf rb * @category String * @param {string} [string=''] The string to escape. * @returns {string} Returns the escaped string. * @example * * rb.escape('fred, barney, &amp; pebbles'); * // =&gt; 'fred, barney, &amp;amp; pebbles' */ rb.escape = createEscaper(escapeMap); /* eslint-disable no-undef */ if (!window._) { window._ = {}; } if (!_.escape) { _.escape = rb.escape; } /* eslint-enable no-undef */ export default rb.escape; × Search results Close "},"utils_events.js.html":{"id":"utils_events.js.html","title":"Source: utils/events.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/events.js import rb from './global-rb'; import rbSymbol from './symbol'; const regSplit = /\\s*?,\\s*?|\\s+?/g; rb.events = { _init: function() { this.proxyKey = rbSymbol('_fnProxy'); }, Event: function(type, options){ let event; if(!options){ options = {}; } if(options.bubbles == null){ options.bubbles = true; } if(options.cancelable == null){ options.cancelable = true; } event = new CustomEvent(type, options); if(typeof process != 'undefined' &amp;&amp; process.env &amp;&amp; process.env.NODE_ENV != 'production'){ if(!event.isDefaultPrevented){ event.isDefaultPrevented = function(){ rb.logError('deprecated'); }; } } return event; }, dispatch: function(element, type, options){ const event = this.Event(type, options); element.dispatchEvent(event); return event; }, proxy: function(fn, type, key, proxy){ if(!proxy){ return fn[this.proxyKey] &amp;&amp; fn[this.proxyKey][type] &amp;&amp; fn[this.proxyKey][type][key]; } if(!fn[this.proxyKey]){ fn[this.proxyKey] = {}; } if(!fn[this.proxyKey][type]){ fn[this.proxyKey][type] = {}; } if(!fn[this.proxyKey][type][key]){ fn[this.proxyKey][type][key] = proxy; } if(fn != proxy){ this.proxy(proxy, type, key, proxy); } }, _runDelegate: function(event, target, handler, context, args){ if(!target){return;} let ret; const oldDelegatedTarget = event.delegatedTarget; const oldDelegateTarget = event.delegateTarget; event.delegatedTarget = target; event.delegateTarget = target; ret = handler.apply(context, args); event.delegatedTarget = oldDelegatedTarget; event.delegateTarget = oldDelegateTarget; return ret; }, proxies: { closest: function(handler, selector){ let proxy = rb.events.proxy(handler, 'closest', selector); if(!proxy){ proxy = function(e){ return rb.events._runDelegate(e, e.target.closest(selector), handler, this, arguments); }; rb.events.proxy(handler, 'closest', selector, proxy); } return proxy; }, matches: function(handler, selector){ let proxy = rb.events.proxy(handler, 'matches', selector); if(!proxy){ proxy = function(e){ return rb.events._runDelegate(e, e.target.matches(selector) ? e.target : null, handler, this, arguments); }; rb.events.proxy(handler, 'matches', selector, proxy); } return proxy; }, keycodes: function(handler, keycodes){ let keycodesObj; let proxy = rb.events.proxy(handler, 'keycodes', keycodes); if(!proxy){ proxy = function(e){ if(!keycodesObj){ keycodesObj = keycodes.trim().split(regSplit).reduce(function(obj, value){ obj[value] = true; return obj; }, {}); } if(keycodesObj[e.keyCode]){ return handler.apply(this, arguments); } }; rb.events.proxy(handler, 'keycodes', keycodes, proxy); } return proxy; }, once: function(handler, once, opts, type){ let proxy = rb.events.proxy(handler, 'once', ''); if(!proxy){ proxy = function(e){ const ret = handler.apply(this, arguments); rb.events.remove(e &amp;&amp; e.target || this, type, handler, opts); return ret; }; rb.events.proxy(handler, 'once', '', proxy); } return proxy; }, }, applyProxies: function(handler, opts, type){ let proxy; if(opts){ for(proxy in opts){ if(this.proxies[proxy] &amp;&amp; proxy != 'once'){ handler = this.proxies[proxy](handler, opts[proxy], opts, type); } } if('once' in opts){ handler = this.proxies.once(handler, opts.once, opts, type); } } return handler; }, special: {}, }; rb.events.proxies.delegate = rb.events.proxies.closest; [['add', 'addEventListener'], ['remove', 'removeEventListener']].forEach(function(action){ /** * * @name rb.event.add * * @param element * @param type * @param handler * @param opts */ /** * * @name rb.event.remove * * @param element * @param type * @param handler * @param opts */ rb.events[action[0]] = function(element, type, handler, opts){ if(!this.special[type] || this.special[type].applyProxies !== false){ handler = rb.events.applyProxies(handler, opts, type); } if(this.special[type]){ this.special[type][action[0]](element, handler, opts); } else { const evtOpts = (opts &amp;&amp; (opts.capture || opts.passive)) ? {passive: !!opts.passive, capture: !!opts.capture} : false ; element[action[1]](type, handler, evtOpts); if(typeof process != 'undefined' &amp;&amp; process.env &amp;&amp; process.env.NODE_ENV != 'production'){ rb.debugHelpers.onEventsAdd(element, type, handler, opts); } } }; }); rb.events._init(); export default rb.events; × Search results Close "},"utils_mutate.js.html":{"id":"utils_mutate.js.html","title":"Source: utils/mutate.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/mutate.js const rb = window.rb; const $ = rb.$; const mutationProp = rb.Symbol('mutate'); const createObserver = function(element, fn, opts){ if(window.MutationObserver){ new MutationObserver(fn).observe( element, {childList: true, subtree: !opts.onlyChilds} ); } else { rb.logWarn('no MutationObserver'); } }; const rb_mutate = { /** * @memberOf rb.events.special.rb_mutate * @param {Element} element * @param {Function} handler * @param {Object} [options] * @param {String} [options.selector=*] Selector to search in added and removed Nodes for. (* is fastest) * @param {Boolean} [options.onlyMatches=false] Checks only added/removed nodes for matches against selector, but doesn't search inside those nodes for selector. (onlyMatches=true is faster). * @param {Boolean} [options.onlyChilds=false] Checks only whether childs of `element` and not the hole subtree. (onlyChilds=true is faster) * * @example * //usage in events object of component: * 'rb_mutate:selector(.{name}-cell)': 'onCellChanged', * //improved performance: * 'rb_mutate:selector(.{name}-cell):onlyMatches()': 'onCellChanged', * //even more improved performance: * 'rb_mutate:@(find(.{name}-content)):selector(.{name}-cell):onlyMatches():onlyChilds()': 'onCellChanged', */ add: function (element, handler, options) { options = options || {}; let mutationObj = element[mutationProp]; const selector = (options.selector || '*').trim(); const onlyMatches = options.onlyMatches ? 'matches' : 'query'; const observerKey = options.onlyChilds ? 'childList' : 'subtree'; const key = onlyMatches + '_' + selector; if(!mutationObj){ mutationObj = {}; element[mutationProp] = mutationObj; } if(!mutationObj[observerKey]){ mutationObj[observerKey] = { everything: true, observers: {}, }; addObserver(element, mutationObj[observerKey], options); } if(mutationObj[observerKey].everything){ mutationObj[observerKey].everything = selector == '*'; } if(!mutationObj[observerKey].observers[key]){ mutationObj[observerKey].observers[key] = { selector: selector, onlyMatches: options.onlyMatches, cbs: $.Callbacks(), }; } mutationObj[observerKey].observers[key].cbs.add(handler); }, remove: function (element, fn, opts) { opts = opts || {}; const mutationObj = element[mutationProp]; const selector = (opts.selector || '*').trim(); const onlyMatches = opts.onlyMatches ? 'matches' : 'query'; const key = onlyMatches + '_' + selector; if(mutationObj &amp;&amp; mutationObj[key]){ mutationObj[key].cbs.remove(fn); if(!mutationObj[key].cbs.has()){ mutationObj[key] = null; } } }, _isRelevantMutation: function(nodeList, observer){ let i, len; let ret = observer.selector == '*' &amp;&amp; !!nodeList.length; for(i = 0, len = nodeList.length; i &lt; len &amp;&amp; !ret; i++){ if(nodeList[i].matches(observer.selector) || (!observer.onlyMatches &amp;&amp; nodeList[i].querySelector(observer.selector))){ ret = true; break; } } return ret; }, isRelevantMutation: function(mutationRecord, observer){ return this._isRelevantMutation(mutationRecord.addedNodes, observer) || this._isRelevantMutation(mutationRecord.removedNodes, observer); }, }; function addObserver(element, observersObj, opts){ const observer = function(mutationRecords){ let recordIndex, recordLength, mutation, observerProp, event, observer, calledObservers; if(observersObj.everything){ for(observerProp in observersObj.observers){ if(!event){ event = [{type: 'rb_mutate', target: element, mutationRecords: mutationRecords}]; } observersObj.observers[observerProp].cbs.fireWith(element, event); } } else { for(recordIndex = 0, recordLength = mutationRecords.length; recordIndex &lt; recordLength; recordIndex++){ mutation = mutationRecords[recordIndex]; for(observerProp in observersObj.observers){ observer = observersObj.observers[observerProp]; if((!calledObservers || !calledObservers[observerProp]) &amp;&amp; rb_mutate.isRelevantMutation(mutation, observer)){ if(!event){ event = [{type: 'rb_mutate', target: element, mutationRecords: mutationRecords}]; } if(!calledObservers){ calledObservers = {}; } calledObservers[observerProp] = true; observer.cbs.fireWith(element, event); } } } } }; createObserver(element, observer, opts); } rb.events.special.rb_mutate = rb_mutate; export default rb_mutate; × Search results Close "},"utils_rafs.js.html":{"id":"utils_rafs.js.html","title":"Source: utils/rafs.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/rafs.js import rb from './global-rb'; import rAFQueue from './rafqueue'; /** * Generates and returns a new, rAFed version of the passed function, so that the passed function is always called using requestAnimationFrame. Normally all methods/functions, that mutate the DOM/CSSOM, should be wrapped using `rb.rAF` to avoid layout thrashing. * @memberof rb * @param fn {Function} The function to be rAFed * @param options {Object} Options object * @param options.that=null {Object} The context in which the function should be invoked. If nothing is passed the context of the wrapper function is used. * @param options.queue=false {Object} Whether the fn should be added to an ongoing rAF (i.e.: `false`) or should be queued to the next rAF (i.e.: `true`). * @param options.throttle=false {boolean} Whether multiple calls in one frame cycle should be throtteled to one. * @returns {Function} * * @example * class Foo { * constructor(element){ * this.element = element; * this.changeLayout = rb.rAF(this.changeLayout); * } * * changeLayout(width){ * this.element.classList[width &gt; 800 ? 'add' : 'remove']('is-large'); * } * * measureLayout(){ * this.changeLayout(this.element.offsetWidth); * } * } */ export function rAF(fn, options) { let running, args, that, inProgress; const batchStack = []; const run = function () { running = false; if (!options.throttle) { while (batchStack.length) { args = batchStack.shift(); fn.apply(args[0], args[1]); } } else { fn.apply(that, args); } }; const rafedFn = function () { args = arguments; that = options.that || this; if (!options.throttle) { batchStack.push([that, args]); } if (!running) { running = true; rAFQueue(run, inProgress); } }; if (!options) { options = {}; } inProgress = !options.queue; if (fn._rbUnrafedFn &amp;&amp; rb.log) { rb.log('double rafed', fn); } rafedFn._rbUnrafedFn = fn; return rafedFn; } /* End: rAF helpers */ /* Begin: rAFs helper */ /** * Invokes `rb.rAF` on multiple methodNames of on object. * * @memberof rb * * @param {Object} obj * @param {Object} [options] see more option @ `rb.rAF` * @param {String} options.nameAppendix='' Wether the rafed method should be renamed by appending the given string. * @param {...String} methodNames * * @example * rb.rAFs(this, {throttle: true}, 'renderList', 'renderCircle'); */ export function rAFs(obj) { let options; const args = Array.from(arguments); args.shift(); if (typeof args[0] == 'object') { options = args.shift(); } const nameAppendix = options &amp;&amp; options.nameAppendix || ''; args.forEach(function (fn) { obj[fn + nameAppendix] = rAF(obj[fn], options); }); } export function rafDecorator(options){ return function (t, n, descriptor) { if(typeof descriptor.value == 'function'){ descriptor.value = rAF(descriptor.value, options); } return descriptor; }; } export default function(fn){ return typeof fn == 'function' ? rAF(...arguments) : rAFs(...arguments); } Object.assign(rb, {rAF, rAFs}); × Search results Close "},"utils_fetch.js.html":{"id":"utils_fetch.js.html","title":"Source: utils/fetch.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/fetch.js import './deferred'; const rb = window.rb; const $ = rb.$; const regQuery = (/\\?/); const getData = function (oReq, obj) { obj.xhr = oReq; obj.data = oReq.response || oReq.responseXML || oReq.responseText; obj.text = oReq.responseText; obj.xml = oReq.responseXML; obj.status = oReq.status; if (typeof obj.data != 'object' &amp;&amp; (oReq.getResponseHeader('Content-Type') || '').split(';')[0].endsWith('json')) { try { obj.data = JSON.parse(oReq.responseText) || obj.data; } catch(er){ //continue } } }; /** * Simple XHRequest util that returns a promise. * @memberof rb * @param {String|Object} url Either the URL to send for the request or the options Object. * @param {Object} [options] * @param {String} [options.url] The URL for the request. * @param {String|undefined} [options.username=undefined] The URL for the request. * @param {String|undefined} [options.password=undefined] The URL for the request. * @param {String} [options.type='GET'] The request type to use. * @param {object} [options.data=null] The send data. * @param {object} [options.headers=null] headers to send. * @param {boolean} [options.processData=true] Data should be processed. * @param {boolean} [options.contentType=true] Wether content-Type should be changed. * @param {boolean} [options.rejectAbort=true] XHR abort/cancel will reject promise. * @param {function} [options.beforeSend] A callback function to allow modification of the XHR object before it is send. * @returns {Promise} * * @example * * rb.fetch('api/user.json?id=12') * .then(function(response, xhr){ * console.log(response.data); * }); */ rb.fetch = function (url, options) { if (typeof url == 'object') { options = url; url = options.url; } options = Object.assign({ type: 'get', username: undefined, password: undefined, processData: true, contentType: true, rejectAbort: true, }, options); let abort; let oReq = new XMLHttpRequest(); const promise = rb.deferred(); (function () { let header; let isAborted = false; let data = options.data || null; const value = {opts: options}; const createAbort = function(){ const abortCb = $.Callbacks(); abort = function(){ if(oReq){ getData(oReq, value); isAborted = true; oReq.abort(); value.status = 'canceled'; promise.catch(rb.logWarn); abortCb.fire(value); if(options.rejectAbort){ promise.reject(value); } } }; promise.abort = abort; promise.onAbort = abortCb.add; promise.offAbort = abortCb.remove; }; oReq.addEventListener('load', function () { const status = oReq.status; const isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status == 304; if(isAborted){return;} getData(oReq, value); promise.catch(rb.logWarn); if (isSuccess) { promise.resolve(value, oReq); } else { promise.reject(value, oReq); } oReq = null; }); oReq.addEventListener('error', function () { if(isAborted){return;} getData(oReq, value); promise.catch(rb.logWarn); promise.reject(value, oReq); oReq = null; }); options.type = options.type.toUpperCase(); if(options.processData &amp;&amp; data &amp;&amp; typeof data == 'object' &amp;&amp; !(data instanceof window.FormData)){ const param = $ &amp;&amp; $.param || rb.param; if(param){ data = param(data); } else if(typeof process != 'undefined' &amp;&amp; process.env &amp;&amp; process.env.NODE_ENV != 'production'){ rb.logError('no $.param/rb.param for fetch stringify'); } if(options.type == 'GET'){ url += (regQuery.test(url) ? '&amp;' : '?') + data; data = null; } } oReq.open(options.type, url, true, options.username, options.password); if((!options.headers || !options.headers['Content-type']) &amp;&amp; options.contentType){ if(options.type == 'POST' &amp;&amp; typeof data == 'string'){ oReq.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); } } if(options.headers){ for(header in options.headers){ oReq.setRequestHeader(header, options.headers[header]); } } if (options.beforeSend) { options.beforeSend(oReq); } promise.abort = function(){ createAbort(); return promise.abort(...arguments); }; promise.onAbort = function(){ createAbort(); return promise.onAbort(...arguments); }; promise.offAbort = function(){ createAbort(); return promise.offAbort(...arguments); }; promise.getXhr = function(){ return oReq; }; oReq.send(data); })(); return promise; }; export default rb.fetch; × Search results Close "},"utils_loadscript.js.html":{"id":"utils_loadscript.js.html","title":"Source: utils/loadscript.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/loadscript.js import deferred from './deferred'; const rb = window.rb; const promises = {}; /** * Loads a script and returns a promise. * @memberof rb * * @param src * @param [options={}] * @param options.async * @param options.defer * @param options.instantInject * @returns {Promise} */ rb.loadScript = function (src, options = {}) { if(!promises[src]){ let script = document.createElement('script'); const inject = function () { (document.body || document.documentElement).appendChild(script); script = null; }; promises[src] = deferred(); script.addEventListener('load', ()=&gt; { promises[src].resolve(); }); script.addEventListener('error', () =&gt; { rb.logWarn('load script error. Configure rb.packageConfig? src: ' + src); promises[src].resolve(); }); script.src = src; script.async = !!options.async; script.defer = !!options.defer; if(document.body &amp;&amp; !options.instantInject){ (rb.rAFQueue || requestAnimationFrame)(inject); } else { inject(); } } return promises[src]; }; rb.loadScript.rb_promises = promises; export default rb.loadScript; × Search results Close "},"utils_get-id.js.html":{"id":"utils_get-id.js.html","title":"Source: utils/get-id.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/get-id.js import rb from './global-rb'; let id = Math.round(Date.now() * Math.random()); /** * Returns a unique id based on Math.random and Date.now(). * @memberof rb * @returns {string} */ export default function getID() { id += Math.round(Math.random() * 1000); return id.toString(36); } rb.getID = getID; × Search results Close "},"utils_throttle.js.html":{"id":"utils_throttle.js.html","title":"Source: utils/throttle.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/throttle.js import rb from './global-rb'; import rIC from './request-idle-callback'; import rAFQueue from './rafqueue'; const wait = Promise.resolve(); /** * Throttles a given function * @memberof rb * @param {function} fn - The function to be throttled. * @param {object} [options] - options for the throttle. * @param {object} options.that=null - the context in which fn should be called. * @param {boolean} options.write=false - Whether fn is used to write layout. * @param {boolean} options.read=false - Whether fn is used to read layout. * @param {number} options.delay=200 - the throttle delay. * @param {boolean} options.unthrottle=false - Whether function should be invoked directly. * @param {boolean} options.micro=false - Whether function should be in a micro task if called with a delay of 0. * @returns {function} the throttled function. */ export default function throttle(fn, options) { let running, that, args; let lastTime = 0; const _run = function () { running = false; lastTime = Date.now(); const nowThat = that; const nowArgs = args; that = null; args = null; fn.apply(nowThat, nowArgs); }; let afterAF = function () { rIC(_run); }; const throttel = function () { that = options.that || this; args = arguments; if (running) { return; } let delay = options.delay; running = true; if (options.unthrottle) { _run(); } else { if (delay &amp;&amp; !options.simple) { delay -= (Date.now() - lastTime); } if (delay &lt; 0) { delay = 0; } if(!delay){ if (options.read || options.write) { getAF(); return; } else if (options.micro) { wait.then(getAF); return; } } setTimeout(getAF, delay); } }; let getAF = function () { rAFQueue(afterAF); }; if (!options) { options = {}; } if (!options.delay) { options.delay = 200; } if (options.write) { afterAF = _run; } else if (!options.read) { getAF = _run; } throttel._rbUnthrotteled = fn; return throttel; } rb.throttle = throttle; × Search results Close "},"utils_get-css-numbers.js.html":{"id":"utils_get-css-numbers.js.html","title":"Source: utils/get-css-numbers.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/get-css-numbers.js import getCss from './get-css'; import getStyles from './get-styles'; /** * Sums up all style values of an element * @memberof rb * @param element {Element} * @param styles {String[]} The names of the style properties (i.e. paddingTop, marginTop) * @param onlyPositive {Boolean} Whether only positive numbers should be considered * @returns {number} Total of all style values * @example * var innerWidth = rb.getCSSNumbers(domElement, ['paddingLeft', 'paddingRight', 'width']; */ export default function getCSSNumbers(element, styles, onlyPositive) { let numbers = 0; const cStyles = getStyles(element); if (!Array.isArray(styles)) { styles = [styles]; } for (let i = 0; i &lt; styles.length; i++) { const value = getCss(element, styles[i], true, cStyles); if (!onlyPositive || value &gt; 0) { numbers += value; } } return numbers; } × Search results Close "},"utils_template-if.js.html":{"id":"utils_template-if.js.html","title":"Source: utils/template-if.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/template-if.js import rb from './global-rb'; /** * Returns yes, if condition is true-thy no/empty string otherwise. Can be used inside of [`rb.template`]{@link rb.template} * * @memberOf rb * * @param condition * @param {String} yes * @param {String} [no=&quot;&quot;] * @returns {string} */ export default function iff(condition, yes, no) { return condition ? yes : (no || ''); } rb.if = iff; × Search results Close "},"utils_add-log.js.html":{"id":"utils_add-log.js.html","title":"Source: utils/add-log.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/add-log.js import glob from './glob'; import rb from './global-rb'; const console = glob.console || {}; const log = console.log &amp;&amp; console.log.bind ? console.log : rb.$.noop; //eslint-disable-line no-unused-vars const logs = ['error', 'warn', 'info', 'log'].map(function(errorName, errorLevel){ const fnName = (errorName == 'log') ? 'log' : 'log' + (errorName.charAt(0).toUpperCase()) + (errorName.substr(1)) ; return { name: fnName, errorLevel: errorLevel, fn: (console[errorName] &amp;&amp; console[errorName].bind ? console[errorName] : rb.$.noop).bind(console) }; }); /** * Adds a log method and a isDebug property to an object, which can be muted by setting isDebug to false. * @memberof rb * @param obj {Object} * @param [initial] {Boolean} */ export default function addLog(obj, initial = true) { const fakeLog = ()=&gt;{}; const setValue = function(){ const level = obj.__isDebug; logs.forEach(function(log){ const fn = (level !== false &amp;&amp; (level === true || level &gt;= log.errorLevel)) ? log.fn : fakeLog; obj[log.name] = fn; }); }; obj.__isDebug = initial; setValue(); Object.defineProperty(obj, 'isDebug', { configurable: true, enumerable: true, get: function () { return obj.__isDebug; }, set: function (value) { if(obj.__isDebug !== value){ obj.__isDebug = value; setValue(); } }, }); return obj; } rb.addLog = addLog; × Search results Close "},"utils_get-styles.js.html":{"id":"utils_get-styles.js.html","title":"Source: utils/get-styles.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/get-styles.js /** * Returns the ComputedStyleObject of an element. * @memberof rb * @param element {Element} * @param [pseudo] {String|null} Either `'::after'`, `'::before'` or `null`/`undefined` * @returns {CssStyle} * * @example * rb.getStyles(element).position // returns 'absolute', 'relative' ... */ export default function getStyles(element, pseudo) { let view = element.ownerDocument.defaultView; if (!view.opener) { view = window; } return view.getComputedStyle(element, pseudo || null) || {getPropertyValue: rb.$ &amp;&amp; rb.$.noop, isNull: true}; } × Search results Close "},"utils_prefixed.js.html":{"id":"utils_prefixed.js.html","title":"Source: utils/prefixed.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/prefixed.js const style = document.createElement('b').style; const rb = window.rb; const $ = rb.$; const prefixes = ['Webkit', 'webkit', 'Moz', 'moz', 'Ms', 'ms', 'O', 'o']; /** * Gets a string and returns a prefixed version. If empty string is returned there is no support. * * @memberof rb * * @param {String} name * @param {Object} [object=document.createElement('b').style] * @return {string} */ rb.prefixed = function(name, object){ object = object || style; let i, partName, testName; let ret = ''; name = $.camelCase(name); if(name in object){ ret = name; } if(!ret){ partName = $.camelCase('-' + name); for(i = 0; i &lt; prefixes.length &amp;&amp; !ret; i++){ testName = prefixes[i] + partName; if(testName in object){ ret = testName; break; } } } return ret; }; export default rb.prefixed; × Search results Close "},"utils_symbol.js.html":{"id":"utils_symbol.js.html","title":"Source: utils/symbol.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/symbol.js import rb from './global-rb'; import getId from './get-id'; /** * Returns a Symbol or unique String * @memberof rb * @param {String} description ID or description of the symbol * @type {Function} * @returns {String|Symbol} */ rb.Symbol = window.Symbol; if (!rb.Symbol) { rb.Symbol = function (name) { name = name || '_'; return name + getId(); }; } export default rb.Symbol; × Search results Close "},"utils_template.js.html":{"id":"utils_template.js.html","title":"Source: utils/template.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/template.js const rb = (typeof window != 'undefined' &amp;&amp; window.rb) ? window.rb : {}; if (!rb.escape) { rb.escape = function (str) { return str; }; } // By default, Underscore uses ERB-style template delimiters, change the // following template settings to use alternative delimiters. const settings = { evaluate: /&lt;%([\\s\\S]+?)%&gt;/g, interpolate: /&lt;%=([\\s\\S]+?)%&gt;/g, escape: /&lt;%-([\\s\\S]+?)%&gt;/g, }; // When customizing `templateSettings`, if you don't want to define an // interpolation, evaluation or escaping regex, we need one that is // guaranteed not to match. const noMatch = /(.)^/; // Certain characters need to be escaped so that they can be put into a // string literal. const escapes = { &quot;'&quot;: &quot;'&quot;, '\\\\': '\\\\', '\\r': 'r', '\\n': 'n', '\\u2028': 'u2028', '\\u2029': 'u2029', }; const escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g; const escapeChar = function (match) { return '\\\\' + escapes[match]; }; /** * JavaScript ERB style/EJS/JST micro-templating, taken from Underscore without modifying settings parameter. * * If templates are pre-compiled, this script doesn't need to be included in the production build. * * * @static * @memberOf rb * @param text {String} The string that should transformed into a template function. * @returns {template} * * @example * // using the &quot;interpolate&quot; delimiter to create a compiled template * var compiled = rb.template('hello &lt;%= user %&gt;!'); * compiled({ 'user': 'fred' }); * // =&gt; 'hello fred!' * * // using the HTML &quot;escape&quot; delimiter to escape data property values * var compiled = rb.template('&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;'); * compiled({ 'value': '&lt;script&gt;' }); * // =&gt; '&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;' * * // using the &quot;evaluate&quot; delimiter to execute JavaScript and generate HTML * var compiled = rb.template('&lt;% users.forEach(users, function(user) { %&gt;&lt;li&gt;&lt;%- user %&gt;&lt;/li&gt;&lt;% }); %&gt;'); * compiled({ 'users': ['fred', 'barney'] }); * // =&gt; '&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;' */ rb.template = function (text) { let render, template; // Combine delimiters into one regular expression via alternation. const matcher = new RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source, ].join('|') + '|$', 'g'); // Compile the template source, escaping string literals appropriately. let index = 0; let source = &quot;__p+='&quot;; text.replace(matcher, function (match, escape, interpolate, evaluate, offset) { source += text.slice(index, offset).replace(escapeRegExp, escapeChar); index = offset + match.length; if (escape) { source += &quot;'+\\n((__t=(&quot; + escape + &quot;))==null?'':rb.escape(__t))+\\n'&quot;; } else if (interpolate) { source += &quot;'+\\n((__t=(&quot; + interpolate + &quot;))==null?'':__t)+\\n'&quot;; } else if (evaluate) { source += &quot;';\\n&quot; + evaluate + &quot;\\n__p+='&quot;; } // Adobe VMs need the match returned to produce the correct offset. return match; }); source += &quot;';\\n&quot;; // If a variable is not specified, place data values in local scope. source = 'with(obj||{}){\\n' + source + '}\\n'; source = &quot;var __t,__p='',__j=Array.prototype.join,&quot; + &quot;print=function(){__p+=__j.call(arguments,'');};\\n&quot; + source + 'return __p;\\n'; /* jshint ignore:start */ try { render = new Function('obj', 'rb', source); } catch (e) { e.source = source; throw e; } /* jshint ignore:end */ template = function (data) { return render.call(this, data, rb); }; // Provide the compiled source as a convenience for precompilation. template.source = 'function(obj){\\n' + source + '}'; return template; }; export default rb.template; × Search results Close "},"utils_spring-animation.js.html":{"id":"utils_spring-animation.js.html","title":"Source: utils/spring-animation.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: utils/spring-animation.js import rAFQueue from './rafqueue'; import addLog from './add-log'; import deferred from './deferred'; // aliases const rb = window.rb || {}; const min = Math.min; const max = Math.max; const noop = ()=&gt;{}; const AFTER_OSCILLATION_STIFFNESS = 170; const AFTER_OSCILLATION_DAMPING = 5; /** * SpringAnimation Class * for more realistic animations * * - takes value + velocity (optional) as from value * - configure stiffness, damping (and mass) * - use progress callback */ class SpringAnimation { static get defaults() { return { // spring and obj mass stiffness: 30, damping: 5, mass: 1, // start and end values from: null, // [number, object] { value, velocity } target: null, // keep alive thresholds keepAlivePrecision: SpringAnimation.PRECISION.LOW, // callbacks progress: noop, complete: noop, stop: noop, // debug debug: 'inherit', }; } static get PRECISION() { return { HIGH: 0.001, // use for calculations that require more precisions (0..1) LOW: 0.4, // used for normal animations (pixel precision) }; } constructor(options) { const o = this.options = Object.assign({}, SpringAnimation.defaults, options); addLog(this, this.options.debug === 'inherit' ? rb.isDebug : this.options.debug); // spring stiffness, in kg/s^2 this.stiffness = o.stiffness; this.damping = o.damping; // damping in kg/s this.mass = o.mass; // in kg this._update = this._update.bind(this); if (o.from == null) { this.logError('Can not create springAnimation without start and end values'); return; } this.oscillationCount = 0; this.oscillationDetected = false; this.currentValue = o.from.value || parseFloat(o.from) || 0; this.currentVelocity = o.from.velocity || 0; this.target = o.target; this.averageFrameTime = 10; this.lastUpdate = Date.now(); this.ended = false; this.promise = deferred(); // initial calls this.update(); } get damping(){ return this._damping * -1; } set damping(newValue){ this._damping = Math.abs(newValue) * -1; } set stiffness(newValue){ this._stiffness = Math.abs(newValue) * -1; } get stiffness(){ return this._stiffness * -1; } get mass(){ return this._mass; } set mass(newValue){ this._mass = Math.abs(newValue) || 1; } get target(){ return this._targetValue; } set target(newValue){ this._targetValue = newValue || 0; if(this.ended &amp;&amp; !this.shouldFinish()){ this.ended = false; if(this.promise.isDone){ this.promise = deferred(); } this.update(); } } get currentDisplacement(){ return this.currentValue - this._targetValue; } update() { rAFQueue(this._update, false, true); } _update() { if (this.ended) { return; } const now = Date.now(); // need to keep frame time in bounds (otherwise calcucations gets crazy) const timeElapsed = Math.max(10, Math.min(66.66, now - this.lastUpdate)); // average frame time out, to get a smoother transition this.averageFrameTime = Math.round((2 * this.averageFrameTime + timeElapsed) / 3); const rate = (1 / 1000) * this.averageFrameTime; // calc spring and damper forces const currentDisplacement = this.currentDisplacement; const _forceSpring = this._stiffness * currentDisplacement; // / 1000 / 1000 const _forceDamper = this._damping * ( this.currentVelocity ); // / 1000 // calc acceleration const acceleration = ( _forceSpring + _forceDamper ) / this.mass; // apply acceleration for passed time an update values // velocity in change per second this.currentVelocity = this.currentVelocity + (acceleration * rate); this.currentVelocity = min(Number.MAX_SAFE_INTEGER, max(Number.MIN_SAFE_INTEGER, this.currentVelocity)); this.currentValue = this.currentValue + (this.currentVelocity * rate); this.currentValue = min(Number.MAX_SAFE_INTEGER, max(Number.MIN_SAFE_INTEGER, this.currentValue)); this.lastUpdate = now; // detect oscillation by counting passing of target value back and forth if(!this.oscillationDetected &amp;&amp; (currentDisplacement &gt; 0) !== (this.currentDisplacement &gt; 0)){ this.oscillationCount += 1; if(this.oscillationCount === 30){ this.oscillationDetected = true; this.logWarn( 'SpringAnimation | oscillation detected, adjust your stiffness and damping', { stiffness: this.stiffness, damping: this.damping }, 'or turn oscillationDetection off') ; } } // adjust spring on oscillationDetected if(this.oscillationDetected){ this.stiffness = this.stiffness - ((this.stiffness - AFTER_OSCILLATION_STIFFNESS) / 1000); this.damping = this.damping - ((this.damping - AFTER_OSCILLATION_DAMPING) / 1000); } if (this.averageFrameTime &gt;= 60) { this.logWarn('SpringAnimation | frame rate is very low!'); } this.options.progress(this.getProgressState()); if(this.shouldFinish()) { this.finish(); } else { this.update(); } } shouldFinish(){ const keepAlivePrecision = this.options.keepAlivePrecision; return Math.abs(this.currentDisplacement) &lt;= keepAlivePrecision &amp;&amp; Math.abs(this.currentVelocity) &lt;= keepAlivePrecision; } getProgressState() { return { currentValue: this.currentValue, currentVelocity: this.currentVelocity, }; } stop() { if (!this.ended) { this.options.stop(this.getProgressState()); this.promise.reject(this); } this.ended = true; } finish() { this.ended = true; this.currentValue = this._targetValue; this.promise.resolve(this); rAFQueue(() =&gt; { this.options.progress(this.getProgressState()); this.options.complete(this.getProgressState()); }, false, true); } } rb.SpringAnimation = SpringAnimation; export default SpringAnimation; × Search results Close "},"components_springanimationdemo.js.html":{"id":"components_springanimationdemo.js.html","title":"Source: components/springanimationdemo.js","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Source: components/springanimationdemo.js import rb, { Component } from '../core'; import '../utils/spring-animation'; const $ = Component.$; /** * Class component to create a SpringAnimation Demo * */ class SpringAnimationDemoGroup extends Component { static get defaults() { return { stiffnessBase: 30, stiffnessInc: 20, dampingBase: 4, dampingInc: 2, autostart: true, initialExampleCount: 4, waitBetweenAnimations: 1000, }; } static get events(){ return { 'springanimationdemoended': 'onChildDemoEnded', 'click:closest(.{name}-ctrl-btn)': 'onControlButtonClick' }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.allEnded = true; this.childsWereAtEnd = false; this.templates = Object.assign({}, this.templates, { childTemplate: rb.template(this.query('.{name}-child-template').innerHTML), }); this.rAFs({that: this}, 'createChildComponents', 'removeChildComponent'); this.getElements(); this.updateControlStates(); this.onChildDemoEnded = rb.debounce(this.onChildDemoEnded, { delay: 100 }); this.createChildComponents(this.options.initialExampleCount); } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); switch (name){ case 'autostart': this.updateControlStates(); if(this.allEnded &amp;&amp; value){ this.restartChildComponents(); } break; default: this.log('unknown option was set'); break; } // this.log(name, value, isSticky); } getElements(){ this.childWrapper = this.query('.{name}-childwrapper'); this.inputAutostart = this.query('input[data-{name}-button-type=&quot;autostart&quot;]'); } updateControlStates(){ this.inputAutostart.checked = this.options.autostart; } createChildComponents(count){ const o = this.options; for(let i = 0; i &lt; count; i++){ this.childWrapper.insertAdjacentHTML('beforeend', this.render('childTemplate', { stiffness: o.stiffnessBase + (o.stiffnessInc * i), damping: o.dampingBase + (o.dampingInc * i), })); } this.getChildComponents(); if(o.autostart){ this.restartChildComponents(); } } addChildComponent(){ const o = this.options; const latestChild = this.childCompontents[this.childCompontents.length - 1]; const stiffness = (latestChild ? latestChild.options.stiffness : o.stiffnessBase) + o.stiffnessInc; const damping = (latestChild ? latestChild.options.damping : o.dampingBase) + o.dampingInc; this.childWrapper.insertAdjacentHTML('beforeend', this.render('childTemplate', { stiffness, damping })); this.getChildComponents(); // start added springdemo this.childCompontents[this.childCompontents.length - 1].createSpring(this.childsWereAtEnd); } removeChildComponent(childComp){ const childCompToRemove = childComp || this.childCompontents[this.childCompontents.length - 1]; childCompToRemove.element.remove(); this.getChildComponents(); } getChildComponents(){ return this.childCompontents = this.queryAll('[data-module=&quot;springanimationdemo&quot;]').map(element =&gt; rb.getComponent(element)); } onChildDemoEnded(){ this.allEnded = this.childCompontents.reduce((previousValue, childComp) =&gt; previousValue &amp;&amp; childComp.ended, true); if(this.allEnded){ this.childsWereAtEnd = !this.childsWereAtEnd; if(this.options.autostart){ this.allEnded = false; setTimeout(()=&gt;{ this.restartChildComponents(); }, this.options.waitBetweenAnimations); } } } onControlButtonClick(event){ const type = event.target.getAttribute(this.interpolateName('data-{name}-button-type')); switch (type) { case 'add': this.addChildComponent(); break; case 'remove': this.removeChildComponent(); break; case 'autostart': this.setOption('autostart', !!event.target.checked); break; case 'toggle': this.startStop(); break; default: this.logWarn('unknown control button type:', type); } } startStop(){ if(!this.childCompontents){ this.getChildComponents(); } if(this.allEnded){ this.restartChildComponents(); } else { this.allEnded = true; this.childCompontents.forEach(childComp =&gt; childComp.stopSpring()); } } restartChildComponents(){ if(!this.childCompontents){ this.getChildComponents(); } this.childCompontents.forEach(childComp =&gt; childComp.createSpring(this.childsWereAtEnd)); this.allEnded = false; } } class SpringAnimationDemo extends rb.Component { static get defaults() { return { stiffness: 50, damping: 50 }; } static get events(){ return { 'rb_layoutchange': 'readLayout', 'input:matches([data-{name}-controls)]': 'onControlInput' }; } constructor(element, initialDefaults) { super(element, initialDefaults); this.maxPos = null; this.springAnimation = null; this.latestValue = 0; this.wasAtEnd = false; this._hasEnded = true; // elements this.animateElement = this.query('.{name}-element'); this.inputsForOptions = this.queryAll('[data-{name}-controls]').reduce((inputsForOptions, el)=&gt;{ const optionName = el.getAttribute(this.interpolateName('data-{name}-controls')); inputsForOptions[optionName] = inputsForOptions[optionName] || []; inputsForOptions[optionName].push(el); return inputsForOptions; }, {}); this.readLayout(); } setOption(name, value, isSticky) { super.setOption(name, value, isSticky); if(this.springAnimation &amp;&amp; name in this.springAnimation){ this.springAnimation[name] = value; } } onControlInput(event){ const optionUpdated = event.target.getAttribute(this.interpolateName('data-{name}-controls')); if(!optionUpdated || !(optionUpdated in this.options)){ return; } const newValue = parseFloat(event.target.value) || 0; const inputsForOption = this.inputsForOptions[optionUpdated] || []; inputsForOption.forEach((input)=&gt;{ // if(input !== event.target){ input.value = newValue; // } }); this.setOption(optionUpdated, newValue); } readLayout(){ const newMaxPos = this.element.clientWidth - this.animateElement.clientWidth; if(newMaxPos === this.maxPos){ return; } this.maxPos = newMaxPos; if(this.springAnimation){ this.springAnimation.target = (this.wasAtEnd &amp;&amp; this.springAnimation.currentValue === this.maxPos) ? 0 : this.maxPos; } } get ended(){ return this._hasEnded; } createSpring(wasAtEnd, opts){ if(!this._hasEnded){ return; } this.wasAtEnd = !!wasAtEnd; const springOpts = Object.assign({ from: this.latestValue || (!this.wasAtEnd ? 0 : this.maxPos), target: this.wasAtEnd ? 0 : this.maxPos, stiffness: this.options.stiffness, damping: this.options.damping, start: ()=&gt;{ // add callback for start }, stop: ()=&gt;{ this._hasEnded = true; }, progress: (data)=&gt;{ // this.log(this.animateElement, data); this.setElPos(data); }, complete: ()=&gt;{ this._hasEnded = true; this.trigger('ended'); this.updateStateClass(); }, }, opts); this.springAnimation = new rb.SpringAnimation(springOpts); this._hasEnded = false; this.updateStateClass(); } stopSpring(){ if(this.springAnimation){ this.springAnimation.stop(); } } updateStateClass(){ $(this.animateElement).rbToggleState('spring{-}animated', !this._hasEnded); } setElPos(data){ // instead... draw canvas! this.animateElement.style.transform = `translateX(${data.currentValue}px)`; this.latestValue = data.currentValue; } detached(){ if(this.springAnimation){ this.springAnimation.stop(); this.springAnimation = null; } this.trigger('removed'); } // shift key -&gt; make slow // alt key -&gt; show ghosts (would be better with canvas) } Component.register('springanimationdemogroup', SpringAnimationDemoGroup); export {SpringAnimationDemoGroup, SpringAnimationDemo}; export default Component.register('springanimationdemo', SpringAnimationDemo); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Global Members &lt;constant&gt; measurePhase Returns a promise that is resolved in the measure/read phase. Source: utils/rafqueue.js, line 74 &lt;constant&gt; mutationPhase If no function is given returns a promise that is resolved in the mutation phase Source: utils/rafqueue.js, line 57 Methods map(routes) Parameters: Name Type Description routes Source: utils/router.js, line 179 Example Router.map({ '/'(){ }, '/:lang': { handler({lang}){ return (lang in availableLangs); }, subRoutes: { '/'(){ }, '/user' } }, '*'(){ } }); module:ajaxform(element) Fetches a form using rb.fetch Parameters: Name Type Description element HTMLFormElement Source: utils/ajaxform.js, line 39 Returns: Type Promise × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Modules Classes _childfx _composer_component _focus_component accordion button dialog itemscroller panel panelgroup popover range scrolly shrinknav sticky tabs SpringAnimation SpringAnimationDemoGroup Namespaces rb × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Classes Classes _childfx _composer_component _focus_component accordion button dialog itemscroller panel panelgroup popover range scrolly shrinknav sticky tabs SpringAnimation SpringAnimationDemoGroup Namespaces rb × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Namespaces Classes _childfx _composer_component _focus_component accordion button dialog itemscroller panel panelgroup popover range scrolly shrinknav sticky tabs SpringAnimation SpringAnimationDemoGroup Namespaces rb × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Tutorials Classes _childfx _composer_component _focus_component accordion button dialog itemscroller panel panelgroup popover range scrolly shrinknav sticky tabs SpringAnimation SpringAnimationDemoGroup Namespaces rb × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase rawblockRawblock JS is a simple UI component library, that allows to create re-usable, accessible, responsive and self-contained components using either ES5 or ES6. As a dependency for rawblock either 'rawblock/$.js' or jQuery has to be included. In most cases 'rawblock/$.js', which provides a jQuery like API and adds itself to the rb.$ namespace should be good enough. For older browsers some polyfills (IE11-), namely DOM4 and some ES6 Promise/String/Array/Object polyfills (_polyfills.js) has to be added. Basic Component MarkupIn general the component markup consists of a &quot;js-rb-live&quot; class and data-module attribute with the name of the component as its value. &lt;div class=&quot;js-rb-live&quot; data-module=&quot;my-component&quot;&gt;&lt;/div&gt;Getting started: Writing new componentsA good starting point is to read the API documentation for the rb.live.register method and the rb.Component class. A simple backbone to start playing around would look like this: &lt;div class=&quot;js-rb-live&quot; data-module=&quot;my-component&quot;&gt;&lt;/div&gt;import {Component} from 'rawblock'; Component.register('my-component', class MyComponent extends Component { constructor(element, initialDefaults){ super(element, initialDefaults); this.log(this.element); } });Getting started: Customizing/Extending existing components.All components are classes and added to the rb.components namespace with their name. The button component for example can be found at rb.components.button. × Search results Close "},"module-ajaxform.html":{"id":"module-ajaxform.html","title":"Module: ajaxform","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Module: ajaxform (require(&quot;ajaxform&quot;))(element) Fetches a form using rb.fetch Parameters: Name Type Description element HTMLFormElement Source: utils/ajaxform.js, line 39 Returns: Type Promise Methods &lt;static&gt; getFormFetchOptions(element) Returns option to fetch a form using rb.fetch. Parameters: Name Type Description element HTMLFormElement Source: utils/ajaxform.js, line 14 Returns: Type Object × Search results Close "},"module-validity.html":{"id":"module-validity.html","title":"Module: validity","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Module: validity Source: utils/validity.js, line 1 Methods &lt;static&gt; addRule(rule) Adds a new custom validation rule to the set. Parameters: Name Type Description rule Object Properties Name Type Argument Default Description name String Name of the custom validation rule. rule customValidationRuleCallback The function that runs the validation. Returns false if the rule is not satisfied otherwise false. In case of async validation it has to return a promise/deferred. message String &lt;optional&gt; 'This field is invalid.' Default validation message. isAsync Boolean &lt;optional&gt; false In case the rule works async. isDependent Boolean &lt;optional&gt; false In case the rule not only depends on the value of one field. Source: utils/validity.js, line 51 Example //&lt;input data-val-foo=&quot;This field has to contain 'foo'&quot; /&gt; //or //&lt;input data-foo=&quot;&quot; /&gt; addRule({ name: 'foo', rule(validityInfo){ return validityInfo.value.includes('foo'); } }); &lt;static&gt; check(element) Runs checkElement on multiple elements. Parameters: Name Type Description element Element | Array.&lt;Element&gt; | HTMLFormElement | FieldsetFormElement Source: utils/validity.js, line 228 Returns: Type Promise | false &lt;static&gt; checkElement(element) Runs custom validation rules on an element. Returns a promise if the validation is pending otherwise false. Parameters: Name Type Description element Element Source: utils/validity.js, line 178 Returns: Type false | Promise | Deferred Example checkElement(element); console.log(element.validity.valid); &lt;static&gt; getCustomValidityInfo(element) Returns the validityData of an element. Parameters: Name Type Description element Source: utils/validity.js, line 74 Returns: Type customValidationElementInfo &lt;static&gt; getInvalidVisibleElements(contextElement) Returns all elements that are invalid inside of contextElement. Parameters: Name Type Description contextElement Source: utils/validity.js, line 273 Returns: Type Array.&lt;Element&gt; &lt;static&gt; getVisibleElements(contextElement) Returns all elements that are considered to be validated inside of contextElement. Parameters: Name Type Description contextElement Source: utils/validity.js, line 262 Returns: Type Array.&lt;Element&gt; Type Definitions customValidationElementInfo Type: Object Properties: Name Type Description element Element Reference to the element. $element Object jQuerified version of element. data Object Data object of the element. Retrieved by $element.data(). errorRule Object | null Current validation rule that the element lacks of. value null | Array.&lt;String&gt; | String The value that was used on last validation. valueStr undefined | String The value as string that was used on last validation. prev null | Array.&lt;String&gt; | String The value that the was used on the validation before. isPending false | Promise | Deferred The value that the was used on the validation before. Source: utils/validity.js, line 18 customValidationRuleCallback(validityInfo) This callback is displayed as a global member. Parameters: Name Type Description validityInfo customValidationElementInfo Source: utils/validity.js, line 11 Returns: Type Boolean | Promise | deferred × Search results Close "},"rb.html":{"id":"rb.html","title":"Namespace: rb","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Namespace: rb rb rawblock main object holds classes and util properties and methods to work with rawblock Source: utils/global-rb.js, line 12 Members &lt;static, constant&gt; cssConfig Parsed global data from Stylesheet (html::before and html::before) Properties: Name Type Description cssConfig Object Properties Name Type Description mqs Object Map of different media queries currentMQ String Currently active media query beforeMQ String Media query that was active before mqChange Object jQuery Callback object to listen for media query changes. Source: crucial.js, line 103 &lt;static&gt; escape Converts the characters &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, '&quot;', &quot;'&quot;, and &quot;`&quot; in string totheir corresponding HTML entities. Source: utils/escape.js, line 42 Example rb.escape('fred, barney, &amp; pebbles'); // =&gt; 'fred, barney, &amp;amp; pebbles' &lt;static&gt; Symbol :function Returns a Symbol or unique String Type: function Source: utils/symbol.js, line 11 Methods &lt;static&gt; contains(containerElements, innerElement) Tests whether an element is inside or equal to a list of elements. Parameters: Name Type Description containerElements Array.&lt;Element&gt; | Element Array of elements that might contain innerElement. innerElement Element An element that might be inside of one of containerElements. Source: utils/contains.js, line 12 Returns: The first element in containerElements, that contains innerElement or is the innerElement. Type Element | undefined | null &lt;static&gt; createPubSub(obj [, options]) extends an object with subscribe, unsubscribe and optionally with a publish method. Parameters: Name Type Argument Description obj Object options Object &lt;optional&gt; Properties Name Type Default Description privatePublish boolean false topicSeparator boolean | string ':/' eventName boolean | string false eventPromise undefined | boolean | Promise | rb.deferred false Source: utils/pubsub.js, line 57 Returns: the publish function. Type function &lt;static&gt; debounce(fn, opts) Parameters: Name Type Description fn function opts Properties Name Type Description delay that write Source: utils/debounce.js, line 17 Returns: Type function &lt;static&gt; exports.rAF(fn, options) Generates and returns a new, rAFed version of the passed function, so that the passed function is always called using requestAnimationFrame. Normally all methods/functions, that mutate the DOM/CSSOM, should be wrapped using rb.rAF to avoid layout thrashing. Parameters: Name Type Description fn function The function to be rAFed options Object Options object Properties Name Type Default Description that Object null The context in which the function should be invoked. If nothing is passed the context of the wrapper function is used. queue Object false Whether the fn should be added to an ongoing rAF (i.e.: false) or should be queued to the next rAF (i.e.: true). throttle boolean false Whether multiple calls in one frame cycle should be throtteled to one. Source: utils/rafs.js, line 30 Returns: Type function Example class Foo { constructor(element){ this.element = element; this.changeLayout = rb.rAF(this.changeLayout); } changeLayout(width){ this.element.classList[width &gt; 800 ? 'add' : 'remove']('is-large'); } measureLayout(){ this.changeLayout(this.element.offsetWidth); } } &lt;static&gt; exports.rAFs(obj [, options], methodNames) Invokes rb.rAF on multiple methodNames of on object. Parameters: Name Type Argument Description obj Object options Object &lt;optional&gt; see more option @ rb.rAF Properties Name Type Default Description nameAppendix String '' Wether the rafed method should be renamed by appending the given string. methodNames String &lt;repeatable&gt; Source: utils/rafs.js, line 88 Example rb.rAFs(this, {throttle: true}, 'renderList', 'renderCircle'); &lt;static&gt; fetch(url [, options]) Simple XHRequest util that returns a promise. Parameters: Name Type Argument Description url String | Object Either the URL to send for the request or the options Object. options Object &lt;optional&gt; Properties Name Type Argument Default Description url String &lt;optional&gt; The URL for the request. username String | undefined &lt;optional&gt; The URL for the request. password String | undefined &lt;optional&gt; The URL for the request. type String &lt;optional&gt; 'GET' The request type to use. data object &lt;optional&gt; null The send data. headers object &lt;optional&gt; null headers to send. processData boolean &lt;optional&gt; true Data should be processed. contentType boolean &lt;optional&gt; true Wether content-Type should be changed. rejectAbort boolean &lt;optional&gt; true XHR abort/cancel will reject promise. beforeSend function &lt;optional&gt; A callback function to allow modification of the XHR object before it is send. Source: utils/fetch.js, line 47 Returns: Type Promise Example rb.fetch('api/user.json?id=12') .then(function(response, xhr){ console.log(response.data); }); &lt;static&gt; getPseudo(element) Parameters: Name Type Description element Source: crucial.js, line 61 Returns: Type * &lt;static&gt; hasPseudoChanged(element, privateExpando) Parameters: Name Type Description element Element privateExpando Symbol | String Source: crucial.js, line 86 Returns: Type boolean &lt;static&gt; jsonParse(str) Parses a string using JSON.parse without throwing an error. Parameters: Name Type Description str Source: crucial.js, line 20 Returns: Type * &lt;static&gt; loadScript(src [, options=]) Loads a script and returns a promise. Parameters: Name Type Argument Description src options= &lt;optional&gt; options.async options.defer options.instantInject Source: utils/loadscript.js, line 17 Returns: Type Promise &lt;static&gt; module.exports() Returns a unique id based on Math.random and Date.now(). Source: utils/get-id.js, line 10 Returns: Type string &lt;static&gt; module.exports(fn [, options]) Throttles a given function Parameters: Name Type Argument Description fn function The function to be throttled. options object &lt;optional&gt; options for the throttle. Properties Name Type Default Description that object null the context in which fn should be called. write boolean false Whether fn is used to write layout. read boolean false Whether fn is used to read layout. delay number 200 the throttle delay. unthrottle boolean false Whether function should be invoked directly. micro boolean false Whether function should be in a micro task if called with a delay of 0. Source: utils/throttle.js, line 20 Returns: the throttled function. Type function &lt;static&gt; module.exports(element, styles, onlyPositive) Sums up all style values of an element Parameters: Name Type Description element Element styles Array.&lt;String&gt; The names of the style properties (i.e. paddingTop, marginTop) onlyPositive Boolean Whether only positive numbers should be considered Source: utils/get-css-numbers.js, line 14 Returns: Total of all style values Type number Example var innerWidth = rb.getCSSNumbers(domElement, ['paddingLeft', 'paddingRight', 'width']; &lt;static&gt; module.exports(condition, yes [, no]) Returns yes, if condition is true-thy no/empty string otherwise. Can be used inside of rb.template Parameters: Name Type Argument Default Description condition yes String no String &lt;optional&gt; &quot;&quot; Source: utils/template-if.js, line 13 Returns: Type string &lt;static&gt; module.exports(obj [, initial]) Adds a log method and a isDebug property to an object, which can be muted by setting isDebug to false. Parameters: Name Type Argument Description obj Object initial Boolean &lt;optional&gt; Source: utils/add-log.js, line 25 &lt;static&gt; module.exports(element [, pseudo]) Returns the ComputedStyleObject of an element. Parameters: Name Type Argument Description element Element pseudo String | null &lt;optional&gt; Either '::after', '::before' or null/undefined Source: utils/get-styles.js, line 11 Returns: Type CssStyle Example rb.getStyles(element).position // returns 'absolute', 'relative' ... &lt;static&gt; parsePseudo(element, privateExpando) Parses the CSS content value of a pseudo element using JSON.parse. Parameters: Name Type Description element Element The element to parse. privateExpando Symbol | String Source: crucial.js, line 40 Returns: Type Object | undefined &lt;static&gt; prefixed(name [, object]) Gets a string and returns a prefixed version. If empty string is returned there is no support. Parameters: Name Type Argument Default Description name String object Object &lt;optional&gt; document.createElement('b').style Source: utils/prefixed.js, line 15 Returns: Type string &lt;static&gt; template(text) JavaScript ERB style/EJS/JST micro-templating, taken from Underscore without modifying settings parameter. If templates are pre-compiled, this script doesn't need to be included in the production build. Parameters: Name Type Description text String The string that should transformed into a template function. Source: utils/template.js, line 66 Returns: Type template Example // using the &quot;interpolate&quot; delimiter to create a compiled template var compiled = rb.template('hello &lt;%= user %&gt;!'); compiled({ 'user': 'fred' }); // =&gt; 'hello fred!' // using the HTML &quot;escape&quot; delimiter to escape data property values var compiled = rb.template('&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;'); compiled({ 'value': '&lt;script&gt;' }); // =&gt; '&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;' // using the &quot;evaluate&quot; delimiter to execute JavaScript and generate HTML var compiled = rb.template('&lt;% users.forEach(users, function(user) { %&gt;&lt;li&gt;&lt;%- user %&gt;&lt;/li&gt;&lt;% }); %&gt;'); compiled({ 'users': ['fred', 'barney'] }); // =&gt; '&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;' rAFQueue(fn [, inProgress]) Invokes a function inside a rAF call Parameters: Name Type Argument Default Description fn function the function that should be invoked inProgress boolean &lt;optional&gt; true Whether the fn should be added to an ongoing rAF or should be appended to the next rAF. Source: utils/rafqueue.js, line 38 × Search results Close "},"rb.components._childfx.html":{"id":"rb.components._childfx.html","title":"Class: _childfx","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: _childfx _childfx Abstract class that can be extended to animate child elements according to a progress property. new _childfx(element, initialDefaults) Parameters: Name Type Description element initialDefaults Source: components/_childfx.js, line 52 Example &lt;style type=&quot;sass&quot;&gt; .rb-main { .child-fx { top: 0; transition: all 50ms; (at)include exportToJS(( top: 50, //complicated values like transform/backgroundColor... transform: ( start: &quot;rotate(0deg)&quot;, value: &quot;rotate(10deg)&quot;, ) )); } } &lt;/style&gt; &lt;div class=&quot;rb-main js-rb-live&quot; data-module=&quot;childfxExtension&quot;&gt; &lt;img class=&quot;logo&quot; src=&quot;...&quot; /&gt; &lt;/div&gt; &lt;script&gt; rb.components._childfx.extend('childfxExtension', { init: function(element, initialDefaults){ this._super(element, initialDefaults); this.pos(); }, pos: function(){ this.progress = 0.4; //set number between 0 - 1. this.updateChilds(); } }); &lt;/script&gt; Extends rb.Component Members &lt;static&gt; defaults Properties: Name Type Default Description defaults.switchedOff Boolean false Switches the component off. defaults.childSel String 'find(.child{e}fx)' Child elements that should be animated. String is processed by rb.elementFromStr. Source: components/_childfx.js, line 58 × Search results Close "},"rb.components._composer_component.html":{"id":"rb.components._composer_component.html","title":"Class: _composer_component","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: _composer_component _composer_component Base Class component to create a _ComposerComponent. new _composer_component(element [, initialDefaults]) Parameters: Name Type Argument Description element Element initialDefaults OptionsObject &lt;optional&gt; Source: components/_composer-component.js, line 15 Extends rb.Component × Search results Close "},"rb.components._focus_component.html":{"id":"rb.components._focus_component.html","title":"Class: _focus_component","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: _focus_component _focus_component Base Class component to create a _FocusComponent. new _focus_component(element [, initialDefaults]) Parameters: Name Type Argument Description element Element initialDefaults OptionsObject &lt;optional&gt; Source: components/_focus-component.js, line 22 Extends rb.Component Members &lt;static&gt; defaults Properties: Name Type Default Description defaults.focusDelay Number 0 Default focus delay for setComponentFocus. Can be used to avoid interference between focusing and an animation. defaults.autofocusSel String '' Overrides the js-rb-autofocus selector for the component. Mixes In: rb.Component.defaults Source: components/_focus-component.js, line 30 Methods getFocusElement( [element]) Parameters: Name Type Argument Description element Element | Boolean | String &lt;optional&gt; The element that should be focused. In case a string is passed the string is converted to an element using rb.elementFromStr Source: components/_focus-component.js, line 51 Returns: Type undefined | Element restoreFocus( [checkInside] [, delay]) Restores the focus to the element, that had focus before setComponentFocus was invoked. Parameters: Name Type Argument Description checkInside Boolean &lt;optional&gt; If checkInside is true, the focus is only restored, if the current activeElement is inside the component itself. delay Number &lt;optional&gt; Source: components/_focus-component.js, line 119 setComponentFocus( [element] [, delay]) Sets the focus and remembers the activeElement before. If setComponentFocus is invoked with no argument. The element with the class js-rb-autofocus inside of the component element is focused. Parameters: Name Type Argument Description element Element | Boolean | String &lt;optional&gt; The element that should be focused. In case a string is passed the string is converted to an element using rb.elementFromStr delay Number &lt;optional&gt; The delay that should be used to focus an element. Source: components/_focus-component.js, line 77 storeActiveElement() stores the activeElement for later restore. Source: components/_focus-component.js, line 104 See: rb.Component.prototype.restoreFocus Returns: Type Element × Search results Close "},"rb.components.accordion.html":{"id":"rb.components.accordion.html","title":"Class: accordion","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: accordion accordion Class component to create a accordion component. This component simply just changes some default options of the panelgroup component. new accordion() Source: components/panelgroup.js, line 597 Examples &lt;div class=&quot;rb-accordion js-rb-click&quot; data-module=&quot;accordion&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;accordion-btn&quot; aria-expanded=&quot;true&quot;&gt;1&lt;/button&gt; &lt;div class=&quot;accordion-panel is-open&quot;&gt; {{panelContent}} &lt;/div&gt; &lt;button type=&quot;button&quot; class=&quot;accordion-btn&quot;&gt;2&lt;/button&gt; &lt;div class=&quot;accordion-panel&quot;&gt; {{panelContent}} &lt;/div&gt; &lt;/div&gt; rb.$('.rb-tabs').on('accordionchanged', function(){ console.log(rb.$(this).rbComponent().selectedIndexes); }); Extends rb.components.panelgroup Members &lt;static&gt; defaults Changed options compared to the panelgroup component. Go to rb.components.panelgroup#defaults for detailed option descriptions. Properties: Name Type Default Description toggle Boolean false selectedIndex Number 0 animation String 'slide' adjustScroll String 10 Mixes In: rb.components.panelgroup.defaults Source: components/panelgroup.js, line 608 Methods closeAll( [except]) Closes all panels of a group. If a panel is passed as the except argument, this panel won't be closed. Parameters: Name Type Argument Description except Element | ComponentInstance | Number &lt;optional&gt; Inherited From: rb.components.panelgroup#closeAll Source: components/panelgroup.js, line 320 deselectIndex(index, options) Closes a panel. Parameters: Name Type Description index Number | Element options Object Options are passed to the close method of the panel instance. Inherited From: rb.components.panelgroup#deselectIndex Source: components/panelgroup.js, line 461 Returns: Type Boolean next(options) Selects next panel. Parameters: Name Type Description options Object options Options are passed to the open method of the panel instance. Inherited From: rb.components.panelgroup#next Source: components/panelgroup.js, line 399 openAll( [except]) Opens all panels of a group. If a panel is passed as the except argument, this panel won't be opened. Parameters: Name Type Argument Description except Element | ComponentInstance | Number &lt;optional&gt; Inherited From: rb.components.panelgroup#openAll Source: components/panelgroup.js, line 335 prev(options) Selects previous panel. Parameters: Name Type Description options Object options Options are passed to the open method of the panel instance. Inherited From: rb.components.panelgroup#prev Source: components/panelgroup.js, line 415 selectIndex(index, options) Selects/opens a panel. Parameters: Name Type Description index Number | Element options Object Options are passed to the open method of the panel instance. Inherited From: rb.components.panelgroup#selectIndex Source: components/panelgroup.js, line 450 Returns: Type Boolean toggleAll() Toggles all panel isOpen state Inherited From: rb.components.panelgroup#toggleAll Source: components/panelgroup.js, line 347 × Search results Close "},"rb.components.button.html":{"id":"rb.components.button.html","title":"Class: button","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: button button Class component to create a button. new button(element, initialDefaults) Parameters: Name Type Description element initialDefaults Source: components/button.js, line 24 Example ```html &lt;button type=&quot;button&quot; data-module=&quot;button&quot; class=&quot;js-rb-click&quot; aria-controls=&quot;panel-1&quot; data-button-type=&quot;open&quot;&gt; click me &lt;/button&gt; &lt;div id=&quot;panel-1&quot; data-module=&quot;panel&quot;&gt;&lt;/div&gt; ``` Extends rb.Component Members &lt;static&gt; defaults Properties: Name Type Description defaults Object Properties Name Type Default Description target String &quot;&quot; String that references the target element. Is processed by rb.elementFromStr. type String &quot;toggle&quot; Method name to invoke on target component. preventDefault Boolean false Whether the default click action should prevented. args * null Arguments to be used to invoke target method. Mixes In: rb.Component.defaults Source: components/button.js, line 36 Methods _setTarget( [element]) Changes/sets the target element. Parameters: Name Type Argument Description element Element | String &lt;optional&gt; Source: components/button.js, line 197 getTarget() Returns the current target component of the button Source: components/button.js, line 220 Returns: Type Element × Search results Close "},"rb.components.dialog.html":{"id":"rb.components.dialog.html","title":"Class: dialog","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: dialog dialog Class component to create a modal dialog with a backdrop. new dialog(element [, initialDefaults]) Parameters: Name Type Argument Description element Element initialDefaults OptionsObject &lt;optional&gt; Source: components/dialog.js, line 35 Fires: dialog#event:change Fires before a dialog's `isOpen` state changes; The default behavior can be prevented. dialog#event:changed Fires after a dialog's `isOpen` state changed; Examples &lt;button aria-controls=&quot;dialog-1&quot; data-module=&quot;button&quot; type=&quot;button&quot; class=&quot;js-rb-click&quot;&gt;button&lt;/button&gt; &lt;div id=&quot;dialog-1&quot; class=&quot;rb-dialog&quot; data-module=&quot;dialog&quot;&gt; &lt;div class=&quot;dialog-content&quot;&gt; {{dialogContent}} &lt;/div&gt; &lt;button type=&quot;button&quot; class=&quot;dialog-close&quot;&gt;close&lt;/button&gt; &lt;/div&gt; rb.$('.rb-dialog').rbComponent().open(); rb.$('.rb-dialog').on('dialogchanged', function(){ console.log(rb.$(this).rbComponent().isOpen); }); Extends rb.components._focus_component Members &lt;static&gt; defaults Properties: Name Type Default Description defaults.open Boolean false Whether the dialog should be open by default defaults.appendToBody Boolean true defaults.contentUrl String '' defaults.closeOnEsc Boolean true Whether the dialog should be closed as soon as the user presses the ESC key. defaults.closeOnBackdropClick Boolean true Whether the dialog should be closed as soon as the user clicks on the backdrop. defaults.contentId String '' defaults.backdropClass String '' defaults.setDisplay Boolean true defaults.scrollPadding String | Boolean 'paddingRight' Whether to set a paddingRight/paddingLeft value to the body. defaults.setFocus Boolean | String 'force' Whether the component should set the focus on open. true: sets only focus if js-rb-autofocus is found. 'force': sets focus to dialog, if no 'js-rb-autofocus' was found. Mixes In: rb.components._focus_component.defaults Source: components/dialog.js, line 51 isOpen :boolean Type: boolean Source: components/dialog.js, line 81 Methods close( [options]) Closes the dialog Parameters: Name Type Argument Description options Object &lt;optional&gt; options are passed to the change and changed event Source: components/dialog.js, line 288 Returns: Type boolean getFocusElement( [element]) Parameters: Name Type Argument Description element Element | Boolean | String &lt;optional&gt; The element that should be focused. In case a string is passed the string is converted to an element using rb.elementFromStr Inherited From: rb.components._focus_component#getFocusElement Source: components/_focus-component.js, line 51 Returns: Type undefined | Element open( [options]) Opens the dialog Parameters: Name Type Argument Description options Object &lt;optional&gt; options are passed to the change and changed event Source: components/dialog.js, line 206 Returns: Type boolean restoreFocus( [checkInside] [, delay]) Restores the focus to the element, that had focus before setComponentFocus was invoked. Parameters: Name Type Argument Description checkInside Boolean &lt;optional&gt; If checkInside is true, the focus is only restored, if the current activeElement is inside the component itself. delay Number &lt;optional&gt; Inherited From: rb.components._focus_component#restoreFocus Source: components/_focus-component.js, line 119 setComponentFocus( [element] [, delay]) Sets the focus and remembers the activeElement before. If setComponentFocus is invoked with no argument. The element with the class js-rb-autofocus inside of the component element is focused. Parameters: Name Type Argument Description element Element | Boolean | String &lt;optional&gt; The element that should be focused. In case a string is passed the string is converted to an element using rb.elementFromStr delay Number &lt;optional&gt; The delay that should be used to focus an element. Inherited From: rb.components._focus_component#setComponentFocus Source: components/_focus-component.js, line 77 storeActiveElement() stores the activeElement for later restore. Inherited From: rb.components._focus_component#storeActiveElement Source: components/_focus-component.js, line 104 See: rb.Component.prototype.restoreFocus Returns: Type Element toggle( [options]) Toggles the dialog isOpen state. Parameters: Name Type Argument Description options Object &lt;optional&gt; options are passed to the change and changed event Source: components/dialog.js, line 304 Returns: Type boolean × Search results Close "},"rb.components.itemscroller.html":{"id":"rb.components.itemscroller.html","title":"Class: itemscroller","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: itemscroller itemscroller Class component to create a carousel/slider/itemscroller. new itemscroller(element, initialDefaults) Parameters: Name Type Description element initialDefaults Properties: Name Type Description pageLength Number Returns the page length (page length depends on item cells and scrollStep option) onslide $.CallbackObject Properties Name Type Description add function Add a onslide callback function remove function Remove a onslide callback function Source: components/itemscroller.js, line 89 Fires: componentName#event:change componentName#event:changed componentName#event:changedcompleted componentName#event:pagelengthchange Examples &lt;!-- markup example --&gt; &lt;div class=&quot;rb-itemscroller js-rb-live&quot; data-module=&quot;itemscroller&quot;&gt; {{#if buttons }} &lt;button type=&quot;button&quot; class=&quot;itemscroller-btn-prev&quot; tabindex=&quot;-1&quot; aria-hidden=&quot;true&quot;&gt;{{buttons.prev}}&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;itemscroller-btn-next&quot; tabindex=&quot;-1&quot; aria-hidden=&quot;true&quot;&gt;{{buttons.next}}&lt;/button&gt; {{/if}} &lt;div class=&quot;itemscroller-viewport&quot;&gt; &lt;div class=&quot;itemscroller-content&quot;&gt; {{#each items}} &lt;div class=&quot;itemscroller-cell&quot;&gt; &lt;div class=&quot;dummy-item&quot;&gt;&lt;/div&gt; &lt;/div&gt; {{/each}} &lt;/div&gt; &lt;/div&gt; {{#if pagination}} &lt;div class=&quot;itemscroller-pagination&quot;&gt;&lt;/div&gt; {{/if}} &lt;/div&gt; //combines a select element with an itemscroller $('.rb-itemscroller select.itemscroller-select').each(function(){ var $itemScroller = $(this).closest('.rb-itemscroller'); var $itemSelect = $(this); var itemscroller = $itemScroller.rbComponent(); var buildOptions = function(){ var i, option; $itemSelect.html(''); for(i = 0; i &lt; itemscroller.pageLength; i++){ option = document.createElement('option'); option.value = i; option.text = i; option.selected = i == itemscroller.selectedIndex; $itemSelect.append(option); } }; $itemScroller.on('itemscrollerpagelengthchanged', buildOptions); $itemScroller.on('itemscrollerchanged', function(){ $itemSelect.prop({selectedIndex: itemscroller.selectedIndex}); }); $itemSelect.on('change', function(){ itemscroller.selectedIndex = this.selectedIndex; }); buildOptions(); }); Extends rb.Component Members &lt;static&gt; defaults Properties: Name Type Default Description centerMode Boolean false Whether cells/selected cell should be centered in scroller. carousel Boolean false Whether scroller should be an infinite carousel. selectedIndex Number 0 Initially selected index. scrollStep Number | String 'auto' How many cells to scroll. Either number of cells or 'view' (i.e. viewport component). 'auto' means 1 for centerMode and 'view' otherwise. easing String 'ease-in-out' Easing value for the slide animation. dragEasing String '0.1, 0.25, 0.1, 1.03' Easing value for the slide animation after drag. duration Number 600 Average duration for the slide animation. mouseDrag Boolean true Whether scroller should be draggable via mouse. wheel Boolean true Whether scroller should be draggable via wheel/trackpad scroll. dragExclude String | false false Whether drag/swipe should be excluded on certain element selectors. mandatorySnap Boolean false Whether each page generates a mandatory snap point. paginationItemTpl String The markup for the pagination buttons. excludeCell String | false | undefined false Simple selector to exclude cells from scroller cell. excludeHiddenCells Boolean true Excludes cells that are set to display: none. switchedOff Boolean false Whether the scroller should be turned off. useTransform Boolean true Whether the scroller should use CSS transform3d or left property. usePx Boolean false Whether the scroller should use CSS px units instead of % units. Set this to true if items are not using % as width unit. Mixes In: rb.Component.prototype.defaults Source: components/itemscroller.js, line 112 selectedIndex Returns the selected page index Source: components/itemscroller.js, line 263 selectedIndex Set the selected page index. Source: components/itemscroller.js, line 271 Methods _snapTo(dir, velocity, length) [_snapTo description] Parameters: Name Type Description dir number direction velocity number px in last 300ms length number length moved during last recognition Source: components/itemscroller.js, line 423 getNext( [offset]) Returns next page index from current position Parameters: Name Type Argument Description offset Number &lt;optional&gt; Offset will be added to the current position to allow manipulations Source: components/itemscroller.js, line 500 Returns: Type number getPageIndexOfCell(cellIndex) Returns page index of a specific item cell Parameters: Name Type Description cellIndex Number | Element Either the index of the cell or the cell DOM element Source: components/itemscroller.js, line 562 Returns: Type Number getPrev( [offset]) Returns previous page index from current position Parameters: Name Type Argument Description offset Number &lt;optional&gt; Offset will be added to the current position to allow manipulations Source: components/itemscroller.js, line 530 Returns: Type number isCellVisible(cellIndex [, useEndPos]) Returns whether a specific cell is in scroller viewport Parameters: Name Type Argument Default Description cellIndex Number | Element Either the index of the cell or the cell DOM element useEndPos boolean | Number &lt;optional&gt; false Wether to use the endpos in case of an animating scroller. In case a number is given this will be used. Source: components/itemscroller.js, line 587 Returns: Returns either true|false or 'partial' Type Boolean | String isEndReached( [position]) Returns whether scroller has reached the end point Parameters: Name Type Argument Description position Number &lt;optional&gt; If no pos is given the current position is used Source: components/itemscroller.js, line 778 Returns: Type boolean isStartReached( [position]) Returns whether scroller has reached the start point Parameters: Name Type Argument Description position Number &lt;optional&gt; If no pos is given the current position is used Source: components/itemscroller.js, line 766 Returns: Type boolean selectCell(cellIndex [, noAnimate]) Selects a specifc item cell Parameters: Name Type Argument Description cellIndex Number | Element Either the index of the cell or the cell DOM element noAnimate Boolean | Undefined &lt;optional&gt; If set to true, the page index will be changed without any animations Source: components/itemscroller.js, line 577 selectIndex(index [, noAnimate]) Selects a page index Parameters: Name Type Argument Description index Number The page index, that should selected noAnimate Boolean | Undefined &lt;optional&gt; If set to true, the page index will be changed without any animations Source: components/itemscroller.js, line 680 Returns: Type * | number selectNext( [noAnimate]) Selects next page index based on current position data Parameters: Name Type Argument Description noAnimate &lt;optional&gt; If set to true, the page index will be changed without any animations Source: components/itemscroller.js, line 521 Returns: Type Number | undefined selectNextIndex() Selects next page index based on current index Source: components/itemscroller.js, line 653 selectPrev( [noAnimate]) Selects previous page index based on current position data Parameters: Name Type Argument Description noAnimate &lt;optional&gt; If set to true, the page index will be changed without any animations Source: components/itemscroller.js, line 553 Returns: Type Number | undefined selectPrevIndex() Selects previous page index based on current index Source: components/itemscroller.js, line 665 × Search results Close "},"rb.components.panel.html":{"id":"rb.components.panel.html","title":"Class: panel","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: panel panel Class component to create a panel. The visibility should be handled using CSS. The component mainly toggles the class is-open. new panel(element, initialDefaults) Parameters: Name Type Description element initialDefaults Properties: Name Type Description isOpen Boolean Source: components/panel.js, line 34 Fires: componentName#change Fires before a panel's `isOpen` state changes.event: The default behavior can be prevented. componentName#event:changed Fires after a panel's `isOpen` state changed. Examples &lt;button aria-controls=&quot;panel-1&quot; data-module=&quot;button&quot; type=&quot;button&quot; class=&quot;js-rb-click&quot;&gt;button&lt;/button&gt; &lt;div id=&quot;panel-1&quot; data-module=&quot;panel&quot;&gt; {{panelContent}} &lt;/div&gt; rb.$('.rb-panel').rbComponent().open(); rb.$('.rb-panel').on('panelchanged', function(){ console.log(rb.$(this).rbComponent().isOpen); }); Extends rb.components._focus_component Members &lt;static&gt; defaults Properties: Name Type Description defaults Object Properties Name Type Default Description animation String '' Predefined animation: 'slide'. These should be combined with CSS transitions or animations. easing String '' CSS Easing function for the animation. duration Number 400 Duration of the animation. setFocus Boolean | String true Whether the component should set the focus on open. true: sets only focus if js-rb-autofocus is found. 'force': sets focus to panel, if no 'js-rb-autofocus' was found. closeOnFocusout Boolean false Similar to closeOnOutsideClick, but better from behavior. Caution behavior can be sometimes unpredictable, if multiple buttons do control the panel. closeOnOutsideClick Boolean false Whether the component should be closed, if clicked outside the component. switchedOff Boolean false Turns off panel. resetSwitchedOff Boolean true Resets panel to initial state on reset switch. closeOnEsc Boolean false Whether panel should be closed on esc key. adjustScroll Boolean | Number false If a panel closes and the activeElement is below the panel, the scroll position might be adjusted to hold the activeElement in view. The adjustScroll option can be combined with the 'slide' animation in a accordion component. So that closing a large panel doesn't move the opening panel out of view. Possible values: true, false, any Number but not 0. scrollIntoView Boolean | Number false If a panel opens tries to scroll it into view. itemWrapper String '' Whether the closest itemWrapper should get the class `is-selected-within'. setDisplay Boolean | String false Changes panel to display none if closed. displayTimer Number 5000 Sets time in ms for display setter. Mixes In: rb.components._focus_component.defaults Source: components/panel.js, line 55 Methods close( [options]) Closes the panel Parameters: Name Type Argument Description options Object &lt;optional&gt; Options are dispatched with the event.detail property. Properties Name Type Argument Description animationPrevented Boolean &lt;optional&gt; If true panel closes without animation. Source: components/panel.js, line 418 Returns: Type boolean Example rb.$('.rb-panel').rbComponent().close(); getFocusElement( [element]) Parameters: Name Type Argument Description element Element | Boolean | String &lt;optional&gt; The element that should be focused. In case a string is passed the string is converted to an element using rb.elementFromStr Inherited From: rb.components._focus_component#getFocusElement Source: components/_focus-component.js, line 51 Returns: Type undefined | Element open( [options]) Opens the panel Parameters: Name Type Argument Description options Object &lt;optional&gt; Options are also dispatched with the event.detail property. Properties Name Type Argument Description animationPrevented Boolean &lt;optional&gt; If true panel opens without animation. setFocus Boolean &lt;optional&gt; Overrides the general setFocus option of the component instance. Source: components/panel.js, line 309 Returns: Type boolean Example //opens a panel without animation and without setting focus. rb.$('.rb-panel').rbComponent().open({animationPrevented: true, setFocus: false}); restoreFocus( [checkInside] [, delay]) Restores the focus to the element, that had focus before setComponentFocus was invoked. Parameters: Name Type Argument Description checkInside Boolean &lt;optional&gt; If checkInside is true, the focus is only restored, if the current activeElement is inside the component itself. delay Number &lt;optional&gt; Inherited From: rb.components._focus_component#restoreFocus Source: components/_focus-component.js, line 119 setComponentFocus( [element] [, delay]) Sets the focus and remembers the activeElement before. If setComponentFocus is invoked with no argument. The element with the class js-rb-autofocus inside of the component element is focused. Parameters: Name Type Argument Description element Element | Boolean | String &lt;optional&gt; The element that should be focused. In case a string is passed the string is converted to an element using rb.elementFromStr delay Number &lt;optional&gt; The delay that should be used to focus an element. Inherited From: rb.components._focus_component#setComponentFocus Source: components/_focus-component.js, line 77 storeActiveElement() stores the activeElement for later restore. Inherited From: rb.components._focus_component#storeActiveElement Source: components/_focus-component.js, line 104 See: rb.Component.prototype.restoreFocus Returns: Type Element toggle( [options]) Toogles the panel Parameters: Name Type Argument Description options Object &lt;optional&gt; Options are also dispatched with the event.detail property. Source: components/panel.js, line 406 Returns: Type boolean Example rb.$('.rb-panel').rbComponent().toggle(); × Search results Close "},"rb.components.panelgroup.html":{"id":"rb.components.panelgroup.html","title":"Class: panelgroup","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: panelgroup panelgroup Class component to create a tab-like or an accordion-like component. Associates panelbuttons and panels and manages the isOpen state of the panels. new panelgroup(element) Parameters: Name Type Description element Element Properties: Name Type Description selectedIndexes Array.&lt;Number&gt; The index(es) of the open panel(s) selectedItems Array.&lt;Element&gt; The dom element(s) of the open panel(s) Source: components/panelgroup.js, line 58 Fires: componentName#changed Fires after the `selectedIndexes`/`selectedItems` changes. Note the panel#change and panel#event:changed events are also fired on the panel elements. Examples &lt;div class=&quot;rb-tabs js-rb-click&quot; data-module=&quot;panelgroup&quot; data-panelgroup-toggle=&quot;false&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;panelgroup-ctrl-btn&quot; data-type=&quot;prev&quot;&gt;&amp;lt;&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;panelgroup-ctrl-btn&quot; data-type=&quot;next&quot;&gt;&amp;gt;&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;panelgroup-btn&quot;&gt;1&lt;/button&gt; &lt;div class=&quot;panelgroup-panel&quot;&gt; {{panelContent}} &lt;/div&gt; &lt;button type=&quot;button&quot; class=&quot;panelgroup-btn&quot;&gt;2&lt;/button&gt; &lt;div class=&quot;panelgroup-panel&quot;&gt; {{panelContent}} &lt;/div&gt; &lt;/div&gt; rb.$('.rb-tabs').on('panelgroupchanged', function(){ console.log(rb.$(this).rbComponent().selectedIndexes); }); rb.$('.rb-tabs').rbComponent().next(); Extends rb.components._composer_component Members &lt;static&gt; defaults Properties: Name Type Default Description defaults Object toggle Boolean true Whether a panel button toggles the state of a panel. multiple Boolean false Whether multiple panels are allowed to be open at the same time. If multiple is true toggle is also automatically set to true. selectedIndex Number -1 The initially opened index. If no panel with the class is-open was found. If no panel should be opened by default use -1. (For performance the is-open class should be favored instead of changing this value). closeOnFocusout Boolean false Closes all panels of a group on focusout. animation String '' Possible animations: adaptHeight or slide. These should be combined with CSS transitions or animations. easing String '' Easing function for the animation. duration Number 400 Duration of the animation. adjustScroll Boolean | Number false Sets the adjustScroll option on the panel components. scrollIntoView Boolean | Number false Sets the scrollIntoView option on the panel components. setDisplay Boolean | String false Sets the setDisplay option on the panel components. setFocus Boolean true Whether component should try to focus a js-rb-autofocus element inside of an opening panel. preventDefault Boolean false Whether default click action on &quot;{name}-btn&quot; should be prevented. itemWrapper String '' Set itemWrapper option of the panel instance. switchedOff Boolean false Turns off panelgroup. resetSwitchedOff Boolean true Resets panels to initial state on reset switch. closeOnEsc Boolean false Panel closes on ESC keydown. panelSel String 'find(.{name}{e}panel)' Reference to find all panels associated with this component group. For a nested accordion/tab use &quot;children(.{name}-panel)&quot;. btnSel String 'find(.{name}{e}btn)' Reference to find all panel buttons associated with this component group. For a nested accordion/tab use &quot;children(.{name}-btn)&quot;. groupBtnSel String 'find(.{name}{e}ctrl{-}btn)' Reference to find all panelgroup buttons associated with this component group. For a nested accordion/tab use &quot;children(.{name}-ctrl-btn)&quot;. panelWrapperSel String 'find(.{name}{e}panel{-}wrapper):0' Reference to find the panelwrapper(s) associated with this component group. If no panelwrapper is found the component element is used. For a nested accordion/tab use &quot;children(.{name}-panel-wrapper)&quot;. btnWrapperSel String 'find(.{name}{e}btn{-}wrapper):0' Reference to find the button wrapper(s) associated with this component group. If no button wrapper is found the component element is used. For a nested accordion/tab use &quot;children(.{name}-panel-btn-wrapper)&quot;. Mixes In: rb.components._composer_component.defaults Source: components/panelgroup.js, line 85 Methods closeAll( [except]) Closes all panels of a group. If a panel is passed as the except argument, this panel won't be closed. Parameters: Name Type Argument Description except Element | ComponentInstance | Number &lt;optional&gt; Source: components/panelgroup.js, line 320 deselectIndex(index, options) Closes a panel. Parameters: Name Type Description index Number | Element options Object Options are passed to the close method of the panel instance. Source: components/panelgroup.js, line 461 Returns: Type Boolean next(options) Selects next panel. Parameters: Name Type Description options Object options Options are passed to the open method of the panel instance. Source: components/panelgroup.js, line 399 openAll( [except]) Opens all panels of a group. If a panel is passed as the except argument, this panel won't be opened. Parameters: Name Type Argument Description except Element | ComponentInstance | Number &lt;optional&gt; Source: components/panelgroup.js, line 335 prev(options) Selects previous panel. Parameters: Name Type Description options Object options Options are passed to the open method of the panel instance. Source: components/panelgroup.js, line 415 selectIndex(index, options) Selects/opens a panel. Parameters: Name Type Description index Number | Element options Object Options are passed to the open method of the panel instance. Source: components/panelgroup.js, line 450 Returns: Type Boolean toggleAll() Toggles all panel isOpen state Source: components/panelgroup.js, line 347 × Search results Close "},"rb.components.popover.html":{"id":"rb.components.popover.html","title":"Class: popover","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: popover popover Creates a popover that is positioned/anchored to another element. A11y-Notes: If the popover has structured content use the class js-rb-autofocus inside of/at the popover. If it contains simple text use a aria-live=&quot;polite&quot; or an appropriate role. new popover(element, initialDefaults) Parameters: Name Type Description element initialDefaults Source: components/popover.js, line 26 Example &lt;button aria-controls=&quot;popover-1&quot; data-module=&quot;panelbutton&quot; type=&quot;button&quot; class=&quot;js-rb-click&quot;&gt;button&lt;/button&gt; &lt;div id=&quot;popover-1&quot; data-module=&quot;popover&quot;&gt; {{popoverContent}} &lt;/div&gt; Extends rb.components.panel Members &lt;static&gt; defaults Properties: Name Type Default Description defaults Object positioned Boolean true indicates wether the panel is positioned my String 'center bottom' Indicates the position of the panel. First x than y. Possible values for x 'left', 'center', 'right'. Possible values for y: 'top', 'middle', 'bottom'. Or numeric value: '0' indicates 'left' or 'top' and '50' 'center'/'middle' at String 'center top' Indicates the position of the anchor element. Same possible values as 'my' collision String 'flip' The collision handling. Possible values: 'flip', 'none'. Can be declared separatly for x and y. (i.e. 'flip none') anchor String 'button' The anchor element to position the panel against. 'button' means the associated panelbutton module or if no associated panelbutton is found the opening button module. Accepts als string that are processed with rb.elementFromStr. updateOnResize Boolean true Wether panel position should be updated on resize. closeOnOutsideClick Boolean true Closes panel on outside click. closeOnEsc Boolean true Closes panel on ESC keydown. setDisplay Boolean | String true Changes panel option setDisplay to true. Mixes In: rb.components.panel.defaults Source: components/popover.js, line 42 Methods close( [options]) Closes the panel Parameters: Name Type Argument Description options Object &lt;optional&gt; Options are dispatched with the event.detail property. Properties Name Type Argument Description animationPrevented Boolean &lt;optional&gt; If true panel closes without animation. Inherited From: rb.components.panel#close Overrides: rb.components.panel#close Source: components/panel.js, line 418 Returns: Type boolean Example rb.$('.rb-panel').rbComponent().close(); getFocusElement( [element]) Parameters: Name Type Argument Description element Element | Boolean | String &lt;optional&gt; The element that should be focused. In case a string is passed the string is converted to an element using rb.elementFromStr Inherited From: rb.components._focus_component#getFocusElement Source: components/_focus-component.js, line 51 Returns: Type undefined | Element open(options) Opens the popover Parameters: Name Type Description options Object Properties Name Type Description anchor String | Element Overrides anchor option of instance for current opening. Overrides: rb.components.panel#open Source: components/popover.js, line 160 Returns: Type Boolean restoreFocus( [checkInside] [, delay]) Restores the focus to the element, that had focus before setComponentFocus was invoked. Parameters: Name Type Argument Description checkInside Boolean &lt;optional&gt; If checkInside is true, the focus is only restored, if the current activeElement is inside the component itself. delay Number &lt;optional&gt; Inherited From: rb.components._focus_component#restoreFocus Source: components/_focus-component.js, line 119 setComponentFocus( [element] [, delay]) Sets the focus and remembers the activeElement before. If setComponentFocus is invoked with no argument. The element with the class js-rb-autofocus inside of the component element is focused. Parameters: Name Type Argument Description element Element | Boolean | String &lt;optional&gt; The element that should be focused. In case a string is passed the string is converted to an element using rb.elementFromStr delay Number &lt;optional&gt; The delay that should be used to focus an element. Inherited From: rb.components._focus_component#setComponentFocus Source: components/_focus-component.js, line 77 storeActiveElement() stores the activeElement for later restore. Inherited From: rb.components._focus_component#storeActiveElement Source: components/_focus-component.js, line 104 See: rb.Component.prototype.restoreFocus Returns: Type Element toggle( [options]) Toogles the panel Parameters: Name Type Argument Description options Object &lt;optional&gt; Options are also dispatched with the event.detail property. Inherited From: rb.components.panel#toggle Source: components/panel.js, line 406 Returns: Type boolean Example rb.$('.rb-panel').rbComponent().toggle(); × Search results Close "},"rb.components.range.html":{"id":"rb.components.range.html","title":"Class: range","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: range range Creates a range input control with one are more thumbs. new range(element, initialDefaults) Parameters: Name Type Description element initialDefaults Properties: Name Type Description values Array.&lt;Number&gt; Returns current values of the range control oninput $.CallbackObject Properties Name Type Description add $.CallbackObject Adds a callback function. remove $.CallbackObject Removes a callback function. Source: components/range.js, line 46 Fires: componentName#event:changed Examples &lt;div class=&quot;rb-range js-rb-live&quot; data-module=&quot;range&quot; data-values=&quot;[0, 100]&quot;&gt;&lt;/div&gt; &lt;!-- combined with visible input --&gt; &lt;label for=&quot;range-1&quot;&gt;range&lt;/label&gt; &lt;input value=&quot;10&quot; min=&quot;1&quot; max=&quot;10&quot; type=&quot;number&quot; id=&quot;range-1&quot; /&gt; &lt;div class=&quot;rb-range js-rb-live&quot; data-module=&quot;range&quot; data-inputs=&quot;range-1&quot;&gt;&lt;/div&gt; rb.$('.rb-range').rbComponent().oninput.add(function(index){ console.log('value changing', this.getValues(index)); }); rb.$('.rb-range').on('rangechanged', function(){ console.log('values changed', rb.$(this).rbComponent().getValues()); }); Extends rb.Component Members &lt;static&gt; defaults Properties: Name Type Default Description defaults Object animate Boolean Whether component should set animation class is-animate. Animation has to be done in CSS. axis String 'auto' Possible values: 'auto', 'horizontal', 'vertical'. ('auto' does not work, if we are in a display none wrapper and also adds some perf penalty) inputs String | Boolean 'find(input)' input element(s) to combine with the range. String is processed by rb.elementsFromStr. values Number | Array.&lt;Number&gt; 50 The initial/default value(s) of the range. Only if no inputs are found. step Number | String 1 Stepping for the range. Also allows the string 'any'. max Number 100 The maximum value of the range. If an input with a data-max or max attribute is found its this value is used. min Number 0 The minimum value of the range. If an associated input with a data-max or max attribute is found its value is used. titles null | String | Array.&lt;String&gt; null The title attribute for the thumb(s). (Only if no inputs with a title is found.) labelIds null | String | Array.&lt;String&gt; null The labelIds for the thumb(s). To be used with aria-labelledby. (Only if no inputs with a label are found.) labels null | String | Array.&lt;String&gt; null The labels for the thumb(s). To be used with aria-label. (Only if no inputs with a label are found.) Mixes In: rb.Component.defaults Source: components/range.js, line 63 Methods formatNumber(number) Formats a number to a string. Use rb.i18n.formatNumber, if available. Can be overridden. Parameters: Name Type Description number String | Number Source: components/range.js, line 199 Returns: Type Number getValues( [index]) Returns values or values[index] Parameters: Name Type Argument Description index Number &lt;optional&gt; Source: components/range.js, line 119 Returns: Type Number | Array.&lt;Number&gt; parseNumber(number) Parses a string to a number. Use rb.i18n.parseNumber, if available. Can be overridden. Parameters: Name Type Description number String | Number Source: components/range.js, line 183 Returns: Type Number setValue(value [, index] [, animate]) Set the value of a thumb (and associated input) in the range control. Parameters: Name Type Argument Default Description value Number index Number &lt;optional&gt; 0 animate Boolean &lt;optional&gt; false Source: components/range.js, line 129 stepDown( [factor] [, index] [, animate]) Sets the value of a thumb (and associated input) to the next lower value. Parameters: Name Type Argument Default Description factor Number &lt;optional&gt; index Number &lt;optional&gt; 0 animate Boolean &lt;optional&gt; false Source: components/range.js, line 171 stepUp( [factor] [, index] [, animate]) Sets the value of a thumb (and associated input) to the next higher value. Parameters: Name Type Argument Default Description factor Number &lt;optional&gt; index Number &lt;optional&gt; 0 animate Boolean &lt;optional&gt; false Source: components/range.js, line 150 × Search results Close "},"rb.components.scrolly.html":{"id":"rb.components.scrolly.html","title":"Class: scrolly","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: scrolly scrolly Adds a class is-in-scrollrange if component is inside of a defined viewport range. Additionally can animate child elements based on this range progress. new scrolly(element, initialDefaults) Parameters: Name Type Description element initialDefaults Source: components/scrolly.js, line 76 Examples &lt;style type=&quot;sass&quot;&gt; .rb-logos { (at)include rb-js-export(( from: '-50eh', to: '100vh - 50eh', once: true, throttleDelay: 300, )); .logo { opacity: 0; transition: all 400ms; } &amp;.is-in-scrollrange { .logo { opacity: 1; } } } &lt;/style&gt; &lt;div class=&quot;rb-logos js-rb-live&quot; data-module=&quot;scrolly&quot;&gt; &lt;img class=&quot;logo&quot; src=&quot;...&quot; /&gt; &lt;/div&gt; &lt;style type=&quot;scss&quot;&gt; .rb-logo { (at)include rb-js-export(( from: &quot;-50eh&quot;, to: &quot;100vh - 50eh&quot;, once: true, throttleDelay: 100, childSel: 'find(.logo-item)', )); .logo-item { top: 0; transition: all 50ms; (at)include rb-js-export(( top: 50, //complicated values like transform/backgroundColor... transform: ( start: &quot;rotate(0deg)&quot;, value: &quot;rotate(10deg)&quot;, ) )); } } &lt;/style&gt; &lt;div class=&quot;rb-logos js-rb-live&quot; data-module=&quot;scrolly&quot;&gt; &lt;img class=&quot;logo&quot; src=&quot;...&quot; /&gt; &lt;/div&gt; Extends rb.components._childfx Members &lt;static&gt; defaults Properties: Name Type Default Description defaults Object from String '-100eh' Start point of in range position relative to viewport top. Can be a simple calculation (addition and subtraction) with the following units (vh = viewport height / 100, vw = viewport width / 100, eh = element height / 100, ew = element width / 100, px). See also 'to'. to String '100vh' End point of in range position relative to viewport top. Example: '100vh' places the top of the element at the bottom of the viewport. '100vh - 20eh' Means 20% of the elements top is visible at the bottom of the viewport. once Boolean | String false Possible values: true, false, 'entered'. Whether the component should destroy itself after it was executed once. switchedOff String false Switches the component off. restSwitchedOff Boolean true Whether there should be a full reset after switchedOff option change. throttleDelay Number 0 Delay in ms to check for position change. Setting this to a higher number (50-300) can improve performance. defaults.childSel String 'find(.{name}-element)' Child elements that should be animated. String is processed by rb.elementFromStr. defaults.scrollContainer String | Boolean false Defines a scrollcontainer, if different from html. Mixes In: rb.components._childfx.defaults Source: components/scrolly.js, line 91 × Search results Close "},"rb.components.shrinknav.html":{"id":"rb.components.shrinknav.html","title":"Class: shrinknav","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: shrinknav shrinknav Class component to create a ShrinkNav. new shrinknav(element [, initialDefaults]) Parameters: Name Type Argument Description element Element initialDefaults OptionsObject &lt;optional&gt; Source: components/shrinknav.js, line 23 Fires: componentName#event:changed Example &lt;div class=&quot;js-rb-live&quot; data-module=&quot;shrinknav&quot;&gt;&lt;/div&gt; Extends rb.Component Members &lt;static&gt; defaults Properties: Name Type Default Description measureElement String 'self' The element that is used to measure the full width. Either self or a selector. items String '.children(.{name}{e}item)' The items which may be overflowed. toggleItemSelector String '.{name}{e}toggle{-}item' The items which may be overflowed. minItems Number 2 The minimum items to see in the main bar. minSubItems Number 2 The minimum items to see in the submenu. growItems Boolean false Mixes In: rb.Component.defaults Source: components/shrinknav.js, line 35 × Search results Close "},"rb.components.sticky.html":{"id":"rb.components.sticky.html","title":"Class: sticky","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: sticky sticky Component creates a sticky element, that can be stuck to the top or the bottom of the viewport. Optionally can animate child elements after it has become stuck according to the scroll position. new sticky(element, initialDefaults) Parameters: Name Type Description element initialDefaults Source: components/sticky.js, line 59 Example &lt;header class=&quot;rb-header js-rb-live&quot; data-module=&quot;sticky&quot;&gt; &lt;div class=&quot;header-fx&quot;&gt; &lt;img class=&quot;logo&quot; /&gt; &lt;nav&gt;&lt;!-- ... --&gt;&lt;/nav&gt; &lt;/div&gt; &lt;/header&gt; &lt;style type=&quot;text/scss&quot;&gt; .rb-header { (at)include rb-js-export(( container: false, progress: 100, childSel: 'find(.header-fx)', )); .header-fx { padding: 20px; font-size: 16px; (at)include rb-js-export(( fontSize: 12, paddingTop: 10, paddingBottom: 10 )); } .logo, nav { height: 1em; } } &lt;/style&gt; Extends rb.components._childfx Members &lt;static&gt; defaults Properties: Name Type Default Description container String | Boolean &quot;.is{-}{name}{-}parent&quot; The container element, that is used to calculate the bounds in which the element should be sticky to the viewport. If false its always sticky. Possible values: false, &quot;parent&quot;(direct parent element), &quot;positionedParent&quot;, &quot;.closest-selector&quot;. topOffset Boolean | Number false If a number/string it sets sticky offset to the number. bottomOffset Boolean | Number false If a number/string it sets sticky offset to the number. offsetElements String &quot;&quot; The height of these elements will be added to the calculated top or bottom offset. The elements are retrieved by this.getElementsByString. marginBottomElements String &quot;&quot; The height of these elements will be added to the calculated top or bottom offset. The elements are retrieved by this.getElementsByString. progress Number 0 Defines the distance in pixel a child animation should be added after an animation should be added. setWidth Boolean true Whether the width of the sticky element should be set, while it is stuck. switchedOff Boolean false Turns off the stickyness. (to be used in responsive context). resetSwitchedOff Boolean true Whether a switchedOff change fully resets the styles. autoThrottle Boolean true Tries to throttle layout reads if current scroll position is far away from a changing point. scrollContainer String '' Mixes In: rb.components._childfx.defaults Source: components/sticky.js, line 75 × Search results Close "},"rb.components.tabs.html":{"id":"rb.components.tabs.html","title":"Class: tabs","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: tabs tabs Class component to create a tab component. This component simply just changes some default options of the panelgroup component. new tabs(element, initialDefaults) Parameters: Name Type Description element initialDefaults Source: components/panelgroup.js, line 551 Examples &lt;div class=&quot;rb-tabs js-rb-click&quot; data-module=&quot;tabs&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;tabs-btn&quot; aria-expanded=&quot;true&quot;&gt;1&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;tabs-btn&quot;&gt;2&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;tabs-ctrl-btn&quot; data-type=&quot;prev&quot;&gt;&amp;lt;&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;tabs-ctrl-btn&quot; data-type=&quot;next&quot;&gt;&amp;gt;&lt;/button&gt; &lt;div class=&quot;tabs-panel is-open&quot;&gt; {{panelContent}} &lt;/div&gt; &lt;div class=&quot;tabs-panel&quot;&gt; {{panelContent}} &lt;/div&gt; &lt;/div&gt; rb.$('.rb-tabs').on('tabschanged', function(){ console.log(rb.$(this).rbComponent().selectedIndexes); }); rb.$('.rb-tabs').rbComponent().next(); Extends rb.components.panelgroup Members &lt;static&gt; defaults Changed options compared to the panelgroup component. Go to rb.components.panelgroup#defaults for detailed option descriptions. Properties: Name Type Default Description toggle Boolean false selectedIndex Number 0 animation String 'adaptHeight' Mixes In: rb.components.panelgroup.defaults Source: components/panelgroup.js, line 562 Methods closeAll( [except]) Closes all panels of a group. If a panel is passed as the except argument, this panel won't be closed. Parameters: Name Type Argument Description except Element | ComponentInstance | Number &lt;optional&gt; Inherited From: rb.components.panelgroup#closeAll Source: components/panelgroup.js, line 320 deselectIndex(index, options) Closes a panel. Parameters: Name Type Description index Number | Element options Object Options are passed to the close method of the panel instance. Inherited From: rb.components.panelgroup#deselectIndex Source: components/panelgroup.js, line 461 Returns: Type Boolean next(options) Selects next panel. Parameters: Name Type Description options Object options Options are passed to the open method of the panel instance. Inherited From: rb.components.panelgroup#next Source: components/panelgroup.js, line 399 openAll( [except]) Opens all panels of a group. If a panel is passed as the except argument, this panel won't be opened. Parameters: Name Type Argument Description except Element | ComponentInstance | Number &lt;optional&gt; Inherited From: rb.components.panelgroup#openAll Source: components/panelgroup.js, line 335 prev(options) Selects previous panel. Parameters: Name Type Description options Object options Options are passed to the open method of the panel instance. Inherited From: rb.components.panelgroup#prev Source: components/panelgroup.js, line 415 selectIndex(index, options) Selects/opens a panel. Parameters: Name Type Description index Number | Element options Object Options are passed to the open method of the panel instance. Inherited From: rb.components.panelgroup#selectIndex Source: components/panelgroup.js, line 450 Returns: Type Boolean toggleAll() Toggles all panel isOpen state Inherited From: rb.components.panelgroup#toggleAll Source: components/panelgroup.js, line 347 × Search results Close "},"SpringAnimation.html":{"id":"SpringAnimation.html","title":"Class: SpringAnimation","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: SpringAnimation SpringAnimation SpringAnimation Classfor more realistic animations takes value + velocity (optional) as from value configure stiffness, damping (and mass) use progress callback new SpringAnimation() Source: utils/spring-animation.js, line 22 × Search results Close "},"SpringAnimationDemoGroup.html":{"id":"SpringAnimationDemoGroup.html","title":"Class: SpringAnimationDemoGroup","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase Class: SpringAnimationDemoGroup SpringAnimationDemoGroup Class component to create a SpringAnimation Demo new SpringAnimationDemoGroup() Source: components/springanimationdemo.js, line 10 × Search results Close "},"tutorial-01-basic-module.html":{"id":"tutorial-01-basic-module.html","title":"Tutorial: 01-basic-module","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase 01-basic-module How to create a rawblock component IAs an example component we will create a &quot;slim header&quot;. As soon as the user scrolls down a certain threshold the header gets slim. A full demo can be seen at codesandbox (SlimHeader with rawblock). HTML of our slim header componentA component markup always has to have a data-module attribute with the name of your component and in general a js-rb-live class to indicate, that rawblock should create the UI component immediately. Excursion: Initializing componentsIn general rawblock components have the class js-rb-live to be automatically created, if they are first seen in the document. In case a component only reacts to a click event and only needs to be created at this time, the author can add a js-rb-click class instead. There is also the possibility to use the rb_lazymodules module to lazily create modules as soon as they become visible in the viewport using the js-rb-lazylive class. Or a class can be fully omitted and the component can initialized from JS using the rb.getComponent or this.component method. The functional childs should have a class prefixed with the component name (htmlName). &lt;div class=&quot;js-rb-live&quot; data-module=&quot;slimheader&quot;&gt;&lt;/div&gt;JS-Boilerplate of a rawblock componentimport { Component } from 'rawblock'; export default class SlimHeader extends Component { // The static defaults getter defines the default options of our component. static get defaults(){ return { }; } // The static events getter defines the events rawblock should attach to the DOM. static get events(){ return { }; } // The constructor is invoked to create the rb component constructor(/*element, initialDefaults*/){ super(...arguments); } // attached is invoked either after the constructor or if the DOM element is added to the DOM // Normally the attached method should be used as an antagonist to the detached method. attached(){ } //detached is invoked after the element was removed from the document and should be used to clean up (i.e.: clear timeouts, unbind global events etc.) detached(){ } } //rb.live.register registers the Component class and defines the component name. The class is then added to the `rb.components` namespace (i.e. `rb.components.clearinput`). Component.register('slimheader', SlimHeader); //in your app.js include core files... //import 'rawblock/$'; //import rb from 'rawblock'; //... and your component //import 'slimheader'; //call rb.live.init in your main file to start rawblock. //rb.live.init();SlimHeader JS ClassWorking with optionsFirst we define the threshold as topThreshold in our defaults getter. import { Component } from 'rawblock'; export default class SlimHeader extends Component { static get defaults(){ return { topThreshold: 60 }; } constructor(/*element, initialDefaults*/){ super(...arguments); this.log(this.options.topThreshold); //outputs 60 } } Component.register('slimheader', SlimHeader);A rawblock component can be configured in multiple ways. With JS: import rb from 'rawblock'; //change the default itself (Note: rawblock changes the defaults getter to a defaults object value.) rb.components.slimheader.defaults.topThreshold = 70; //create a new component with changed options and use this instead (Note: rawblock will automatically merge/mixin your defaults object) export default class SuperSlimHeader extends rb.components.slimheader { static get defaults(){ return { topThreshold: 80 }; } } //change the specific component option rb.$('.slimheader').rbComponent().setOption('topThreshold', 90);With HTML: &lt;!-- As one option --&gt; &lt;div data-module=&quot;slimheader&quot; data-slimheader-top-threshold=&quot;100&quot;&gt;&lt;/div&gt; &lt;!-- As an option object (with multiple options) --&gt; &lt;div data-module=&quot;slimheader&quot; data-slimheader-options='{&quot;topThreshold&quot;: 110}'&gt;&lt;/div&gt;With CSS/SCSS .slimheader { @include rb-js-export(( topThreshold: 120, )); }Due to the fact that the threshold is heavily style/layout related it might make sense to configure it with SCSS. It can get really helpful if you plan to act on it responsively. .slimheader { @include rb-js-export(( topThreshold: 120, )); @media (min-width: 120px) { @include rb-js-export(( topThreshold: 180, )); } }By extending/overriding the setOption method it is possible to react to option changes: export default class SlimHeader extends Component { setOption(name, value, isSticky){ super.setOption(name, value, isSticky); if(name == 'topThreshold'){ //do the work } } }EventsJS events can be bound normally or by using the events object. In our case we need to bind the scroll event to the window object. Due to the fact, that the window object remains even if our component is destroyed. It makes sense to use the attached/detached lifecycle callbacks. export default class SuperSlimHeader extends rb.components.slimheader { constructor(/*element, initialDefaults*/){ super(...arguments); this.handleScroll = this.handleScroll.bind(this); } handleScroll(){ } attached(){ window.addEventListener('scroll', this.handleScroll); } detached(){ window.removeEventListener('scroll', this.handleScroll); } }But you can also use the static events object of your component class. Normally rawblock binds all events to the component itself and gives you some options to help with event delegation. But due to the fact that the scroll event happens outside of the component event delegation does not help here. For this you can use the @ event option. Every event option is prefixed with a :. export default class SlimHeader extends Component { static get events(){ return { 'scroll:@(window)': 'handleScroll', }; } constructor(/*element, initialDefaults*/){ super(...arguments); } handleScroll(){ } }About event options:There are 4 different kinds of event options: The @ allows to bind listeners to other elements than the component element. These elements are retrieved by the this.getElementsByString method, which not only allows to use predefined values like &quot;window&quot; or &quot;document&quot;, but also to use jQuery-like traversing methods to select an element (i.e.: &quot;submit:@(closest(form))&quot;, &quot;click:@(next(.item))&quot; etc.). Native event options: capture, once and passive. proxy functions: closest, matches, keycodes and some more. closest can be used for event delegation. For example 'click:closest(.button)' means, if a click happens the proxy function will use the closest method on the event.target and if it finds an element will set the event.delegatedTarget property to this element and call the declared event handler. matches can also be used for event delegation. For example 'change:matches(.input)' means, if a change happens the proxy function will use the matches method on the event.target and if it returns true will set the event.delegatedTarget property to this element and call the declared event handler. Different options for custom events. Adding some logicNow we can fill in some logic to add a class as soon as the header reaches our threshold. export default class SlimHeader extends Component { static get defaults(){ return { topThreshold: 80 }; } static get events(){ return { 'scroll:@(window)': 'handleScroll', }; } constructor(/*element, initialDefaults*/){ super(...arguments); //call handleScroll to get the initial state right this.handleScroll(); } handleScroll(){ this.element.classList.toggle('is-slim', this.options.topThreshold &lt; document.scrollingElement.scrollTop); } } Component.register('slimheader', SlimHeader);Improvements to our current componentThe code above will give us a full functional rawblock component. But it can be improved in multiple ways. Performance considerations classList.toggle is called with a very high frequency, even if the threshold expression has the same result as before. classList.toggle mutates the DOM (= layout write) outside of a requestAnimationFrame, which is likely to produce layout thrashing in a complex application. handleScroll could also be throttled. To fix the first point we will add a isSlim property and only change the class if it has changed export default class SlimHeader extends Component { //..... constructor(/*element, initialDefaults*/){ super(...arguments); this.isSlim = false; this.handleScroll(); } handleScroll(){ const shouldBeSlim = this.options.topThreshold &lt; document.scrollingElement.scrollTop; if(this.isSlim != shouldBeSlim){ this.isSlim = shouldBeSlim; this.element.classList.toggle('is-slim', this.isSlim); } } }To fix the second point rawblock offers a method called this.rAFs. This method can take an unlimited number of method names and will make sure that these methods are called inside a rAF. Due to the fact, that getting document.scrollingElement.scrollTop is a layout read we need to separate it from our layout write classList.toggle. export default class SlimHeader extends Component { //..... constructor(/*element, initialDefaults*/){ super(...arguments); this.isSlim = false; this.rAFs('changeState'); this.calculateState(); } changeState(){ this.element.classList.toggle('is-slim', this.isSlim); } calculateState(){ const shouldBeSlim = this.options.topThreshold &lt; document.scrollingElement.scrollTop; if(this.isSlim != shouldBeSlim){ this.isSlim = shouldBeSlim; this.changeState(); } } }For small DOM changes rawblock also supports jQuery-like functions, that are called in a rAF. To these methods the string &quot;Raf&quot; is appended. In our case the method toggleClassRaf can be used: export default class SlimHeader extends Component { //... calculateState(){ const shouldBeSlim = this.options.topThreshold &lt; document.scrollingElement.scrollTop; if(this.isSlim != shouldBeSlim){ this.isSlim = shouldBeSlim; this.$element.toggleClassRaf('is-slim', this.isSlim); } } }As a more modern way rawblocks also adds the method this.mutationPhase which returns a promise to be likely used in an async method. export default class SlimHeader extends Component { //... async calculateState(){ const shouldBeSlim = this.options.topThreshold &lt; document.scrollingElement.scrollTop; if(this.isSlim != shouldBeSlim){ this.isSlim = shouldBeSlim; await this.mutationPhase(); this.element.classList.toggle('is-slim', this.isSlim); } } }Point 3. could be fixed by using rb.throttle. But I assume that in our refactored case the calculateState is so light, that throttling won't affect the performance too much. import rb, { Component } from 'rawblock'; export default class SlimHeader extends Component { //..... constructor(/*element, initialDefaults*/){ super(...arguments); this.isSlim = false; this.calculateState = rb.throttle(this.calculateState, {read: true}); this.calculateState(); } }The slimheader component can be further improved under the following more rawblock specific aspects: A good component should dispatch an event as soon as it's state changes. This can be realized using the trigger method. The method accepts an event name as also a detail object for further event specific information. The event name is automatically prefixed by the component name (jsName). If a component only has one state that changes or one state can be seen as the main state the component should dispatch a changed state. In case no event name is given, trigger will automatically generate this changed state event prefixed by the component name. (In our case &quot;slimheaderchanged&quot;.) In case you are using a *Raf method to alter your DOM, your trigger call is not done in a rAF method and you want to dispatch the event after the DOM changes are done you can use the method this.triggerRaf. rawblock allows you to define how state classes are defined (prefixed by is-, modifier__ etc.).To support this feature we need to use rb.$.fn.rbToggleState instead of classList.toggle. Building responsive JS components often reveals, that you need to disable/switch off a component under certain media conditions and turn others on. rawblock uses the convention to use the option switchedOff for those cases. In case options.switchedOff is true no event listener bound by the events object is called (Keep in mind, that this won't help, if your bound listeners are called async du to throttling or debouncing.). Often the developer still has to do some work to react to those option changes (cleanup changed markup). In case your specific project needs this or you want to build a general re-usable component you should do this. Our final improved code could look like this: import rb, { Component } from 'rawblock'; export default class SlimHeader extends Component { static get defaults(){ return { topThreshold: 80, }; } static get events(){ return { 'scroll:@(window)': 'calculateState', }; } constructor(/*element, initialDefaults*/){ super(...arguments); this.isSlim = false; this.calculateState = rb.throttle(this.calculateState, {read: true}); this.calculateState(); } setOption(name/*, value, isSticky*/){ super.setOption(...arguments); //if topThreshold or switchedOff option changed re-calculate with these options. if(name == 'topThreshold' || name == 'switchedOff'){ this.calculateState(); } } async calculateState(){ const {switchedOff, topThreshold} = this.options; //if it is switchedOff it is never slim const shouldBeSlim = !switchedOff &amp;&amp; topThreshold &lt; document.scrollingElement.scrollTop; if(this.isSlim != shouldBeSlim){ this.isSlim = shouldBeSlim; await this.mutationPhase(); this.$element.rbToggleState('slim', this.isSlim); // trigger event after render was complete and we are in read mode again (if you need to in form other scripts earlier skip measurePhase) await this.measurePhase(); this.trigger(); } } } Component.register('slimheader', SlimHeader); × Search results Close "},"tutorial-02-extending-components.html":{"id":"tutorial-02-extending-components.html","title":"Tutorial: 02-extending-components","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase 02-extending-components Extending a rawblock component (panelgroup)For this tutorial we will generate some kind of a select list of checkboxes or radio buttons, that opens on a button click. The final demo can be seen on codesandbox. As a base we will use the panelgroup component. A similar component could also be build with the popover component Extend the panelgroupFirst we extend the panelgroup component and register our new component class with the name checklist: import Panelgroup from 'rawblock/components/panelgroup'; import rb, { Component } from 'rawblock'; class CheckList extends Panelgroup { } Component.register('checklist', CheckList); export default CheckList;Excursion: The &quot;name&quot; feature of rawblock.In rawblock events and the CSS classes for elements are prefixed with the component name. For example panels and panelbutton elements for the panelgroup component have the class .panelgroup-panel/.panelgroup-btn. Our checklist component changes this now to .checklist-panel and .checklist-btn. Rawblock has the concept of basically 3 different names: componentName: This is the name that was used to register the component and has to be used in the data-module attribute as also for changing options via the data-* attributes. htmlName (defaults to the componentName): This is the name that is used to prefix element classes and can be changed via the name option. This is especially useful to create new CSS components based on an unmodified normal JS component.&lt;style type=&quot;text/scss&quot;&gt; .herotabs { @include rb-js-export(( name: herotabs, )); } &lt;/style&gt; &lt;div class=&quot;herotabs js-rb-click&quot; data-module=&quot;tabs&quot;&gt; &lt;button class=&quot;herotabs-btn&quot; type=&quot;button&quot; aria-expanded=&quot;true&quot;&gt;Tab 1&lt;/button&gt; &lt;button class=&quot;herotabs-btn&quot; type=&quot;button&quot;&gt;Tab 2&lt;/button&gt; &lt;div class=&quot;herotabs-panel-wrapper&quot;&gt; &lt;div class=&quot;herotabs-panel&quot;&gt;Panel 1&lt;/div&gt; &lt;div class=&quot;herotabs-panel&quot;&gt;Panel 2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; jsName (defaults to the componentName): This is the name that is used to prefix the events which are dispatched by the component. This option can be changed using the jsName option. In most cases you wont change this option. Rawblock gives the developer some methods to deal with these dynamic naming. A developer should use the placeholder {name} in the event object as also inside of method calls like (this.query, this.queryAll, this.$queryAll, this.getElementsByString, this.component). Rawblock also gives a primitive this.interpolateName to deal with this. Of course you are not forced to use this in your components, but we highly recommend it. Checklist markupOur component markup will now look like this. There are 3 different inerhited behavior elements in our component. (checklist-btn, checklist-panel and checklist-panel-close). &lt;div class=&quot;rb-checklist js-rb-click&quot; data-module=&quot;checklist&quot; role=&quot;group&quot; aria-label=&quot;Auswahlliste&quot;&gt; &lt;button class=&quot;checklist-btn&quot; type=&quot;button&quot;&gt; &lt;span class=&quot;checklist-value&quot;&gt;Auswählen&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;checklist-panel&quot;&gt; &lt;div class=&quot;checklist-panel-box&quot;&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;foo&quot;&gt; Option 1&lt;/label&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;foo&quot;&gt; Option 2&lt;/label&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;foo&quot;&gt; Option 3&lt;/label&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;foo&quot;&gt; Option 4&lt;/label&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;foo&quot;&gt; Option 5&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;rb-checklist js-rb-click&quot; data-module=&quot;checklist&quot; role=&quot;group&quot; aria-label=&quot;Auswahlliste&quot;&gt; &lt;button class=&quot;checklist-btn&quot; type=&quot;button&quot;&gt; &lt;span class=&quot;checklist-value&quot;&gt;Auswählen&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;checklist-panel&quot;&gt; &lt;div class=&quot;checklist-panel-box&quot;&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; Option 1&lt;/label&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; Option 2&lt;/label&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; Option 3&lt;/label&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; Option 4&lt;/label&gt; &lt;label class=&quot;checklist-option&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; Option 5&lt;/label&gt; &lt;button type=&quot;button&quot; class=&quot;checklist-panel-close&quot;&gt;close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;We can additionally improve the behavior of the component by adding the attribute aria-haspopup=&quot;true&quot;. This tells rawblocks button component to not only run the default action on click but also if the cursor down key (with the alt key) is pressed. &lt;button class=&quot;checklist-btn&quot; type=&quot;button&quot; aria-haspopup=&quot;true&quot;&gt; &lt;span class=&quot;checklist-value&quot;&gt;Auswählen&lt;/span&gt; &lt;/button&gt;Additionally we can change some of the panelgroup default options: class CheckList extends Panelgroup { static get defaults() { return { closeOnFocusout: true, autofocusSel: 'input[type=&quot;checkbox&quot;], input[type=&quot;radio&quot;]', closeOnEsc: true, }; } }Adding some custom logic to our component.We are now pretty close to our final component behavior. What we need to change is add the label text of the selected options into our .checklist-value element. To do this, we first save the current value .checklist-value as a default value and then check write the function to update its content. class CheckList extends Panelgroup { //... initItemOptions(){ // get the value element this.valueElement = this.query('.{name}-value'); // ... and save the textContent as the defaultValue. this.defaultValue = this.valueElement &amp;&amp; this.valueElement.textContent || ''; this.currentValue = this.defaultValue; } static get events(){ return { // run updateValue everytime a checkbox/rawdio button changes 'change:matches(input[type=&quot;checkbox&quot;], input[type=&quot;radio&quot;])': 'updateValue', }; } updateValue(){ // get the textContent of all checked options const currentValue = this.queryAll(':checked') .map(CheckList.getLabelContent).join(', ') || this.defaultValue ; // if it has changed update the value element if(currentValue != this.currentValue){ this.currentValue = currentValue; this._updateValue(); } } static getLabelContent(input){ return input.closest('label, li').textContent; } _updateValue(){ if(this.valueElement){ this.valueElement.innerText = this.currentValue; } //trigger checklistvaluechanged this.trigger('valuechanged'); } }Additionally we also want to automatically close the list if a radio button, but not a checkbox was changed. To do this we refactor the change handler. The panelgroup gives us a nice method called closeAll to do exactly this. class CheckList extends Panelgroup { static get defaults() { return { closeOnFocusout: true, autofocusSel: 'input[type=&quot;checkbox&quot;], input[type=&quot;radio&quot;]', closeOnEsc: true, }; } static get events(){ return { 'change:matches(input[type=&quot;checkbox&quot;], input[type=&quot;radio&quot;])': function(e, _superHandler){ if(e.target.type == 'radio'){ this.closeAll(); } this.updateValue(); }, }; } }The event handler is not only passed the event object, but also a function, that will invoke a possible overridden handler defined in a super class. A11y fixesUnfortunately the change event is also dispatched by using the keyboard to navigate in the radio group. To only close the list if it was handled by mouse we add a mouseup listener. Our final component JS looks now like this: import Panelgroup from 'rawblock/components/panelgroup'; import rb, { Component } from 'rawblock'; class CheckList extends Panelgroup { static get defaults() { return { closeOnFocusout: true, autofocusSel: 'input[type=&quot;checkbox&quot;], input[type=&quot;radio&quot;]', closeOnEsc: true, }; } static get events(){ return { 'mouseup:closest(.{name}-panel)': function(_e, _superHandler){ this._allowOptionClose = true; clearTimeout(this._allowOptionCloseTimer); this._allowOptionCloseTimer = setTimeout(()=&gt;{ this._allowOptionClose = false; }, 9); }, 'change:matches(input[type=&quot;checkbox&quot;], input[type=&quot;radio&quot;])': function(e, _superHandler){ if(this._allowOptionClose &amp;&amp; e.target.type == 'radio'){ this.closeAll(); } this.updateValue(); }, }; } static getLabelContent(input){ return input.closest('label, li').textContent; } constructor(/*element, initialDefaults*/){ super(...arguments); this.rAFs('_updateValue'); this.initItemOptions(); this.updateValue(); } initItemOptions(){ this.valueElement = this.query('.{name}-value'); this.defaultValue = this.valueElement &amp;&amp; this.valueElement.textContent || ''; this.currentValue = this.defaultValue; } updateValue(){ const currentValue = this.queryAll(':checked') .map(CheckList.getLabelContent).join(', ') || this.defaultValue ; if(currentValue != this.currentValue){ this.currentValue = currentValue; this._updateValue(); } } _updateValue(){ if(this.valueElement){ this.valueElement.innerText = this.currentValue; } this.trigger('valuechanged'); } } Component.register('checklist', CheckList); export default CheckList;As a small refinement you can now add a simple animation to the component. .rb-checklist { @include rb-js-export(( animation: slide, )); }final codesandbox demo. × Search results Close "},"tutorial-03-communicating-composing-components.html":{"id":"tutorial-03-communicating-composing-components.html","title":"Tutorial: 03-communicating-composing-components","body":" DocStrap Namespaces rb Modules ajaxformvalidity Classes rb.components._childfxrb.components._composer_componentrb.components._focus_componentrb.components.accordionrb.components.buttonrb.components.dialogrb.components.itemscrollerrb.components.panelrb.components.panelgrouprb.components.popoverrb.components.rangerb.components.scrollyrb.components.shrinknavrb.components.stickyrb.components.tabsSpringAnimationSpringAnimationDemoGroup Tutorials 01-basic-module02-extending-components03-communicating-composing-components Global mapmeasurePhasemutationPhase 03-communicating-composing-components Commmunicating between components and composing componentsFor this tutorial we will build two very simple components. The first component is a native select element that controls the isOpen state of panels. The markup of the component and its controlled elements looks like this: &lt;select class=&quot;js-rb-click&quot; data-module=&quot;selectcontrol&quot;&gt; &lt;option&gt;Keine Auswahl&lt;/option&gt; &lt;option data-open-panel=&quot;panel-1&quot;&gt;Opens panel 1&lt;/option&gt; &lt;option&gt;Closes panel 2&lt;/option&gt; &lt;option&gt;Opens panel 3&lt;/option&gt; &lt;/select&gt; &lt;div id=&quot;panel-1&quot; class=&quot;rb-panel&quot;&gt; &lt;p&gt;Panel 1&lt;/p&gt; &lt;/div&gt;Due to the fact, that our component does only need to be initialized after the user interacts with it, we add the js-rb-click instead the js-rb-live class. The basic JS codeimport { Component } from 'rawblock'; class Selectcontrol extends Component { static get events(){ return { change: 'change' } } constructor(element, initialDefaults) { super(element, initialDefaults); this.change(); } change(){ const openPanel = this.$queryAll(':checked').data('openPanel'); if(openPanel){ this.component(openPanel, 'panel').open(); } } } Component.register('selectcontrol', Selectcontrol);The × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
